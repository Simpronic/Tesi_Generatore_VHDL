library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;
library work;
use work.AESA_if_pkg.all;
entity DAC_AD5724_mst is generic(DAC_D_IN_LEN_g : integer := 24); port(clk_i:in std_logic; rst_n_i:in std_logic; clk_en_i:in std_logic; start_i:in std_logic; strobe_i:in std_logic; done_o:out std_logic; data_i:in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o:out std_logic; sda_o:out std_logic; ldac_o:out std_logic; cs_o:out std_logic); end DAC_AD5724_mst;
clk_i : in std_logic;
rst_n_i : in std_logic;
clk_en_i : in std_logic;
start_i : in std_logic;
strobe_i : in std_logic;
done_o : out std_logic;
data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0);
scl_o : out std_logic;
sda_o : out std_logic;
ldac_o : out std_logic;
cs_o : out std_logic;
entity DAC_AD5724_mst is generic (DAC_D_IN_LEN_g : integer := 24); port (clk_i : in std_logic; rst_n_i : in std_logic; clk_en_i : in std_logic; start_i : in std_logic; strobe_i : in std_logic; done_o : out std_logic; data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o : out std_logic; sda_o : out std_logic; ldac_o : out std_logic; cs_o : out std_logic); end DAC_AD5724_mst;
architecture arch of DAC_AD5724_mst is begin ;  end arch
signal i_bit_counter : integer range 0 to 24;
signal i_dly_counter : integer range 0 to 400;
signal i_slc_counter : integer range 0 to 100;
signal i_scl_cnt : integer range 0 to 24;
signal i_ldac_dly_cnt : integer range 0 to 20;
signal i_ldac_cnt : integer range 0 to 4;
signal i_clk_cnt : integer range 0 to 2;
signal i_cs : std_logic;
signal i_done : std_logic;
signal i_scl : std_logic;
signal i_sda : std_logic;
signal i_ldac : std_logic;
signal i_sck_cpy : std_logic;
signal i_sck_re_tk : std_logic;
signal i_sck_fe_tk : std_logic;
signal i_cs_cpy : std_logic;
signal i_cs_re_tk : std_logic;
signal i_cs_fe_tk : std_logic;
signal i_stb_cpy : std_logic;
signal i_stb_re_tk : std_logic;
signal i_stb_fe_tk : std_logic;
type clk_state is (clk_idle_st, clk_gen_st);
signal i_clk_state : clk_state;
type cmd_state is (idle_st, sample_st, done_st, wait_stb_st, ldac_low_st);
signal i_cmd_state : cmd_state;
cs_edge : process (clk_i) begin ; end process ;
if rising_edge(clk_i) then ; end if ;
if rst_n_i = '0' then ; end if ;
i_cs_cpy <= '0';
i_cs_cpy <= i_cs;
if rising_edge(clk_i) then if rst_n_i = '0' then i_cs_cpy <= '0'; else i_cs_cpy <= i_cs; end if; end if;
i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0';
i_cs_fe_tk <= '1' when i_cs_cpy = '1' and i_cs = '0' else '0';
sck_gen : process (clk_i)
if rising_edge(clk_i) then ;  end if;
if rst_n_i = '0' then ; end if;
if rst_n_i = '0' then ; end if;
i_slc_counter <= DAC_CLK_DIV - 1;
i_scl <= '0';
i_scl <= '0';
i_scl_cnt <= 0;
case i_clk_state is
case i_clk_state is when clk_idle_st => ; when clk_gen_st => ; end case ;
i_clk_state <= clk_idle_st;
i_slc_counter <= DAC_CLK_DIV - 1;
i_scl <= '0';
i_scl <= '0';
i_scl_cnt <= 0;
if start_i = '1' then ; end if ;
if start_i = '1' then ; end if ;
i_clk_state <= clk_gen_st;
when clk_gen_st =>
if i_slc_counter = 0 then ; end if;
i_slc_counter <= (DAC_CLK_DIV - 1);
i_slc_counter <= i_slc_counter - 1;
if i_slc_counter < DAC_CLK_DIV/2 then ; end if;
if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if;
if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if;
i_clk_state <= clk_idle_st;
i_scl_cnt <= i_scl_cnt + 1;
sck_edge : process (clk_i) begin ; end process ;
if rising_edge(clk_i) then ; end if ;
if rst_n_i = '0' then ; end if;
i_sck_cpy <= i_scl;
sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
i_sck_re_tk <= '1' when i_sck_cpy = '0' and i_scl = '1' else '0';
i_sck_re_tk <= '1' when i_sck_cpy = '0' and i_scl = '1' else '0';
i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0';
i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0';
if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if;
i_done <= '0';
i_done <= '0';
i_cs <= '1';
i_cs <= '1';
i_sda <= '0';
i_sda <= '0';
i_ldac <= '1';
i_ldac <= '1';
i_ldac_cnt <= 0;
cs_o <= i_cs when rst_n_i = '1' else '1';
cs_o <= i_cs when rst_n_i = '1' else '1';
scl_o <= i_scl when rst_n_i = '1' else '0';
scl_o <= i_scl when rst_n_i = '1' else '0';
done_o <= i_done when rst_n_i = '1' else '0';
done_o <= i_done when rst_n_i = '1' else '0';
sda_o <= i_sda when rst_n_i = '1' else '0';
sda_o <= i_sda when rst_n_i = '1' else '0';
ldac_o <= i_ldac when rst_n_i = '1' else '1';
ldac_o <= i_ldac when rst_n_i = '1' else '1';
when ldac_low_st =>
when clk_gen_st =>
when idle_st =>
when sample_st =>
when done_st =>
when wait_stb_st =>
when other_st =>
when ready_st =>
when start_st =>
when stop_st =>
i_sda <= data_i(i_bit_counter);
i_stb_cpy <= trial(i_counter_1);
i_clk_state <= mamba(i_counter_2);
i_cs <= sign_data(i_counter_3);
i_scl <= val_vector(i_counter_4);
i_done <= data_out(i_counter_5);
i_sda <= value_in(i_counter_6);
i_sck_cpy <= prova(i_counter_7);
i_sck_re_tk <= example(i_counter_8);
i_sck_fe_tk <= data_i(i_counter_9);
i_ldac <= data_i(i_counter_10);
i_bit_counter <= i_bit_counter - 1;
data_count <= data_count + 5;
counter_signal <= counter_signal - 10;
clk_delay <= clk_delay + 3;
output_value <= output_value - 8;
temp_signal <= temp_signal + 15;
sample_rate <= sample_rate - 20;
index_signal <= index_signal + 7;
gain_value <= gain_value - 12;
input_data <= input_data + 2;
error_count <= error_count - 6;
entity deglitcher_testbench is end entity deglitcher_testbench;
architecture behavioral of deglitcher_testbench is begin end architecture behavioral;
component deglitcher is port (clk : in std_logic; rst_n : in std_logic; d : in std_logic; q : out std_logic); end component;
uut : component deglitcher port map ();
clk_generator : process is begin wait for clk_period / 2; clk_t <= not clk_t; end process clk_generator;
clk_t <= not clk_t;
wait for clk_period / 2;
wait for 95 ns;
wait for 20 us;
wait for 20 us;
constant n : integer := 1000;
signal count_nxt : integer range 0 to n - 1;
signal count_nxt : integer range 0 to n - 1;
update_state : process (clk) is begin if rising_edge(clk) then if (rst_n = '0') then q_reg <= '0'; d_reg <= '0'; else count_reg <= count_nxt; q_reg <= q_nxt; d_reg <= d_nxt; end if; end if; end process update_state;
if ((d xor d_reg) = '1') then
count_nxt <= 0;
if (count_reg < n - 1) then
count_nxt <= count_reg + 1;
entity pwm_generator is port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; data_out : out std_logic); end pwm_generator;
clk : in std_logic;
rst_n : in std_logic;
enable : in std_logic;
data_out : out std_logic;
constant DIV : integer := 200;
signal count_reg, count_nxt : integer range 0 to DIV - 1;
signal data_out_reg, data_out_nxt : std_logic;
constant FACTOR : integer := 100;
constant MAX_LIMIT : integer := 500;
constant DELAY_TIME : integer := 50;
constant TIMEOUT_VAL : integer := 1000;
constant BUFFER_SIZE : integer := 256;
constant SCALE_FACTOR : integer := 10;
constant SAMPLE_RATE : integer := 10000;
constant MAX_VALUE : integer := 1023;
constant THRESHOLD : integer := 50;
constant REFERENCE_VOLTAGE : integer := 5000;
update_process: process(clk) begin ; end process update_process;
update_process: process(clk) begin if(rising_edge(clk)) then if(rst_n = '0') then count_reg <= 0; data_out_reg <= '0'; else count_reg <= count_nxt; data_out_reg <= data_out_nxt; end if; end if; end process update_process;
update_process: process(clk) begin if(rising_edge(clk)) then if(rst_n = '0') then count_reg <= 0; data_out_reg <= '0'; else count_reg <= count_nxt; data_out_reg <= data_out_nxt; end if; end if; end process update_process;
if(rst_n = '0') then ; end if ;
if(rst_n = '0') then ; end if ;
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
data_out_nxt <= '0' when count_reg = DIV/2 - 1 else '1';
entity pwm_generator_TB is end pwm_generator_TB;
constant clk_period : time := 5 ns;
signal clk_t : std_logic := '0';
signal enable : std_logic := '1';
pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);
wait for 20*clk_period;
wait for 50*clk_period;
wait for 120*clk_period;
entity TimeExpander is generic (clock_multiplier : integer := 5000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end TimeExpander;
sync_proc : process (clk, rst_n) begin end process sync_proc
expander : process (clk, rst_n, reg_count_reg, enable) begin end process expander
reg_count_nxt <= reg_count_reg + 1;
round_key_in: in std_logic_vector(63 downto 0);
data_in: in std_logic_vector(63 downto 0);
data_out: out std_logic_vector(63 downto 0)
entity add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end add_round_key;
architecture behavioral of add_round_key is end behavioral
entity cypher_layer is port(); end cypher_layer
round_counter: in std_logic_vector(4 downto 0);
round_counter: out std_logic_vector(4 downto 0);
round_key_in: in std_logic_vector(63 downto 0); 
round_key_in: out std_logic_vector(63 downto 0); 
reg_key_in: in std_logic_vector(79 downto 0);
reg_key_in: out std_logic_vector(79 downto 0);
reg_key_in: in std_logic_vector(79 downto 0);
data_out: out std_logic_vector(63 downto 0);
data_out: out std_logic_vector(63 downto 0);
reg_key_out: out std_logic_vector(79 downto 0)
entity cypher_layer is port (round_counter: in std_logic_vector(4 downto 0); round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0) ); end cypher_layer;
architecture my_arch of cypher_layer is end my_arch
component add_round_key is port(); end component;
component sbox is port(); end component;
component add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
component sbox is port(data_in: in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0)); end component;
component perm_layer is port() end component;
component perm_layer is port() end component;
component perm_layer is port(data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0)); end component;
component key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0)); end component;
component key_update is port () end component;
reg_key_out: out std_logic_vector(79 downto 0);
reg_key_in: in std_logic;
reg_key_in: in std_logic;
round_counter: in std_logic_vector(4 downto 0);
signal data_out_temp1: std_logic_vector(63 downto 0);
signal data_out_temp1: std_logic_vector(63 downto 0);
signal data_out_temp2: std_logic_vector(63 downto 0);
signal data_out_temp3: std_logic_vector(63 downto 0);
signal data_out_temp3: std_logic_vector(63 downto 0);
signal round_key_temp: std_logic_vector(63 downto 0);
ark: add_round_key port map ();
ark: add_round_key port map (round_key_in,data_in,data_out_temp1);
pl: perm_layer port map (data_out_temp2,data_out);
pl: perm_layer port map ();
kupd: key_update port map(reg_key_in,round_counter,reg_key_out);
kupd: key_update port map();
end behavioral;
sbox_i: for i in 0 to 15 generate end generate sbox_i
sbox_i: for i in 0 to 15 generate sboxi: sbox port map(); end generate sbox_i;
add_round_key_i: for i in 0 to 63 generate add_round_keyi: add_round_key port map(); end generate add_round_key_i;
sbox_i : for i in 0 to 15 generate sboxi: sbox port map ( data_out_temp1 (4*i+3 downto 4*i), data_out_temp2(4*i+3 downto 4*i) ); end generate sbox_i;
use ieee.numeric_std.all;
entity inputmanager is port () end inputmanager;
entity inputmanager is port ( clock: in std_logic; rst: in std_logic; stringa_in: in std_logic_vector(15 downto 0); en: in std_logic; stringa_out: out std_logic_vector(63 downto 0) ); end inputmanager;
en: in std_logic;
stringa_in: in std_logic_vector(15 downto 0);
clock: in std_logic;
clock: in std_logic;
architecture bevy of inputmanager is begin end architecture;
architecture bevy of inputmanager is begin end architecture;
type state is (idle, primo, secondo, terzo);
type ciao is (x, y, z);
type rob is (x, c, v, b, n);
signal current_state: state := idle;
signal current_state: state := primo;
signal current_state: state := secondo;
signal current_state: state := bau;
signal stringa1: std_logic_vector(15 downto 0) := ( others => '0' );
signal stringa2: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
stringa_out <= stringa1 & stringa2 & stringa3 & stringa4;
x <= y & z
prova <= stringa1 & stringa2 & stringa3 & stringa4;
if(rising_edge(clock)) then
if(rising_edge(clock)) then
process(clock)
if ( rst = '1' ) then
if ( rst = '1' ) then
stringa1 <= ( others => '0' );
stringa2 <= ( others => '0' );
stringa3 <= ( others => '0' );
stringa4 <= ( others => '0' );
current_state <= idle;
current_state <= idle;
if (rst='1') then stringa1 <= ( others => '0' ); end if;
case current_state is when idle => ; when primo => ; when secondo => ; when terzo => ; end case;
case current_state is when idle => stringa1 <= stringa_in ; end case;
case current_state is when idle => if ( en = '1' ) then stringa1 <= stringa_in; current_state <= primo ; end if ; end case ; 
case current_state is when primo => if ( en = '1' ) then stringa2 <= stringa_in; current_state <= secondo ; end if ; end case ;
if ( current_state = secondo ) then x <= ( others => '0' ); end if;
case current_state is when secondo => x <= ( others => '0' ); end case;
key_update is port () end key_update;
key_update is port () end key_update;
entity key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0) ); end key_update;
architecture structural of key_update is begin end structural;
signal key_temp1: std_logic_vector(79 downto 0);
signal key_temp1_frac: std_logic_vector(3 downto 0);
component abox port (); end component
component abox port (data_in:  in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0) ); end component;
key_temp1 <= reg_key_in( 18 downto 0 ) & reg_key_in( 79 downto 19 );
SB : sbox port map ( data_in => key_temp1(79 downto 76), data_out => key_temp1_frac );
sbox_inst : sbox port map ();
reg_key_out( 79 downto 76 ) <= key_temp1_frac;
reg_key_out(19 downto 15) <= key_temp1(19 downto 15) xor round_counter;
reg_key_out <= key_temp1 and round_counter;
reg_count_reg(89 downto 34) <= key_temp1
entity present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0)); end present_cypher;
component add_round_key is port ( round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
component cypher_layer is port ( round_counter: in std_logic_vector(4 downto 0); round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); reg_key_in: in std_logic_vector(79 downto 0); data_out: out std_logic_vector(63 downto 0); reg_key_out: out std_logic_vector(79 downto 0)); end component;
signal cont: std_logic_vector(4 downto 0):= "00000";
type dataArrayType is array(0 to 31) of std_logic_vector(63 downto 0);
type x is array(0 to 15) of std_logic_vector(19 downto 0);
signal blocks: dataArrayType;
signal round_keys: dataArrayType;
signal my_sig: x;
type keyArrayType is array(0 to 31) of std_logic_vector(79 downto 0);
signal key_registers: keyArrayType;
blocks(0) <= plaintext;
x(4)
key_registers(0) <= user_key;
y( 10 )
round_keys(i) <= key_registers(i)(79 downto 16);
round_keys(31) <= key_registers(31)(60 downto 3);
final_ark: add_round_key port map (round_keys(31),blocks(31),cyphertext);
entity present_top is port ( clock: in std_logic; rst: in std_logic; value_in: in std_logic_vector(15 downto 0); btn_plainText_in: in std_logic; btn_switch_display: in std_logic; catodi : out std_logic_vector (7 downto 0); anodi : out std_logic_vector (7 downto 0) ); end present_top;
component present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0) ); end component;
user_key: in std_logic_vector(79 downto 0);
generic ( clock_frequency_in : integer := 50000000; clock_frequency_out : integer := 5000000 );
clock_frequency_in : integer := 50000000;
clock_frequency_out : integer := 5000000;
value32_in : in  STD_LOGIC_VECTOR (31 downto 0);
anodes : out  STD_LOGIC_VECTOR (7 downto 0);
cathodes : out  STD_LOGIC_VECTOR (7 downto 0);
reset : in  STD_LOGIC;
component display_seven_segments is generic ( clock_frequency_in : integer := 50000000; clock_frequency_out : integer := 5000000); port ( clock : in STD_LOGIC; reset : in STD_LOGIC; value32_in : in STD_LOGIC_VECTOR (31 downto 0); enable : in STD_LOGIC_VECTOR (7 downto 0); dots : in STD_LOGIC_VECTOR (7 downto 0); anodes : out  STD_LOGIC_VECTOR (7 downto 0); cathodes : out STD_LOGIC_VECTOR (7 downto 0)); end component;
component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); end component;
clock_frequency_out : integer := 500
component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC ); end component;
component button_debouncer is generic () ; port () ; end component ;
clk_period: integer := 10;
btn_noise_time: integer := 10000000
signal clk_div: std_logic;
signal t_btn_plaintext , t_switchdisplay , t_btn_key : std_logic; 
signal value_to_display: std_logic_vector(31 downto 0);
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ) ;
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ) ;
signal cyphertext64: std_logic_vector(63 downto 0):=(others=>'0');
signal mode : boolean := false ;
signal mode : boolean := false ;
begin
divisore_frequenza: clock_divider port map(clock, rst, clk_div);
divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map(clock, rst, clk_div);
divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map () ;
debouncer_display_btn : button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_switch_display, t_switchDisplay);
debouncer_plaintext_btn: button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_plainText_in, t_btn_plainText);
visualizza_ris: process ( clock ) begin end process ; 
if ( rising_edge(clock) ) then if ( t_switchDisplay = '1') then mode <= not mode ; end if ; end if;
input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64);
cypher: present_cypher port map (plaintext64, cyphertext64, x"00000000000000000000");
value_to_display <= cyphertext64(63 downto 32) when mode = false else cyphertext64(31 downto 0) when mode=true;
visualizzatore_sevenseg: display_seven_segments generic map(clock_frequency_in => 100000000, clock_frequency_out => 10000) port map (clock, rst, value_to_display, "11111111", "00000000", anodi, catodi);
entity counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end counter;
architecture behavioral of counter is begin end behavioral ; 
signal c: std_logic_vector(2 downto 0); 
if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if;
count <= c
entity MEM is port ( clk : in STD_LOGIC; addr: in STD_LOGIC_VECTOR(2 downto 0); write : in STD_LOGIC; data_in : in STD_LOGIC_VECTOR (31 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end MEM;
data_in : in STD_LOGIC_VECTOR (31 downto 0);
type mem_type is array (0 to 7) of std_logic_vector(31 downto 0);
signal mem : mem_type; 
unsigned(addr)
mem(to_integer(unsigned(addr)))
mem(to_integer(unsigned(addr))) <= data_in; 
if(write = '1') then mem(to_integer(unsigned(addr))) <= data_in; end if;
data_out <= mem(to_integer(unsigned(addr)));
entity rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end rom;
X"AAAAAAAA"
X"BBBBBBBB"
type rom_type is array (0 to 7) of std_logic_vector(31 downto 0);
signal rom : rom_type := (X"AAAAAAAA", X"BBBBBBBB", X"CCCCCCCC", X"DDDDDDDD", X"12345678", X"87654321", X"00112233", X"44556677");
data_out <= rom(to_integer(unsigned(addr)));
entity sistemaA is port ( start : in STD_LOGIC; clkA : in STD_LOGIC; rst : in STD_LOGIC; ack : in STD_LOGIC; dato : out STD_LOGIC_VECTOR (31 downto 0); req : out STD_LOGIC); end sistemaA; 
component UC_A is port ( clkA : in STD_LOGIC; rst : in STD_LOGIC; start: in STD_LOGIC; ack : in STD_LOGIC; count : in STD_LOGIC_VECTOR(2 downto 0); en : out STD_LOGIC; req : out STD_LOGIC); end component;
component rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end component;
component counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end component;
signal count_tmp: STD_LOGIC_VECTOR (2 downto 0);
signal en_tmp: STD_LOGIC;
ROM_comp: ROM port map (count_tmp, dato);
counter_comp: counter port map(clkA, en_tmp, rst, count_tmp);
UCA_comp: UC_A port map(clkA, rst, start, ack, count_tmp, en_tmp, req);
entity sistemaTOT is port ( clkA : in STD_LOGIC; clkB : in STD_LOGIC; rst : in STD_LOGIC; start : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR (31 downto 0)); end sistemaTOT;
component sistemaB is port ( req : in STD_LOGIC; dato_in : in STD_LOGIC_VECTOR (31 downto 0); dato_out : out STD_LOGIC_VECTOR (31 downto 0); clkB : in STD_LOGIC; rst : in STD_LOGIC; ack : out STD_LOGIC); end component;
signal count_tmp: STD_LOGIC_VECTOR (2 downto 0);
signal data_tmp: STD_LOGIC_VECTOR (31 downto 0);
signal en_tmp, req_tmp, ack_tmp, write_tmp: STD_LOGIC;
sisA: sistemaA port map(start,clkA,rst,ack_tmp,data_tmp,req_tmp);
type stato is (IDLE, INVIA, ASPETTA, FINITO);
signal stato_corrente, stato_prossimo : stato := IDLE;
stato_mem: process(clkA) begin if rising_edge(clkA) then if( RST = '1') then stato_corrente <= IDLE; else stato_corrente <= stato_prossimo; end if; end if; end process;
stato_uscita: process(stato_corrente,start,ack)
case stato_corrente is when IDLE => ; when  INVIA => ; when ASPETTA => ; when FINITO => ; when others => ; end case ;
case stato_corrente is when IDLE => if( start = '1' ) then stato_prossimo <= INVIA; else stato_prossimo <= IDLE; end if; end case;
case stato_corrente is when INVIA => en <='0'; req <= '1'; if( ack = '1') then stato_prossimo <= ASPETTA; else stato_prossimo <= INVIA ; end if ; end case ;
case stato_corrente is when ASPETTA => req <='0'; if (ack = '0') then stato_prossimo <= FINITO; else stato_prossimo <= ASPETTA; end if;
component sistemaTOT port (clkA : in std_logic; clkB : in std_logic; rst : in std_logic; start : in std_logic; data_out : out std_logic_vector (31 downto 0)); end component;
signal clkA     : std_logic;
signal clkB     : std_logic;
signal rst      : std_logic;
signal start    : std_logic;
signal data_out : std_logic_vector (31 downto 0);
constant TbPeriodA : time := 13 ns;
signal TbClockA : std_logic := '0';
constant TbPeriodB : time := 40 ns;
signal TbClockB : std_logic := '0';
signal TbSimEnded : std_logic := '0';
dut : sistemaTOT port map (clkA => clkA, clkB => clkB, rst => rst, start => start, data_out => data_out);
clk_process : process begin TbClockA <= '0'; wait for TbPeriodA/2; TbClockA <= '1'; wait for TbPeriodA/2; end process;
TbClockB <= not TbClockB after TbPeriodB/2
TbClockB <= not TbClockB after TbPeriodB/2
TbClockB <= not TbClockB after TbPeriodB/2 when TbSimEnded /= '1' else '0';
clkB <= TbClockB;
wait for 100 ns; rst <= '0';
wait for 10 ns;
wait for 10 ns; start <= '1';
wait for 10 ns; start <= '0';
wait for 100 ns;
wait for 500 * TbPeriodB;
wait for 10ns; start <= '0'; wait for 10ns; start <= '1';
uut: present_cypher port map(plaintext, cyphertext, user_key);
stimuli: process begin wait for 100 ns; plaintext <= x"0000000000000000"; user_key <= x"00000000000000000000"; wait for 30 ns; plaintext <= x"5579c1387b228445"; end process;
wait for 100 ns; plaintext <= x"0000000000000000"; user_key <= x"00000000000000000000";
wait for 30 ns; plaintext <= x"5579c1387b228445"; user_key <= x"00000000000000000000";
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1;
y <= a0 when s = '0' else a1 when s = '1' else '-';
y <= a0 when s = '0' else a1 when s = '1' else '-';
y <= c3 when g = '0' else a1 when g = '1' else '-';
with s select y <= 	a0 when '0', a1 when '1', '-' when others;
with f select z <= 	b0 when '0', a1 when '1', '-' when others;
with ciao select y <= a0 when '0', a1 when '1', '-' when others;
with ciao select y <= a0 when '0', a1 when '1', '-' when others;
y <= ((a0 and (NOT s)) OR (a1 and s));
signal control : STD_LOGIC := 'U';
signal output : STD_LOGIC := 'U';
signal input : STD_LOGIC_VECTOR (0 to 1) := (others => 'U'); 
utt : entity work.mux_2_1(dataflow_v2) port map( a0 => input(0), a1 => input(1), s => control, y => output );
wait for 5 ns; input <= "00";
assert output = '0' report "errore0" severity failure;
assert strobe = '1' report "prova" severity failure;
assert output = '1' report "mystring" severity warning;
stim_proc : process begin wait for 100 ns; input <= "01"; wait for 10 ns; assert output = '0' report "errore0" severity failure;
entity mux2_1_tb is port () end mux2_1_tb;
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1;
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1;
signal u0 : STD_LOGIC := '0';
signal u1 : STD_LOGIC := '0';
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component;
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component;
mux0: mux_2_1 port map(a0 => b0, a1 => b1, s => s0, y => u0);
mux1: mux_2_1 port map(a0 => b2, a1 => b3, s => s0, y => u1);
mux2: mux_2_1 port map(a0 => u0, a1 => u1, s => s1, y => y0);
component mux_4_1 port (b0 : in STD_LOGIC; b1 : in STD_LOGIC; b2 : in STD_LOGIC; b3 : in STD_LOGIC; s0 : in STD_LOGIC; s1 : in STD_LOGIC; y0 : out STD_LOGIC); end component; 
component mux_4_1 port (b0 : in STD_LOGIC; b1 : in STD_LOGIC; b2 : in STD_LOGIC; b3 : in STD_LOGIC; s0 : in STD_LOGIC; s1 : in STD_LOGIC; y0 : out STD_LOGIC); end component; 
signal input : STD_LOGIC_VECTOR (0 to 3) := (others => '0');
signal control : STD_LOGIC_VECTOR (1 downto 0) := (others => '0');
signal output : STD_LOGIC := '0';
uut: mux_4_1 port map(b0 => input(0), b1 => input(1), b2 => input(2), b3 => input(3), s0 => control(0), s1 => control(1), y0 => output );
stim_proc: process begin wait for 100 ns; input <= "1010"; control <= "00"; wait for 10 ns; assert output = '0' report "errore" severity failure; wait; end process;
assert output = '0' report "errore" severity failure;
entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;
entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;
entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;
y <= "1000" when a="00" else "0100" when a="01" else "0010" when a="10" else "0001" when a="11" else "----";
with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others;     	
case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case;
case (a) is when "00" => ; when "01" => ; when "10" => ; when "11" => ; when others => ; end case;
y <= "----";
component decoder_2_4 port( a : in STD_LOGIC_VECTOR(1 downto 0); y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
component decoder_2_4 port( a : in STD_LOGIC_VECTOR(1 downto 0); y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
signal a: STD_LOGIC_VECTOR(1 downto 0);
signal y: STD_LOGIC_VECTOR(3 downto 0);
uut: decoder_2_4 port map ( a => a, y => y );
stimulus: process begin wait for 100 ns; wait for 10 ns; a<="00"; wait for 10 ns; wait; end process;
wait for 10 ns;
entity Riconoscitore_Mealy is port( i: in std_logic; rst, clk: in std_logic; y: out std_logic ); end Riconoscitore_Mealy;
type stato is (S0, S1, S2, S3, S4);
signal stato_corrente : stato := S0;
stato_uscita_mem: process(clk) begin if rising_edge(clk) then if(rst = '1') then stato_corrente <= S0; Y <= '0'; end if; end process;
case stato_corrente is when S0 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S1; end if; end case ;
case stato_corrente is when S1 => if( i = '0' ) then stato_corrente <= S2; Y <= '0'; else stato_corrente <= S1; end if; end case ;
case stato_corrente is when S2 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S0; end if; end case ;
when others => stato_corrente <= S0; Y <= '0'; end case ;
type stato is (S0, S1, S2);
mem: process (CLK) begin if( rising_edge( CLK ) ) then if( RST = '1') then stato_corrente <= S0; else stato_corrente <= stato_prossimo; end if; end if; end process;
if( rising_edge( CLK ) ) then end if;
mem: process (CLK) begin if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if; end process;
architecture behavioral_2proc_v2 of Riconoscitore_Mealy is begin end behavioral_2proc_v2
if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if;
component Riconoscitore_Mealy port( i : IN std_logic; CLK, RST : IN std_logic; Y : OUT std_logic); end component;
signal i : std_logic := '0';
signal CLK : std_logic := '0';
signal RST : std_logic := '0'; 
signal Y : std_logic;
uut: Riconoscitore_Mealy port map(i => i, CLK => CLK, RST => RST, Y => Y);
clk_process : process begin CLK <= '0'; wait for CLK_period/2; CLK <= '1'; wait for CLK_period/2; end process;
wait for 100 ns;
stim_proc: process begin wait for 100 ns; i<='0'; wait for 10 ns; i<='0'; wait for 10 ns; i<='1';
entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
entity shift_reg is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi;
signal tmp: std_logic_vector(3 downto 0);
if (rising_edge(CLK)) then tmp(0) <= '0'; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if;
tmp(1) <= tmp(0);
tmp(2) <= tmp(1);
tmp(3) <= tmp(2);
SO <= tmp(3);
component shift_register port (CLK : in std_logic; RST : in std_logic; SI : in std_logic; SO : out std_logic); end component;
component shift_register port (CLK : in std_logic; RST : in std_logic; SI : in std_logic; SO : out std_logic); end component;
signal clk_tb : std_logic;
signal input : std_logic := '0';
signal output : std_logic;
signal rst : std_logic;
constant clk_period : time := 20 ns;
clk_process : process begin clk_tb <= '0'; wait for clk_period/2; clk_tb <= '1'; wait for clk_period/2; end process;
uut : shift_register port map (CLK => clk_tb, RST => rst, SI => input, SO => output);
stimuli : process begin rst <= '1'; wait for 100ns; rst <='0'; input <= '1'; wait for 100ns; input <= '0'; wait for 100ns; input <= '1'; wait; end process;
entity encoder is port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end encoder;
with X select Y <= "0000" when "0000000001", "0001" when "0000000010", "0010" when "0000000100", "0011" when "0000001000", "0100" when "0000010000", "0101" when "0000100000", "0110" when "0001000000", "0111" when "0010000000", "1000" when "0100000000", "1001" when "1000000000", "1111" when others;
constant zero : std_logic_vector(6 downto 0) := "1000000";
constant one : std_logic_vector(6 downto 0) := "1111001"; 
constant two : std_logic_vector(6 downto 0) := "0100100"; 
constant three : std_logic_vector(6 downto 0) := "0110000"; 
constant four : std_logic_vector(6 downto 0) := "0011001"; 
constant five : std_logic_vector(6 downto 0) := "0010010"; 
constant six : std_logic_vector(6 downto 0) := "0000010"; 
constant seven : std_logic_vector(6 downto 0) := "1111000"; 
constant eight : std_logic_vector(6 downto 0) := "0000000"; 
constant nine : std_logic_vector(6 downto 0) := "0010000"; 
constant a : std_logic_vector(6 downto 0) := "0001000"; 
constant b : std_logic_vector(6 downto 0) := "0000011"; 
constant c : std_logic_vector(6 downto 0) := "1000110"; 
constant d : std_logic_vector(6 downto 0) := "0100001"; 
constant e : std_logic_vector(6 downto 0) := "0000110"; 
constant f : std_logic_vector(6 downto 0) := "0001110";
signal cathodes : std_logic_vector(6 downto 0);
case value is when "0000" => cathodes <= zero; when "0001" => cathodes <= one; when "0010" => cathodes <= two; when "0011" => cathodes <= three; when "0100" => cathodes <= four; when "0101" => cathodes <= five; when "0110" => cathodes <= six; when "0111" => cathodes <= seven; when "1000" => cathodes <= eight; when "1001" => cathodes <= nine; when "1010" => cathodes <= a; when "1011" => cathodes <= b; when "1100" => cathodes <= c; when "1101" => cathodes <= d; when "1110" => cathodes <= e; when "1111" => cathodes <= f; when others => cathodes <= (others => '0'); end case;
cathodes_dot <= (not dot)&cathodes;
entity Encoder_onBoard is port ( switch : in STD_LOGIC_VECTOR(9 downto 0); led : out STD_LOGIC_VECTOR(3 downto 0); catodi : out STD_LOGIC_VECTOR(7 downto 0); anodi : out STD_LOGIC_VECTOR(7 downto 0)); end Encoder_onBoard;
component Encoder port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
component cathodes_manager port(value : in std_logic_vector(3 downto 0); dot : in std_logic; cathodes_dot : out std_logic_vector(7 downto 0)); end component;
cat: cathodes_manager port map(value => ytemp, dot => dot, cathodes_dot => catodi);
enc: Encoder port map(X => switch, Y => ytemp);
signal ytemp : std_logic_vector (3 downto 0);
signal dot : std_logic;
dot <= '1';
anodi <= (others=>'0');
led <= ytemp;
entity counter_mod8 is port ( clock : in STD_LOGIC; reset : in STD_LOGIC; enable : in STD_LOGIC; counter : out STD_LOGIC_VECTOR (2 downto 0)); end counter_mod8;
signal c : std_logic_vector (2 downto 0) := (others => '0');
counter <= c;
c <= std_logic_vector(unsigned(c) + 1);
if(rising_edge(clock)) then if reset = '1' then c <= (others => '0'); elsif enable = '1' then c <= std_logic_vector(unsigned(c) + 1); end if; end if;
entity clock_filter is generic(CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500); Port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC); end clock_filter;
signal clockfx : std_logic := '0';
constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1;
clock_out <= clockfx;
if rising_edge(clock_in) then end if ;
variable counter : integer range 0 to count_max_value := 0;
variable index : integer range -10 to 10 := -5;
variable count : integer range 1 to 100 := 50;
variable value : integer range -1000 to 1000 := 0;
variable limit : integer range 0 to 255 := 255;
variable speed : integer range 50 to 200 := 100;
variable temperature : integer range -20 to 50 := 25;
variable distance : integer range 0 to 1000 := 500;
variable power : integer range 0 to 5000 := 2000;
variable delay : integer range 0 to 100 := 10;
variable size : integer range 10 to 10000 := 1000;
if rising_edge(clock_in) then if( reset = '1') then counter := 0; clockfx <= '0'; counter := counter + 1; end if; end if;
if rising_edge(clk) then if( rst = '1') then cnt := 0; flag <= '0'; cnt := cnt + 1; end if; end if;
if rising_edge(clock) then if( reset_sig = '1') then counter_var := 10; enable <= '1'; counter_var := counter_var + 2; end if; end if;
if rising_edge(clk_in) then if( clear_sig = '1') then idx := 5; stop_sig <= '0'; idx := idx + 3; end if; end if;
if rising_edge(clock_in) then if( rst_n = '1') then value := -100; enable_sig <= '1'; value := value - 10; end if; end if;
if rising_edge(clk) then if( reset_sig = '1') then count := 50; ready <= '1'; count := count + 5; end if; end if;
if rising_edge(clk_in) then if( reset_n = '1') then temp := 25; start_sig <= '1'; temp := temp - 1; end if; end if;
if rising_edge(clk) then if( clear_sig = '1') then limit := 255; start_signal <= '1'; limit := limit + 20; end if; end if;
if rising_edge(clock_in) then if( rst_n = '1') then num := 1000; enable_sig <= '0'; num := num - 100; end if; end if;
if rising_edge(clk) then if( reset_sig = '1') then value := 0; enable_sig <= '1'; value := value + 2; end if; end if;
if rising_edge(clock_in) then if( clear_signal = '1') then count := 0; enable <= '1'; count := count - 1; end if; end if;
entity ROM_selector_onboard is port (clock_in : in STD_LOGIC; reset_in : in STD_LOGIC; addr_strobe_in : in STD_LOGIC; anodes_out : out STD_LOGIC_VECTOR(7 downto 0); cathodes_out : out STD_LOGIC_VECTOR(7 downto 0)); end ROM_selector_onboard;
component ButtonDebouncer generic (CLK_period: integer := 10; btn_noise_time: integer := 10000000) port (RST : in STD_LOGIC; CLK : in STD_LOGIC; BTN : in STD_LOGIC; CLEARED_BTN : out STD_LOGIC); end component;
component counter_mod8 port (clock : in STD_LOGIC; reset : in STD_LOGIC; enable : in STD_LOGIC; counter : out STD_LOGIC_VECTOR(2 downto 0)); end component;
component ROM port (RST: in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end component;
component display_seven_segments generic (CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500) port (CLK : IN std_logic; RST : IN std_logic; VALUE : IN std_logic_vector(31 downto 0); ENABLE : IN std_logic_vector(7 downto 0); DOTS : IN std_logic_vector(7 downto 0); ANODES : OUT std_logic_vector(7 downto 0); CATHODES : OUT std_logic_vector(7 downto 0)); end component;
signal reset_n, read_strobe : std_logic;
signal value_temp : std_logic_vector(31 downto 0);
signal address_in : STD_LOGIC_VECTOR(2 downto 0); 
debouncer: ButtonDebouncer generic MAP(CLK_period => 10, btn_noise_time => 10000000) port map(RST => reset_n, CLK => clock_in, BTN => addr_strobe_in, CLEARED_BTN => read_strobe);
counter: counter_mod8 port map(clock=> clock_in, reset => reset_n, enable => read_strobe, counter => address_in);
mem: ROM port map (rst => reset_n, addr => address_in, data => value_temp);
seven_segment_array: display_seven_segments generic map(CLKIN_freq => 100000000, CLKOUT_freq => 500) port map(CLK => clock_in, RST => reset_n, value => value_temp, enable => "11111111", dots => "00000000", anodes => anodes_out, cathodes => cathodes_out);
entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;
entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;
type rom_type is array (0 to 7) of std_logic_vector(31 downto 0);
signal ROM : rom_type := (X"AAAAAAAA", X"BBBBBBBB", X"CCCCCCCC", X"DDDDDDDD", X"12345678", X"87654321", X"00112233", X"44556677");
type stato is (NOT_PRESSED, CHK_PRESSED, PRESSED, CHK_NOT_PRESSED);
signal BTN_state : stato := NOT_PRESSED;
constant max_count : integer := btn_noise_time/CLK_period;
if rising_edge(CLK) then if RST = '1' then BTN_state <= NOT_PRESSED; CLEARED_BTN <= '0'; end if; end if;
variable count: integer := 0;
case BTN_state is when NOT_PRESSED => if BTN = '1' then BTN_state <= CHK_PRESSED; else BTN_state <= NOT_PRESSED; end if; when CHK_PRESSED => if count = max_count -1 then if BTN = '1' then count:=0; CLEARED_BTN <= '1'; BTN_state <= PRESSED; else count:=0; BTN_state <= NOT_PRESSED; end if; end if; end case;
if(count = max_count -1) then end if;
if(index /= limit + 1) then end if;
if(data >= threshold) then end if;
if(counter > max_count) then end if;
if(voltage < ref_voltage) then end if;
if(sum /= difference) then end if;
count := count + 1;
case BTN_state is when NOT_PRESSED => ; when CHK_PRESSED => ; when PRESSED => ; when CHK_NOT_PRESSED => ; when others => ; end case ;
case status is when IDLE => ; when ACTIVE => ; when ERROR => ; when COMPLETED => ; when others => ; end case ;
case mode is when AUTO => ; when MANUAL => ; when SEMI_AUTO => ; when OFF => ; when others => ; end case ;
case state is when INIT => ; when PROCESSING => ; when WAITING => ; when FINISHED => ; when others => ; end case ;
case flag is when ENABLED => ; when DISABLED => ; when SET => ; when CLEARED => ; when others => ; end case ;
case operation is when ADD => ; when SUBTRACT => ; when MULTIPLY => ; when DIVIDE => ; when others => ; end case ;
case condition is when TRUE => ; when FALSE => ; when HIGH => ; when LOW => ; when others => ; end case ;
case status_code is when OK => ; when WARNING => ; when ERROR_CODE => ; when CRITICAL => ; when others => ; end case ;
case mode_code is when SAFE_MODE => ; when NORMAL_MODE => ; when SLEEP_MODE => ; when EMERGENCY_MODE => ; when others => ; end case ;
case state_code is when STARTUP => ; when RUNNING => ; when HALTED => ; when SHUTDOWN => ; when others => ; end case ;
case flag_code is when FLAG_1 => ; when FLAG_2 => ; when FLAG_3 => ; when FLAG_4 => ; when others => ; end case ;
count := 0;
CLEARED_BTN <= '1';
if(count = max_count -1) then if(BTN = '0') then count :=0 ; BTN_state <= NOT_PRESSED; end if; end if;
entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;
entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;
FF_D: process(clock) begin if(clock'event and clock='1') then if(reset='1') then y <= '0'; else y <= d; end if; end if; end process;
FF_D: process(clock) begin if(clock'event and clock='1') then if(reset='1') then y <= '0'; else y <= d; end if; end if; end process;
entity ripple_carry is port( X, Y: in std_logic_vector(7 downto 0); c_in: in std_logic; c_out: out std_logic; Z: out std_logic_vector(7 downto 0)); end ripple_carry;
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
architecture dataflow of half_adder is begin s <= x XOR y; c <= x AND y; end dataflow;
s <= x xor y
result <= input_a nand input_b;
output_signal <= input1 nor input2;
output <= operand1 and operand2;
out_signal <= data1 nor data2;
result_sig <= input_x xor input_y;
output_val <= val1 and val2;
out_data <= dividend or divisor;
s_result <= data_in1 nand data_in2;
output_data <= val_a or val_b;
entity full_adder is port ( x, y, z : in std_logic; s, c : out std_logic); end full_adder; architecture struct_dataflow of full_adder is component half_adder port (x, y : in std_logic; s, c: out std_logic); end component; signal hs, hc, tc : std_logic; begin HA1: half_adder port map(x, y, hs, hc); HA2: half_adder port map(hs, z, s, tc); c <= tc or hc; end struct_dataflow;
entity mul8x8 is port ( x: in unsigned (7 downto 0); y : in unsigned(7 downto 0); p: out unsigned(15 downto 0)); end mul8x8;
architecture mul_arch of mul8x8 is begin p <= x * y; end mul_arch;
entity molt_rob is port( clock, reset, start: in std_logic; X, Y: in std_logic_vector(7 downto 0); P: out std_logic_vector(15 downto 0); stop_cu: out std_logic); end molt_rob;
component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;
component unita_operativa is port(X, Y: in std_logic_vector(7 downto 0); clock, reset: in std_logic; loadAQ, shift, loadM, sub, selM, selAQ, selF, count_in: in std_logic; count: out std_logic_vector(2 downto 0); P: out std_logic_vector(15 downto 0)); end component;
signal tempq0, temp_selM, temp_selAQ, temp_clock, temp_sub,temp_loadAQ: std_logic;
signal temp_count: std_logic_vector(2 downto 0);
signal temp_p: std_logic_vector(15 downto 0);
signal temp_count_in, t_load_add: std_logic;
signal fine_conteggio: std_logic;
signal temp_shift, temp_fshift: std_logic;
signal temp_loadM: std_logic;
signal temp_stop_cu: std_logic;
signal temp_reset_in: std_logic;
signal temp_selF: std_logic;
UC: unita_controllo port map (tempq0, clock, reset, start, temp_count, temp_loadM, temp_count_in, temp_loadAQ, temp_shift, temp_selM, temp_selAQ, temp_selF, temp_sub, temp_stop_cu);
UO: unita_operativa port map (X, Y, clock, reset, temp_loadAQ, temp_shift, temp_loadM, temp_sub, temp_selM, temp_selAQ, temp_selF, temp_count_in, temp_count, temp_p);
tempq0 <= temp_p(0);
signal_1 <= signal_2(0);
signal_4 <= signal_3(0);
signal_5 <= signal_6(0);
signal_8 <= signal_7(0);
signal_9 <= signal_10(3);
signal_12 <= signal_11(4);
signal_13 <= signal_14(2);
signal_16 <= signal_15(1);
signal_17 <= signal_18(3);
signal_20 <= signal_19(0);
RA0: full_adder port map(X(0), Y(0), c_in, temp(0), Z(0));
RA7: full_adder port map(X(7), Y(7), temp(6), c_out, Z(7));
RA1to6: FOR i IN 1 TO 6 GENERATE RA: full_adder port map(X(i), Y(i), temp(i-1), temp(i), Z(i)); END GENERATE;
entity myFA is port(OP_A, OP_B, CIN: in std_logic; S, COUT: out std_logic); end myFA;
S <= (OP_A xor OP_B) xor CIN;
COUT <= (OP_A and OP_B) or (CIN and(OP_A or OP_B));
entity RCA_Nbit is generic (N: natural range 0 to 32 := 8); port(OP_A_RCA, OP_B_RCA: in std_logic_vector(N-1 downto 0); CIN_RCA: in std_logic; S_RCA: out std_logic_vector(N-1 downto 0); COUT_RCA, OV: out std_logic); end RCA_Nbit;
signal cout_int: std_logic_vector(N-1 downto 0);
signal s_int: std_logic_vector(N-1 downto 0);
S_RCA <= s_int;
COUT_RCA <= cout_int(N-1);
FA_0: myFA port map(OP_A => OP_A_RCA(0), OP_B => OP_B_RCA(0), CIN => CIN_RCA, S => s_int(0), COUT => cout_int(0));
entity deglitcher is port (clk : in std_logic; rst_n : in std_logic; d : in std_logic; q : out std_logic); end entity deglitcher;
clk : in std_logic; 
rst_n : in std_logic; 
d : in std_logic; 
q : out std_logic
constant n : integer := 1000;
signal d_nxt : std_logic;
signal d_reg : std_logic;
signal q_nxt : std_logic;
signal q_reg : std_logic;
signal count_nxt : integer range 0 to n - 1;
signal count_reg : integer range 0 to n - 1;
if ((d xor d_reg) = '1') then ; end if;
if ((d xor d_reg) = '1') then ; end if;
count_nxt <= 0;
if (count_reg < n - 1) then
count_nxt <= count_reg + 1;
clk_i : in std_logic;
rst_n_i : in std_logic;
scl_i : in std_logic;
cs_i : in std_logic;
done_i : in std_logic;
data_0_o : out std_logic_vector(15 downto 0);
data_1_o : out std_logic_vector(15 downto 0);
data_2_o : out std_logic_vector(15 downto 0);
data_3_o : out std_logic_vector(15 downto 0);
data_4_o : out std_logic_vector(15 downto 0);
data_5_o : out std_logic_vector(15 downto 0);
ldac_i : in std_logic;
sda_i : in std_logic
constant DOUT_LEN : integer := 16;
constant DATA_LEN : integer := 24;
constant CLK_DIV : integer := 100;
signal i_bit_counter : integer range 0 to 24;
signal i_sck_cpy : std_logic;
signal i_sck_re_tk : std_logic;
signal i_sck_fe_tk : std_logic;
signal i_cs_cpy : std_logic;
signal i_cs_re_tk : std_logic;
signal i_cs_fe_tk : std_logic;
signal i_ldac_cpy : std_logic;
signal i_ldac_re_tk : std_logic;
signal i_ldac_fe_tk : std_logic;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0);
i_sr_data <= (others => '0');
i_data_0 <= (others => '0');
i_data_1 <= (others => '0');
i_data_2 <= (others => '0');
i_data_3 <= (others => '0');
i_data_4 <= (others => '0');
i_data_5 <= (others => '0');
if i_sr_data(23 downto 16) = x"08" or i_sr_data(23 downto 16) = x"09"or i_sr_data(23 downto 16) = x"0A" or i_sr_data(23 downto 16) = x"0B" or i_sr_data(23 downto 16) = x"0C" then ; end if ;
if i_sr_data(23 downto 16) = x"08" then ; end if;
if foo(22 downto 15) = x"1A" then ; end if;
if bar(21 downto 14) = x"2B" then ; end if;
if baz(20 downto 13) = x"3C" then ; end if;
if xyz(19 downto 12) = x"4D" then ; end if;
if abc(18 downto 11) = x"5E" then ; end if;
if def(17 downto 10) = x"6F" then ; end if;
if ghi(16 downto 9) = x"77" then ; end if;
if jkl(15 downto 8) = x"88" then ; end if;
if mno(14 downto 7) = x"99" then ;end if;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0);
i_sr_data <= i_sr_data(i_sr_data'length - 2 downto 0) & sda_i;
i_data_0 <= i_data_0(i_data_0'length - 2 downto 0) & i_bit_counter;
i_data_1_out <= i_data_1_out(i_data_1_out'length - 2 downto 0) & i_sck_cpy;
i_data_2 <= i_data_2(i_data_2'length - 2 downto 0) & i_cs_fe_tk;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 2 downto 0) & i_ldac_cpy;
i_data_4 <= i_data_4(i_data_4'length - 2 downto 0) & i_sr_data;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 2 downto 0) & i_data_0;
i_sr_data <= i_sr_data(i_sr_data'length - 2 downto 0) & i_data_1_out;
i_data_0_out <= i_data_0_out(i_data_0_out'length - 2 downto 0) & i_data_2_out;
i_data_0 <= i_data_0(i_data_0'length - 3 downto 0) & i_bit_counter;
i_data_1_out <= i_data_1_out(i_data_1_out'length - 3 downto 0) & i_sck_cpy;
i_data_2 <= i_data_2(i_data_2'length - 3 downto 0) & i_cs_fe_tk;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 3 downto 0) & i_ldac_cpy;
i_data_4 <= i_data_4(i_data_4'length - 3 downto 0) & i_sr_data;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 3 downto 0) & i_data_0;
i_sr_data <= i_sr_data(i_sr_data'length - 3 downto 0) & i_data_1_out;
i_data_0 <= i_data_0(i_data_0'length - 4 downto 0) & i_bit_counter;
i_data_1_out <= i_data_1_out(i_data_1_out'length - 4 downto 0) & i_sck_cpy;
i_data_2 <= i_data_2(i_data_2'length - 4 downto 0) & i_cs_fe_tk;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 4 downto 0) & i_ldac_cpy;
i_data_4 <= i_data_4(i_data_4'length - 4 downto 0) & i_sr_data;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 4 downto 0) & i_data_0;
i_sr_data <= i_sr_data(i_sr_data'length - 4 downto 0) & i_data_1_out;
i_data_0_out <= i_data_0_out(i_data_0_out'length - 4 downto 0) & i_data_2_out;
i_data_1 <= i_data_1(i_data_1'length - 4 downto 0) & i_data_3_out;
data_0_o <= i_data_0_out when rst_n_i = '1' else (others => '0');
data_1_o <= i_data_1_out when rst_n_i = '1' else (others => '0');
data_2_o <= i_data_2_out when rst_n_i = '1' else (others => '0');
data_3_o <= i_data_3_out when rst_n_i = '1' else (others => '0');
data_4_o <= i_data_4_out when rst_n_i = '1' else (others => '0');
data_5_o <= i_data_5_out when rst_n_i = '1' else (others => '0');
entity tb_dac is end tb_dac;
signal i_start_counter : integer range 0 to 400;
signal t_start : std_logic;
signal t_stb_counter : integer range 0 to 108;
signal t_stb : std_logic;
signal t_rst_n : std_logic;
signal t_clk_en : std_logic;
signal t_clk : std_logic;
signal t_scl : std_logic;
signal t_sda : std_logic;
signal t_cs : std_logic;
signal t_done : std_logic;
signal t_data_to_send : std_logic_vector(DAC_D_IN_LEN - 1 downto 0);
signal t_dac_val_0 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_1 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_2 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_3 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_4 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_5 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_ldac : std_logic;
t_rst_n <= '0', '1' after CLK_HPER * 10;
t_rst_n <= '0', '1' after CLK_HPER * 10;
t_clk <= '1' after CLK_HPER when t_clk = '0' else '0' after CLK_HPER;
t_clk <= '1' after CLK_HPER when t_clk = '0' else '0' after CLK_HPER;
t_clk_en <= '1';
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;
library std;
use std.textio.all;
library work;
use work.tb_AESA_if_pkg.all;
start_proc : process (t_clk) begin ; end process start_proc;
if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;
if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;
if i_start_counter = STB_DLY - 1 then t_stb <= '1'; end if;
if i_start_counter = STB_DLY - 1 then t_stb <= '1'; end if;
clk_i => t_clk
rst_n_i => t_rst_n
scl_i => t_scl
cs_i => t_cs
done_i => t_done
data_0_o => t_dac_val_0
data_1_o => t_dac_val_1
data_2_o => t_dac_val_2
data_3_o => t_dac_val_3
data_4_o => t_dac_val_4
data_5_o => t_dac_val_5
ldac_i => t_ldac
sda_i => t_sda
clk_i => t_clk
rst_n_i => t_rst_n
clk_en_i => t_clk_en
start_i => t_start
strobe_i => t_stb
done_o => t_done
data_i => t_data_to_send
scl_o => t_scl
sda_o => t_sda
ldac_o => t_ldac
cs_o => t_cs
entity TimeExpander is generic (clock_multiplier : integer := 5000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end TimeExpander;
clock_multiplier : integer := 5000000
clk : in std_logic;
rst_n : in std_logic;
enable : in std_logic;
tick_o : out std_logic;
signal tick_o_nxt : std_logic;
signal reg_count_nxt : integer range 0 to clock_multiplier - 1;
signal tick_o_reg : std_logic;
signal reg_count_reg : integer range 0 to clock_multiplier - 1;
sync_proc : process (clk, rst_n) begin ; end process sync_proc;
if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0;
if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0;
tick_o_reg <= tick_o_nxt;
reg_count_reg <= reg_count_nxt;
expander : process (clk, rst_n, reg_count_reg, enable)
tick_o_nxt <= '0';
tick_o_nxt <= '0';
if enable = '1' then if reg_count_reg = clock_multiplier - 1 then tick_o_nxt <= '1'; reg_count_nxt <= 0;
if enable = '1' then if reg_count_reg = clock_multiplier - 1 then tick_o_nxt <= '1'; reg_count_nxt <= 0;
reg_count_nxt <= reg_count_reg + 1;
reg_count_nxt <= 0;
tick_o <= tick_o_reg;
constant clk_period : time := 10 ns;
constant unsaccoditempo : time := 550 ns;
constant t_clock_multiplier : integer := 50;
signal clk_t : std_logic := '0';
signal rst_n : std_logic := '1';
signal run : boolean := TRUE;
signal t_clk : std_logic;
signal t_rst_n : std_logic;
signal t_enable : std_logic;
signal t_tick_o : std_logic;
component TimeExpander generic (clock_multiplier : integer := 10000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end component TimeExpander;
clock_multiplier : integer := 10000000
use grlib.stdlib.all;
use grlib.devices.all;
use techmap.gencomp.all;
use techmap.allclkgen.all;
library gaisler;
component GPIO is generic (BitWidth: integer); port ( IO_sel: in std_logic; IO: inout std_logic_vector (BitWidth-1 downto 0); WrtData: in std_logic_vector (BitWidth-1 downto 0); RdData: out std_logic_vector (BitWidth-1 downto 0)); end component;
component ALU is generic (BitWidth: integer); port ( A: in std_logic_vector (BitWidth-1 downto 0); B: in std_logic_vector (BitWidth-1 downto 0); Command: in std_logic_vector (3 downto 0); Cflag_in: in std_logic; Cflag_out: out std_logic; Result: out std_logic_vector (BitWidth-1 downto 0)); end component;
entity up_down_counter is generic ( WIDTH: positive := 8); port ( clk_en_p: in std_logic; up_down_p: in std_logic; value_p: out std_logic_vector(WIDTH - 1 downto 0); reset: in std_logic; clk: in std_logic); end up_down_counter;
component modn is generic( n:integer := 4 ); port( clk: in std_logic; inc: in std_logic; enable: in std_logic; reset: in std_logic; overflow: out std_logic; output: out std_logic_vector(f_log2(n)-1 downto 0)); end component;
component pulser is generic( delay:integer := 500000 ); port( clk: in std_logic; enable: in std_logic; output: out std_logic ); end component;
component PicoCPU is port( rst: in std_logic; clk: in std_logic; FlagOut: out std_logic_vector ( 3 downto 0); IO: inout std_logic_vector (CPU_Bitwidth-1 downto 0); output: out std_logic_vector ( CPU_Bitwidth-1 downto 0)); end component;
component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component;
component system_inverter_0_0 is port ( x : in STD_LOGIC; x_not : out STD_LOGIC); end component;
component system_rgb565_to_rgb888_0_0 is port ( clk : in STD_LOGIC; rgb_565 : in STD_LOGIC_VECTOR ( 15 downto 0 ); rgb_888 : out STD_LOGIC_VECTOR ( 23 downto 0 )); end component;
component system_util_vector_logic_0_0 is port ( Op1 : in STD_LOGIC_VECTOR ( 0 to 0 ); Op2 : in STD_LOGIC_VECTOR ( 0 to 0 ); Res : out STD_LOGIC_VECTOR ( 0 to 0 )); end component;
rotl: process(codoprotl, portArotl) begin if(codoprotl = "1101") then outrotl(0) <= portArotl(7); outrotl(7 downto 1) <= portArotl(6 downto 0); outFlagrotl <= '1'; else outrotl <= (others => 'Z'); outFlagrotl <= 'Z'; end if; end process rotl;
PRIORITY_REG_PROCESS:process (Clk, Rst, Priorreg_wrce, Dpen, Shift, Bus2ip_data, Master_id_in, master_id) begin if Clk'event and Clk = '1' then if Rst = RESET_ACTIVE then master_id <= C_RESET_VALUE; elsif Priorreg_wrce = '1' then master_id <= Bus2ip_data(BIT_INDEX to C_OPBDATA_WIDTH-1); elsif (Dpen = '1' and Shift = '1') then master_id <= Master_id_in; else master_id <= master_id; end if; end if; end process;
sync_carry: process (clk, reset) begin if reset = '1' then carry <= '0'; elsif rising_edge(clk) then carry <= carry_nxt; end if; end process;
dir1:process(direction, clk_48) begin if rising_edge(clk_48) then if (direction='0') then count <= count+1; end if; if (direction='1') then count <= count-1; end if; end if; end process;
process(control, data_in_array) begin case (control) is when "00" => data_out <= data_in_array(0); when "01" => data_out <= data_in_array(1); when "10" => data_out <= data_in_array(2); when "11" => data_out <= data_in_array(3); when others => data_out <= "0000"; end case; end process;
clk200p <= not clk200p after 2.5 ns;
data <= buskeep(data) after 5 ns;
clk <= not clk after ct * 1 ns;
stimulus : input <= X"00000000", X"00000008" after 10 ns, X"00000010" after 20 ns, X"00000018" after 30 ns, X"FFFFFFF8" after 40 ns, X"FFFFFFF0" after 50 ns, X"FFFFFF00" after 60 ns;
sys_rst_in <= '0', '1' after 200 ns;
TYPE hex_digit IS ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f');
TYPE direction is (LITTLE_ENDIAN, BIG_ENDIAN);
TYPE hex_number IS array (POSITIVE range <>) OF hex_digit;
TYPE hexstdlogic IS ARRAY (hex_digit'LOW TO hex_digit'HIGH) of std_logic_vector(3 DOWNTO 0);
TYPE stdlogic_boolean_table is array(std_ulogic, std_ulogic) of boolean;
if ((dci.eenaddr or dci.enaddr) = '1') or (r.dstate /= idle) or ((dsu = 1) and (dci.dsuen = '1')) or (r.flush = '1') or (is_fpga(memtech) = 1) then enable := (others => '1'); else enable := (others => '0'); end if;
if DSETS > 1 then if conv_integer(r.rndcnt) = (DSETS - 1) then v.rndcnt := (others => '0'); else v.rndcnt := r.rndcnt + 1; end if; end if;
if gls_reset = '1' then write_ack <= '0'; elsif rising_edge(gls_clk) then if ((wbs_strobe and wbs_write and wbs_cycle) = '1') then write_ack <= '1'; else write_ack <= '0'; end if; end if;
if (udbus/=X"0D" and udbus/=X"0A") then write(L,std_to_char(udbus)); end if;
if (vcount<=494 and vcount>=493) then VSync <= '0'; else VSync <= '1'; end if;
i.cmd_byte_addr <= r.haddr(29 downto 2) & "00";
vcc <= (others => '1');
ahbso(2) <= ahbs_none;
memi.edac <= gpioo.val(2); 
memi.bwidth <= gpioo.val(1 downto 0);
a := a + 1;
BitWidth := BitWidth + 5;
BitWidth := BitWidth - 10;
CPU_Bitwidth := CPU_Bitwidth+45;
CPU_Bitwidth := CPU_Bitwidth-78;
component osctimer generic(TIMER_DIV : string); port( DYNOSCDIS : in std_logic; TIMERRES : in std_logic; OSCOUT : out std_logic; TIMEROUT : out std_logic); end component;
component altpll generic(operation_mode: string := "NORMAL"; inclk0_input_frequency: positive; width_clock: positive := 6; clk0_multiply_by: positive := 1; clk0_divide_by: positive := 1; clk1_multiply_by: positive := 1; clk1_divide_by: positive := 1; extclk0_multiply_by: positive := 1; extclk0_divide_by: positive := 1); port(inclk: in std_logic_vector(1 downto 0); clkena: in std_logic_vector(5 downto 0); extclkena: in std_logic_vector(3 downto 0); clk: out std_logic_vector(width_clock-1 downto 0); extclk: out std_logic_vector(3 downto 0); locked: out std_logic); end component;
component altera_pll generic(clk_mul: integer := 1; clk_div: integer := 1; clk_freq: integer := 25000; clk2xen: integer := 0; sdramen: integer := 0); port(inclk0: in std_ulogic; e0: out std_ulogic; c0: out std_ulogic; c0_2x: out std_ulogic; locked: out std_ulogic); end component;
component counter is generic (constant cnt_max : integer := 50000000); port ( iClk: in std_logic; iReset: in std_logic; is_forward: in std_logic; is_enabled: in std_logic; output_data: out std_logic_vector(7 downto 0)); end component;
component input_handler is generic (COUNT_MAX: integer := 500000); port (row_sel: in std_logic_vector(4 downto 0); clk: in std_logic; reset: in std_logic; key_out: out std_logic_vector(7 downto 0); col_sel: out std_logic_vector(3 downto 0); keypress_out: out std_logic); end component;
clk2xgen: if (clk2xen /= 0) generate clkena(1 downto 0) <= "11"; end generate;
c0: if (PCISYSCLK = 0) or (PCIEN = 0) generate clkint <= clkin; end generate c0;
if sela = '1' then q <= a; elsif selb = '1' then q <= b; else q <= c; end if;
if rising_edge(clk) then if clr = '0' then q <= '0'; else q <= d; end if;
gxa: IF (unsigned = 0) GENERATE cc(mantissa+10 DOWNTO mantissa+5) <= aa(32) & aa(32) & aa(32) & aa(32) & aa(32); END GENERATE;
gen_num:FOR N IN LOOP_COUNT-1 DOWNTO 0 GENERATE rd_gen_inst2:fifo_rng GENERIC MAP(WIDTH => 8, SEED => TB_SEED+N) PORT MAP(CLK => RD_CLK, RESET => RESET, RANDOM_NUM => rand_num(8*(N+1)-1 downto 8*N), ENABLE => pr_r_en ); END GENERATE;
prom0: for i in 0 to (romwidth/8)-1 generate sr0: sram generic map (index => i+4, abits => romdepth, fname => promfile) port map (address(romdepth downto 1), data(31-i*8 downto 24-i*8), romsn(0), writen, oen); end generate;
gen_rx_ddr_lvds : for i in 0 to 4 generate inst_IDDR : IDDR generic map (DDR_CLK_EDGE => "SAME_EDGE_PIPELINED", SRTYPE => "ASYNC") port map (Q1 => rx_data_3x_i(i), Q2 => rx_data_3x_q(i), C => clk_rx_3x, CE => '1', D => rx_data_3x_ddr(i), R => rx_reset, S => '0'); inst_IBUFDS : IBUFDS generic map (DIFF_TERM => TRUE, IOSTANDARD => "DEFAULT") port map (I => RX_DATA_P(i), IB => RX_DATA_N(i), O => rx_data_3x_ddr(i)); end generate;
gen_tx_ddr_lvds : for i in 0 to 5 generate inst_ODDR : ODDR generic map (DDR_CLK_EDGE => "OPPOSITE_EDGE", SRTYPE => "ASYNC") port map (Q => tx_data_3x_ddr(i), C => clk_tx_3x, CE => '1', D1 => tx_data_3x_i(i), D2 => tx_data_3x_q(i), R => tx_reset, S => '0'); inst_OBUFDS : OBUFDS generic map (IOSTANDARD => "DEFAULT") port map (I => tx_data_3x_ddr(i), O => TX_DATA_P(i), OB => TX_DATA_N(i)); end generate;
genByteComps : for i in 0 to 15 generate MatchVectorxS(i) <= '1' when CandidatexDI((i+1)*8-1 downto i*8) = LookAheadxDI((i+1)*8-1 downto i*8) else '0'; end generate genByteComps;
TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);
TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic;
type state_array_t is array(1 to num_rng) of std_logic_vector(width-1 downto 0);
type data_t is array(0 to C_NUM_SENSORS - 1) of std_logic_vector (C_COUNTER_WIDTH - 1 downto 0);
type hsv_function is array ( 0 to 255) of integer;
address(0) <= '0';
noise(15) <= raw_lfsr(1);
outrotl(7 downto 1) <= portArotl(6 downto 0);
data_out <= data_in_array(0);
dbg_ila_probe0(31) <= cmd_fifo_empty;
case mcmmo.data(PT_ET_U downto PT_ET_D) is when ET_INV => inv := '1'; when ET_PTD => ptd := '1'; goon := '1'; when ET_PTE => pte := '1'; found := '1'; when ET_RVD => rvd := '1'; null; when others => null; end case;
case r.haddr(1 downto 0) is when "00" => wmask := "1101"; when "01" => wmask := "1110"; when "10" => wmask := "0111"; when others => wmask := "1011"; end case;
case ra.raddr(2 downto 2) is when "0" => rdata := r.hrdata(127 downto 0); when others => rdata := r.hrdata(255 downto 128); end case;
case w is when 'U' => w := 'X'; when 'X' => null; when '0' => w := w2; when '+' | '-' => if w2 /= '0' then w := 'X'; end if; end case;
CASE s IS WHEN '0' => RETURN ('0'); WHEN '1' => RETURN ('1'); WHEN OTHERS => RETURN ('0'); END CASE;
xenable <= enable when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');
buffer_Full <= '1' when (addr_i = "1111") else '0';
etho.mdio_oe <= ahbmi.testoen when (scanen = '1') and (ahbmi.testen = '1') else lmdio_oe;
configuration_vector <= "10000" when (autonegotiation = 1) else "00000";
gmiii.tx_dv <= cnt_en when gmiio.tx_en = '1' else '1';
clk <= '0'; wait for clk_period; clk <= not clk; wait for clk_period;
wait until s0_arready = '1';
wait until rising_edge(clk);
wait until s0_awready = '1' and s0_wready = '1';
wait until clock='1';
constant REVISION : integer := 0;
constant MAX_CNT : natural := 32;
constant LATCH_CNT : boolean := clatch /= 0;
constant mcnt_none : mcnt_type := ('0', '0', zero32);
constant RES : reg_type := ('0', '0', '0', '0');
test0 : grtestmod port map (rst, clk, error, address(21 downto 2), smsc_data, smsc_ncs, oen, writen, open);
rst0 : rstgen port map (rst, clkm, cgo.clklock, rstn, rstraw);
u2: component ycbcr_to_rgb port map(clk => clk, y => y, cb => cb, cr => cr, red => red, green => green, blue => blue);
BSCAN_SPARTAN3_inst : BSCAN_SPARTAN3 port map ( CAPTURE => CAPTURE, DRCK1 => DRCK1, DRCK2 => open, RESET => open, SEL1 => SEL1, SEL2 => open, SHIFT => SHIFT, TDI => TDI, UPDATE => UPDATE, TDO1 => TDO1, TDO2 => open );
clkin1_bufg : BUFG port map (O => clk_100MHz_clk_video, I => clk_100MHz);
variable acc, acc1, acc2 : std_logic_vector(48 downto 0);
variable zero, rsigned, rmac : std_logic;
variable v : mul_regtype;
variable v : reg_type;
variable startsd : std_ulogic;
assert (to_x01(f_led(6)) = '1') report "*** IU in error mode, simulation halted ***" severity error;
assert false report "outpad_ddr: Not yet supported on Nextreme2" severity failure;
assert(Q = std_logic_vector(to_unsigned(0, 32))) report "Clear failed" severity warning;
assert ip_pkt_count = x"00" report "ip_pkt_count not initialised correctly on reset";
assert sim_done_i = '0' report "Simulation Complete for:" & AXI_CHANNEL severity note;
addr := to_integer(unsigned(ADR_I(10 downto 0)));
font_byte <= ram_font(to_integer(unsigned(font_address)));
initaddr := std_logic_vector((unsigned(initaddr) + 1));
memory_ram(to_integer(unsigned(address_a) + index)) <= data_in_a(((ram_word_size)*(index + 1) - 1) downto ((ram_word_size)*index)); 
pdl_empty <= unsigned(pdl_addr_reg) = 0;
with iThisRegAddr select iDataOutput <= iThisR0 when "00", iThisR1 when "01", iThisR2 when "10", sw when others;
with AC_I.use_logic select alu_logic_shift <= alu_logic when "01", not alu_logic when "11", alu_shift when others;
with GPIO_enable select GPIO_inout <= 	GPIO_write when '1', 'Z' when others;
with byte_en select end_phase <= data_rden & "00" when "0001", data_rden & "01" when "0011", data_rden & "11" when "1111", "000" when others;
with data select decoded <= "00000001" when "00001001110100011111", "00000010" when "00001001110100011110", "00000011" when "00001001110100001111", "00000100" when "00001001110100001110", "00000101" when "00001001110100101001", "00000110" when "00001001110100101000", "00000111" when "00001001110100101101", "00001000" when "00001001110100101100", "00001001" when "00001001110100010001", "00010000" when "00001001110100010000", "00010001" when "00001001110100011001", "00010010" when "00001001110100011000", "00010011" when "00001001110100001101", "00010100" when "00001001110100001100", "00010101" when "00001001110100100111", "00010110" when "00001001110100100110", "00010111" when "00001001110100101011", "00011000" when "00001001110100101010", "00011001" when "00001001110100111000", "00100000" when "00001001110100110111", "11101110" when others;
with c.b_request_complete select c.a_request.size <= c.sys_master_dp_out.size when '1', r.b_request.size when '0', (others => 'X') when others;
with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;
with sel select dataout <= "01" when "0", "10" when "1", (others => 'X') when others;
with sel select dataout <= "001" when "00", "010" when "01", "100" when "10", (others => 'X') when others;
with sel select dataout <= "0001" when "00", "0010" when "01", "0100" when "10", "1000" when "11", (others => 'X') when others;
entity mux_2_1 is generic(SIZE: natural := 4); port(select_in: in std_logic; data_0_in: in std_logic_vector(SIZE-1 downto 0); data_1_in: in std_logic_vector(SIZE-1 downto 0); data_out: out std_logic_vector(SIZE-1 downto 0)); end mux_2_1;
mux_4_1 : process(y, key_in, exp_sn_out, reg_Q) begin case y is when "00" => reg_D <= key_in; when "01" => reg_D <= exp_sn_out; when others => reg_D <= reg_Q; end case; end process mux_4_1;
component carry_ripple_adder generic (WIDTH: integer); port (a: in std_logic_vector (WIDTH-1 downto 0); b: in std_logic_vector (WIDTH-1 downto 0); ci: in std_logic; s: out std_logic_vector (WIDTH-1 downto 0); co: out std_logic); end component;
component alt_dspbuilder_pipelined_adder_GNTWZRTG4I generic (width: natural := 0; pipeline: integer := 0); port (aclr: in std_logic := 'X'; add_sub: in std_logic := 'X'; cin: in std_logic := 'X'; clock: in std_logic := 'X'; cout: out std_logic; dataa: in std_logic_vector(width-1 downto 0) := (others => 'X'); datab: in std_logic_vector(width-1 downto 0) := (others => 'X'); ena: in std_logic := 'X'; result: out std_logic_vector(width-1 downto 0); user_aclr: in std_logic := 'X'); end component;
entity adder is port(A: in std_logic; B: in std_logic; carryIn: in std_logic; carryOut: out std_logic; fnord: out std_logic; baz: out std_logic_vector(7 downto 0); sum: out std_logic); end adder;
component FullAdder1Bit is Port (A: in STD_LOGIC; B: in STD_LOGIC; CIN: in STD_LOGIC; SUM: out STD_LOGIC; COUT: out STD_LOGIC); end component;
entity adder_full is port(in_0: in std_logic; in_1: in std_logic; carry_in: in std_logic; sum: out std_logic; carry_out: out std_logic); end entity adder_full;
entity adder is port(a: in std_logic_vector(7 downto 0); b: in std_logic_vector(7 downto 0); cin: in std_logic; cout: out std_logic; sum: out std_logic_vector(7 downto 0)); end adder;
entity adder is port(D: out std_logic; A: out std_logic; sel: in std_logic_vector(2 downto 0); clock: in std_logic; enable2: in std_logic; enable: in std_logic); end adder;
entity adder is port(A: in std_logic; B: in std_logic; carryIn: in std_logic; carryOut: out std_logic; fnord: out std_logic; baz: out std_logic_vector(7 downto 0); clock: in std_logic; clock2: in std_logic; sum: out std_logic); end adder;
sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);
vreg.sh(0) := unsigned(in_data(7 downto 0));
data <= memory(to_integer(unsigned(addr)));
f_V_fu_377_p2 <= std_logic_vector(unsigned(r_V_10_cast1_i_cast_fu_353_p1) - unsigned(tmp_55_cast_i_cast_fu_373_p1));
grp_fu_418_p10 <= std_logic_vector(IEEE.numeric_std.resize(unsigned(f_V_cast_fu_408_p1),47));
variable temp : unsigned(7 downto 0);
variable res : string(s'range);
variable updateFlag : boolean;
variable oline : line;
variable factor, result: integer;
type ctrarr is array (1 to NUM_C) of std_logic_vector(C_W-1 downto 0);
type core_type is array(1023 downto 0) of std_logic_vector(15 downto 0);
type aRxSetArr is array (3 downto 0) of aRxSet;
type T_SCALE_VALUES_FIFO is array (NUMBER_OF_SCALES-1 downto 0) of std_logic_vector(OUT_VERT_CONV_BW-1 downto 0);
type t_ram is array (0 to c_num_words-1) of unsigned(31 downto 0);
prom0: for i in 0 to (romwidth/8)-1 generate sr0 : sram generic map (index => i, abits => romdepth, fname => promfile) port map (sram_flash_addr(romdepth-1 downto 0), sram_flash_data(31-i*8 downto 24-i*8), flash_cex, sram_bw(i), sram_flash_oe_n); end generate;
bdr: for i in 0 to 3 generate data_pad: iopadv generic map (level => padlevel, tech => padtech, width => 8) port map (sram_dq(31-i*8 downto 24-i*8), memo.data(31-i*8 downto 24-i*8), memo.bdrive(i), memi.data(31-i*8 downto 24-i*8)); end generate;
x: for i in 0 to CFG_NCPU-1 generate irqi(i).irl <= "0000"; end generate;
nam1: for i in (CFG_NCPU+CFG_AHB_UART+CFG_GRPCI2_TARGET+CFG_GRPCI2_DMA+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE) to NAHBMST-1 generate ahbmo(i) <= ahbm_none; end generate;
nap0: for i in 12 to NAPBSLV-1 generate apbo(i) <= apb_none; end generate;
p_arst: arst <= '1', '0' after 5 *C_CLK_PERIOD;
weA <= '0', '1' after 50 ns, '0' after 650 ns;
enB <= '0', '1' after 350 ns;
diA <= "0000", "0001" after 150 ns, "0010" after 250 ns, "0011" after 350 ns, "0100" after 450 ns, "0101" after 550 ns;
addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns;
reg_data_out(reg_data_out'length - 1 downto PIX_DEPTH) <= reg_data_out(reg_data_out'length - PIX_DEPTH - 1 downto 0);
shift_reg <= shift_reg(shift_reg'length - 2 downto 0) & sdi;
shift_reg <= shift_reg(shift_reg'length - 3   downto 0) & sdi;
brkpt_reg <= cmd(0) & brkpt_reg(brkpt_reg'length - 3 downto 1);
brkpt_reg <= cmd(0) & brkpt_reg(brkpt_reg'length - 2 downto 1);
addr_dout_reg <= cmd(0) & addr_dout_reg(addr_dout_reg'length - 3 downto 1);
shift_reg <= sdi & shift_reg(shift_reg'length - 3 downto 1);
shift_reg <= sdi & shift_reg(shift_reg'length - 2 downto 1);
SampledBits <= SampledBits(SampledBits'length - 2 downto 0) & RxD_i;
SampledBits <= SampledBits(SampledBits'length - 3 downto 0) & RxD_i;
library ieee;
use ieee.math_real.all;
library work;
use work.AESA_if_pkg.all;
entity DAC_AD5724_mst is generic(DAC_D_IN_LEN_g : integer := 24); port(clk_i:in std_logic; rst_n_i:in std_logic; clk_en_i:in std_logic; start_i:in std_logic; strobe_i:in std_logic; done_o:out std_logic; data_i:in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o:out std_logic; sda_o:out std_logic; ldac_o:out std_logic; cs_o:out std_logic); end DAC_AD5724_mst;
clk_i : in std_logic;
rst_n_i : in std_logic;
clk_en_i : in std_logic;
start_i : in std_logic;
strobe_i : in std_logic;
done_o : out std_logic;
data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0);
scl_o : out std_logic;
sda_o : out std_logic;
ldac_o : out std_logic;
cs_o : out std_logic;
entity DAC_AD5724_mst is generic (DAC_D_IN_LEN_g : integer := 24); port (clk_i : in std_logic; rst_n_i : in std_logic; clk_en_i : in std_logic; start_i : in std_logic; strobe_i : in std_logic; done_o : out std_logic; data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o : out std_logic; sda_o : out std_logic; ldac_o : out std_logic; cs_o : out std_logic); end DAC_AD5724_mst;
architecture arch of DAC_AD5724_mst is begin ;  end arch
signal i_dly_counter : integer range 0 to 400;
signal i_slc_counter : integer range 0 to 100;
signal i_scl_cnt : integer range 0 to 24;
signal i_ldac_dly_cnt : integer range 0 to 20;
signal i_ldac_cnt : integer range 0 to 4;
signal i_clk_cnt : integer range 0 to 2;
signal i_sda : std_logic;
signal i_ldac : std_logic;
signal i_sck_cpy : std_logic;
signal i_sck_re_tk : std_logic;
signal i_cs_cpy : std_logic;
signal i_cs_re_tk : std_logic;
signal i_stb_cpy : std_logic;
signal i_stb_re_tk : std_logic;
signal i_stb_fe_tk : std_logic;
type clk_state is (clk_idle_st, clk_gen_st);
signal i_clk_state : clk_state;
type cmd_state is (idle_st, sample_st, done_st, wait_stb_st, ldac_low_st);
i_cs_cpy <= '0';
i_cs_cpy <= i_cs;
if rising_edge(clk_i) then if rst_n_i = '0' then i_cs_cpy <= '0'; else i_cs_cpy <= i_cs; end if; end if;
i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0';
i_cs_fe_tk <= '1' when i_cs_cpy = '1' and i_cs = '0' else '0';
sck_gen : process (clk_i)
if rst_n_i = '0' then ; end if;
if rst_n_i = '0' then ; end if;
i_scl <= '0';
i_scl_cnt <= 0;
case i_clk_state is
i_scl <= '0';
i_scl <= '0';
if start_i = '1' then ; end if ;
if i_slc_counter < DAC_CLK_DIV/2 then ; end if;
if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if;
if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if;
i_scl_cnt <= i_scl_cnt + 1;
sck_edge : process (clk_i) begin ; end process ;
if rst_n_i = '0' then ; end if;
i_sck_cpy <= i_scl;
sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
i_sck_re_tk <= '1' when i_sck_cpy = '0' and i_scl = '1' else '0';
i_sck_re_tk <= '1' when i_sck_cpy = '0' and i_scl = '1' else '0';
i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0';
i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0';
i_done <= '0';
i_done <= '0';
i_cs <= '1';
i_sda <= '0';
i_sda <= '0';
cs_o <= i_cs when rst_n_i = '1' else '1';
cs_o <= i_cs when rst_n_i = '1' else '1';
scl_o <= i_scl when rst_n_i = '1' else '0';
scl_o <= i_scl when rst_n_i = '1' else '0';
done_o <= i_done when rst_n_i = '1' else '0';
done_o <= i_done when rst_n_i = '1' else '0';
sda_o <= i_sda when rst_n_i = '1' else '0';
sda_o <= i_sda when rst_n_i = '1' else '0';
ldac_o <= i_ldac when rst_n_i = '1' else '1';
when idle_st =>
when sample_st =>
when done_st =>
when other_st =>
when start_st =>
when stop_st =>
i_stb_cpy <= trial(i_counter_1);
i_clk_state <= mamba(i_counter_2);
i_cs <= sign_data(i_counter_3);
i_scl <= val_vector(i_counter_4);
i_sck_cpy <= prova(i_counter_7);
i_sck_fe_tk <= data_i(i_counter_9);
i_ldac <= data_i(i_counter_10);
output_value <= output_value - 8;
sample_rate <= sample_rate - 20;
gain_value <= gain_value - 12;
error_count <= error_count - 6;
architecture behavioral of deglitcher_testbench is begin end architecture behavioral;
clk_generator : process is begin wait for clk_period / 2; clk_t <= not clk_t; end process clk_generator;
wait for 95 ns;
wait for 20 us;
wait for 20 us;
constant n : integer := 1000;
signal count_nxt : integer range 0 to n - 1;
update_state : process (clk) is begin if rising_edge(clk) then if (rst_n = '0') then q_reg <= '0'; d_reg <= '0'; else count_reg <= count_nxt; q_reg <= q_nxt; d_reg <= d_nxt; end if; end if; end process update_state;
count_nxt <= 0;
entity pwm_generator is port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; data_out : out std_logic); end pwm_generator;
clk : in std_logic;
rst_n : in std_logic;
constant DIV : integer := 200;
signal count_reg, count_nxt : integer range 0 to DIV - 1;
constant FACTOR : integer := 100;
constant TIMEOUT_VAL : integer := 1000;
constant SCALE_FACTOR : integer := 10;
constant SAMPLE_RATE : integer := 10000;
constant THRESHOLD : integer := 50;
constant REFERENCE_VOLTAGE : integer := 5000;
update_process: process(clk) begin if(rising_edge(clk)) then if(rst_n = '0') then count_reg <= 0; data_out_reg <= '0'; else count_reg <= count_nxt; data_out_reg <= data_out_nxt; end if; end if; end process update_process;
if(rst_n = '0') then ; end if ;
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
data_out_nxt <= '0' when count_reg = DIV/2 - 1 else '1';
entity pwm_generator_TB is end pwm_generator_TB;
constant clk_period : time := 5 ns;
signal clk_t : std_logic := '0';
signal enable : std_logic := '1';
pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);
wait for 50*clk_period;
wait for 120*clk_period;
entity TimeExpander is generic (clock_multiplier : integer := 5000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end TimeExpander;
sync_proc : process (clk, rst_n) begin end process sync_proc
round_key_in: in std_logic_vector(63 downto 0);
data_in: in std_logic_vector(63 downto 0);
data_out: out std_logic_vector(63 downto 0)
entity add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end add_round_key;
entity cypher_layer is port(); end cypher_layer
round_counter: in std_logic_vector(4 downto 0);
round_counter: out std_logic_vector(4 downto 0);
round_key_in: in std_logic_vector(63 downto 0);
round_key_in: out std_logic_vector(63 downto 0);
reg_key_in: in std_logic_vector(79 downto 0);
reg_key_in: out std_logic_vector(79 downto 0);
reg_key_in: in std_logic_vector(79 downto 0);
data_out: out std_logic_vector(63 downto 0);
data_out: out std_logic_vector(63 downto 0);
reg_key_out: out std_logic_vector(79 downto 0)
entity cypher_layer is port (round_counter: in std_logic_vector(4 downto 0); round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0) ); end cypher_layer;
component sbox is port(); end component;
component add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
component sbox is port(data_in: in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0)); end component;
component perm_layer is port(data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0)); end component;
component key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0)); end component;
component key_update is port () end component;
reg_key_out: out std_logic_vector(79 downto 0);
reg_key_in: in std_logic;
reg_key_in: in std_logic;
round_counter: in std_logic_vector(4 downto 0);
signal data_out_temp1: std_logic_vector(63 downto 0);
signal data_out_temp1: std_logic_vector(63 downto 0);
signal data_out_temp2: std_logic_vector(63 downto 0);
signal data_out_temp3: std_logic_vector(63 downto 0);
signal data_out_temp3: std_logic_vector(63 downto 0);
signal round_key_temp: std_logic_vector(63 downto 0);
ark: add_round_key port map ();
ark: add_round_key port map (round_key_in,data_in,data_out_temp1);
pl: perm_layer port map (data_out_temp2,data_out);
pl: perm_layer port map ();
kupd: key_update port map(reg_key_in,round_counter,reg_key_out);
end behavioral;
sbox_i: for i in 0 to 15 generate end generate sbox_i
sbox_i: for i in 0 to 15 generate sboxi: sbox port map(); end generate sbox_i;
add_round_key_i: for i in 0 to 63 generate add_round_keyi: add_round_key port map(); end generate add_round_key_i;
sbox_i : for i in 0 to 15 generate sboxi: sbox port map ( data_out_temp1 (4*i+3 downto 4*i), data_out_temp2(4*i+3 downto 4*i) ); end generate sbox_i;
use ieee.numeric_std.all;
entity inputmanager is port () end inputmanager;
entity inputmanager is port ( clock: in std_logic; rst: in std_logic; stringa_in: in std_logic_vector(15 downto 0); en: in std_logic; stringa_out: out std_logic_vector(63 downto 0) ); end inputmanager;
en: in std_logic;
stringa_in: in std_logic_vector(15 downto 0);
clock: in std_logic;
type state is (idle, primo, secondo, terzo);
type ciao is (x, y, z);
type rob is (x, c, v, b, n);
signal current_state: state := idle;
signal current_state: state := secondo;
signal current_state: state := bau;
signal stringa1: std_logic_vector(15 downto 0) := ( others => '0' );
signal stringa2: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');
signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
x <= y & z
prova <= stringa1 & stringa2 & stringa3 & stringa4;
if(rising_edge(clock)) then
process(clock)
if ( rst = '1' ) then
if ( rst = '1' ) then
stringa1 <= ( others => '0' );
stringa2 <= ( others => '0' );
stringa3 <= ( others => '0' );
stringa4 <= ( others => '0' );
current_state <= idle;
case current_state is when idle => ; when primo => ; when secondo => ; when terzo => ; end case;
case current_state is when primo => if ( en = '1' ) then stringa2 <= stringa_in; current_state <= secondo ; end if ; end case ;
if ( current_state = secondo ) then x <= ( others => '0' ); end if;
entity key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0) ); end key_update;
architecture structural of key_update is begin end structural;
signal key_temp1: std_logic_vector(79 downto 0);
signal key_temp1_frac: std_logic_vector(3 downto 0);
component abox port (); end component
component abox port (data_in:  in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0) ); end component;
key_temp1 <= reg_key_in( 18 downto 0 ) & reg_key_in( 79 downto 19 );
SB : sbox port map ( data_in => key_temp1(79 downto 76), data_out => key_temp1_frac );
sbox_inst : sbox port map ();
reg_key_out( 79 downto 76 ) <= key_temp1_frac;
reg_key_out(19 downto 15) <= key_temp1(19 downto 15) xor round_counter;
reg_key_out <= key_temp1 and round_counter;
component add_round_key is port ( round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
signal cont: std_logic_vector(4 downto 0):= "00000";
type dataArrayType is array(0 to 31) of std_logic_vector(63 downto 0);
type x is array(0 to 15) of std_logic_vector(19 downto 0);
signal blocks: dataArrayType;
signal round_keys: dataArrayType;
type keyArrayType is array(0 to 31) of std_logic_vector(79 downto 0);
signal key_registers: keyArrayType;
blocks(0) <= plaintext;
x(4)
key_registers(0) <= user_key;
y( 10 )
round_keys(i) <= key_registers(i)(79 downto 16);
final_ark: add_round_key port map (round_keys(31),blocks(31),cyphertext);
entity present_top is port ( clock: in std_logic; rst: in std_logic; value_in: in std_logic_vector(15 downto 0); btn_plainText_in: in std_logic; btn_switch_display: in std_logic; catodi : out std_logic_vector (7 downto 0); anodi : out std_logic_vector (7 downto 0) ); end present_top;
component present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0) ); end component;
user_key: in std_logic_vector(79 downto 0);
clock_frequency_in : integer := 50000000;
clock_frequency_out : integer := 5000000;
value32_in : in  STD_LOGIC_VECTOR (31 downto 0);
anodes : out  STD_LOGIC_VECTOR (7 downto 0);
cathodes : out  STD_LOGIC_VECTOR (7 downto 0);
reset : in  STD_LOGIC;
component display_seven_segments is generic ( clock_frequency_in : integer := 50000000; clock_frequency_out : integer := 5000000); port ( clock : in STD_LOGIC; reset : in STD_LOGIC; value32_in : in STD_LOGIC_VECTOR (31 downto 0); enable : in STD_LOGIC_VECTOR (7 downto 0); dots : in STD_LOGIC_VECTOR (7 downto 0); anodes : out  STD_LOGIC_VECTOR (7 downto 0); cathodes : out STD_LOGIC_VECTOR (7 downto 0)); end component;
component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); end component;
clock_frequency_out : integer := 500
component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC ); end component;
clk_period: integer := 10;
btn_noise_time: integer := 10000000
signal clk_div: std_logic;
signal t_btn_plaintext , t_switchdisplay , t_btn_key : std_logic;
signal value_to_display: std_logic_vector(31 downto 0);
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ) ;
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ) ;
signal cyphertext64: std_logic_vector(63 downto 0):=(others=>'0');
signal mode : boolean := false ;
signal mode : boolean := false ;
divisore_frequenza: clock_divider port map(clock, rst, clk_div);
divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map(clock, rst, clk_div);
divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map () ;
debouncer_display_btn : button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_switch_display, t_switchDisplay);
debouncer_plaintext_btn: button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_plainText_in, t_btn_plainText);
input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64);
cypher: present_cypher port map (plaintext64, cyphertext64, x"00000000000000000000");
value_to_display <= cyphertext64(63 downto 32) when mode = false else cyphertext64(31 downto 0) when mode=true;
visualizzatore_sevenseg: display_seven_segments generic map(clock_frequency_in => 100000000, clock_frequency_out => 10000) port map (clock, rst, value_to_display, "11111111", "00000000", anodi, catodi);
architecture behavioral of counter is begin end behavioral ;
signal c: std_logic_vector(2 downto 0);
if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if;
count <= c
entity MEM is port ( clk : in STD_LOGIC; addr: in STD_LOGIC_VECTOR(2 downto 0); write : in STD_LOGIC; data_in : in STD_LOGIC_VECTOR (31 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end MEM;
data_in : in STD_LOGIC_VECTOR (31 downto 0);
type mem_type is array (0 to 7) of std_logic_vector(31 downto 0);
signal mem : mem_type;
mem(to_integer(unsigned(addr))) <= data_in;
if(write = '1') then mem(to_integer(unsigned(addr))) <= data_in; end if;
data_out <= mem(to_integer(unsigned(addr)));
entity rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end rom;
X"BBBBBBBB"
type rom_type is array (0 to 7) of std_logic_vector(31 downto 0);
signal rom : rom_type := (X"AAAAAAAA", X"BBBBBBBB", X"CCCCCCCC", X"DDDDDDDD", X"12345678", X"87654321", X"00112233", X"44556677");
entity sistemaA is port ( start : in STD_LOGIC; clkA : in STD_LOGIC; rst : in STD_LOGIC; ack : in STD_LOGIC; dato : out STD_LOGIC_VECTOR (31 downto 0); req : out STD_LOGIC); end sistemaA;
component UC_A is port ( clkA : in STD_LOGIC; rst : in STD_LOGIC; start: in STD_LOGIC; ack : in STD_LOGIC; count : in STD_LOGIC_VECTOR(2 downto 0); en : out STD_LOGIC; req : out STD_LOGIC); end component;
component rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end component;
component counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end component;
signal count_tmp: STD_LOGIC_VECTOR (2 downto 0);
signal en_tmp: STD_LOGIC;
counter_comp: counter port map(clkA, en_tmp, rst, count_tmp);
entity sistemaTOT is port ( clkA : in STD_LOGIC; clkB : in STD_LOGIC; rst : in STD_LOGIC; start : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR (31 downto 0)); end sistemaTOT;
signal count_tmp: STD_LOGIC_VECTOR (2 downto 0);
signal data_tmp: STD_LOGIC_VECTOR (31 downto 0);
signal en_tmp, req_tmp, ack_tmp, write_tmp: STD_LOGIC;
type stato is (IDLE, INVIA, ASPETTA, FINITO);
signal stato_corrente, stato_prossimo : stato := IDLE;
stato_mem: process(clkA) begin if rising_edge(clkA) then if( RST = '1') then stato_corrente <= IDLE; else stato_corrente <= stato_prossimo; end if; end if; end process;
stato_uscita: process(stato_corrente,start,ack)
case stato_corrente is when IDLE => if( start = '1' ) then stato_prossimo <= INVIA; else stato_prossimo <= IDLE; end if; end case;
case stato_corrente is when INVIA => en <='0'; req <= '1'; if( ack = '1') then stato_prossimo <= ASPETTA; else stato_prossimo <= INVIA ; end if ; end case ;
case stato_corrente is when ASPETTA => req <='0'; if (ack = '0') then stato_prossimo <= FINITO; else stato_prossimo <= ASPETTA; end if;
signal clkB     : std_logic;
signal rst      : std_logic;
signal start    : std_logic;
constant TbPeriodA : time := 13 ns;
signal TbClockA : std_logic := '0';
constant TbPeriodB : time := 40 ns;
signal TbClockB : std_logic := '0';
signal TbSimEnded : std_logic := '0';
dut : sistemaTOT port map (clkA => clkA, clkB => clkB, rst => rst, start => start, data_out => data_out);
clk_process : process begin TbClockA <= '0'; wait for TbPeriodA/2; TbClockA <= '1'; wait for TbPeriodA/2; end process;
TbClockB <= not TbClockB after TbPeriodB/2
TbClockB <= not TbClockB after TbPeriodB/2 when TbSimEnded /= '1' else '0';
wait for 100 ns; rst <= '0';
wait for 10 ns;
wait for 10 ns; start <= '1';
wait for 10 ns; start <= '0';
wait for 100 ns;
uut: present_cypher port map(plaintext, cyphertext, user_key);
stimuli: process begin wait for 100 ns; plaintext <= x"0000000000000000"; user_key <= x"00000000000000000000"; wait for 30 ns; plaintext <= x"5579c1387b228445"; end process;
wait for 100 ns; plaintext <= x"0000000000000000"; user_key <= x"00000000000000000000";
wait for 30 ns; plaintext <= x"5579c1387b228445"; user_key <= x"00000000000000000000";
y <= a0 when s = '0' else a1 when s = '1' else '-';
y <= a0 when s = '0' else a1 when s = '1' else '-';
with s select y <= 	a0 when '0', a1 when '1', '-' when others;
with f select z <= 	b0 when '0', a1 when '1', '-' when others;
with ciao select y <= a0 when '0', a1 when '1', '-' when others;
with ciao select y <= a0 when '0', a1 when '1', '-' when others;
y <= ((a0 and (NOT s)) OR (a1 and s));
signal control : STD_LOGIC := 'U';
signal output : STD_LOGIC := 'U';
signal input : STD_LOGIC_VECTOR (0 to 1) := (others => 'U');
utt : entity work.mux_2_1(dataflow_v2) port map( a0 => input(0), a1 => input(1), s => control, y => output );
assert output = '0' report "errore0" severity failure;
stim_proc : process begin wait for 100 ns; input <= "01"; wait for 10 ns; assert output = '0' report "errore0" severity failure;
entity mux2_1_tb is port () end mux2_1_tb;
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1;
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1;
signal u0 : STD_LOGIC := '0';
signal u1 : STD_LOGIC := '0';
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component;
mux0: mux_2_1 port map(a0 => b0, a1 => b1, s => s0, y => u0);
mux1: mux_2_1 port map(a0 => b2, a1 => b3, s => s0, y => u1);
mux2: mux_2_1 port map(a0 => u0, a1 => u1, s => s1, y => y0);
component mux_4_1 port (b0 : in STD_LOGIC; b1 : in STD_LOGIC; b2 : in STD_LOGIC; b3 : in STD_LOGIC; s0 : in STD_LOGIC; s1 : in STD_LOGIC; y0 : out STD_LOGIC); end component;
signal input : STD_LOGIC_VECTOR (0 to 3) := (others => '0');
signal control : STD_LOGIC_VECTOR (1 downto 0) := (others => '0');
signal output : STD_LOGIC := '0';
uut: mux_4_1 port map(b0 => input(0), b1 => input(1), b2 => input(2), b3 => input(3), s0 => control(0), s1 => control(1), y0 => output );
stim_proc: process begin wait for 100 ns; input <= "1010"; control <= "00"; wait for 10 ns; assert output = '0' report "errore" severity failure; wait; end process;
assert output = '0' report "errore" severity failure;
entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;
entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;
y <= "1000" when a="00" else "0100" when a="01" else "0010" when a="10" else "0001" when a="11" else "----";
with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others;
case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case;
case (a) is when "00" => ; when "01" => ; when "10" => ; when "11" => ; when others => ; end case;
y <= "----";
component decoder_2_4 port( a : in STD_LOGIC_VECTOR(1 downto 0); y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
signal a: STD_LOGIC_VECTOR(1 downto 0);
uut: decoder_2_4 port map ( a => a, y => y );
stimulus: process begin wait for 100 ns; wait for 10 ns; a<="00"; wait for 10 ns; wait; end process;
entity Riconoscitore_Mealy is port( i: in std_logic; rst, clk: in std_logic; y: out std_logic ); end Riconoscitore_Mealy;
type stato is (S0, S1, S2, S3, S4);
signal stato_corrente : stato := S0;
stato_uscita_mem: process(clk) begin if rising_edge(clk) then if(rst = '1') then stato_corrente <= S0; Y <= '0'; end if; end process;
case stato_corrente is when S0 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S1; end if; end case ;
case stato_corrente is when S1 => if( i = '0' ) then stato_corrente <= S2; Y <= '0'; else stato_corrente <= S1; end if; end case ;
case stato_corrente is when S2 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S0; end if; end case ;
when others => stato_corrente <= S0; Y <= '0'; end case ;
type stato is (S0, S1, S2);
mem: process (CLK) begin if( rising_edge( CLK ) ) then if( RST = '1') then stato_corrente <= S0; else stato_corrente <= stato_prossimo; end if; end if; end process;
if( rising_edge( CLK ) ) then end if;
mem: process (CLK) begin if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if; end process;
if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if;
component Riconoscitore_Mealy port( i : IN std_logic; CLK, RST : IN std_logic; Y : OUT std_logic); end component;
signal i : std_logic := '0';
signal CLK : std_logic := '0';
signal RST : std_logic := '0';
signal Y : std_logic;
uut: Riconoscitore_Mealy port map(i => i, CLK => CLK, RST => RST, Y => Y);
clk_process : process begin CLK <= '0'; wait for CLK_period/2; CLK <= '1'; wait for CLK_period/2; end process;
wait for 100 ns;
stim_proc: process begin wait for 100 ns; i<='0'; wait for 10 ns; i<='0'; wait for 10 ns; i<='1';
entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
entity shift_reg is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi;
signal tmp: std_logic_vector(3 downto 0);
if (rising_edge(CLK)) then tmp(0) <= '0'; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if;
signal clk_tb : std_logic;
signal output : std_logic;
signal rst : std_logic;
constant clk_period : time := 20 ns;
clk_process : process begin clk_tb <= '0'; wait for clk_period/2; clk_tb <= '1'; wait for clk_period/2; end process;
uut : shift_register port map (CLK => clk_tb, RST => rst, SI => input, SO => output);
stimuli : process begin rst <= '1'; wait for 100ns; rst <='0'; input <= '1'; wait for 100ns; input <= '0'; wait for 100ns; input <= '1'; wait; end process;
with X select Y <= "0000" when "0000000001", "0001" when "0000000010", "0010" when "0000000100", "0011" when "0000001000", "0100" when "0000010000", "0101" when "0000100000", "0110" when "0001000000", "0111" when "0010000000", "1000" when "0100000000", "1001" when "1000000000", "1111" when others;
constant zero : std_logic_vector(6 downto 0) := "1000000";
constant one : std_logic_vector(6 downto 0) := "1111001";
constant two : std_logic_vector(6 downto 0) := "0100100";
constant three : std_logic_vector(6 downto 0) := "0110000";
constant four : std_logic_vector(6 downto 0) := "0011001";
constant five : std_logic_vector(6 downto 0) := "0010010";
constant six : std_logic_vector(6 downto 0) := "0000010";
constant seven : std_logic_vector(6 downto 0) := "1111000";
constant eight : std_logic_vector(6 downto 0) := "0000000";
constant nine : std_logic_vector(6 downto 0) := "0010000";
constant a : std_logic_vector(6 downto 0) := "0001000";
constant b : std_logic_vector(6 downto 0) := "0000011";
constant c : std_logic_vector(6 downto 0) := "1000110";
constant e : std_logic_vector(6 downto 0) := "0000110";
constant f : std_logic_vector(6 downto 0) := "0001110";
signal cathodes : std_logic_vector(6 downto 0);
case value is when "0000" => cathodes <= zero; when "0001" => cathodes <= one; when "0010" => cathodes <= two; when "0011" => cathodes <= three; when "0100" => cathodes <= four; when "0101" => cathodes <= five; when "0110" => cathodes <= six; when "0111" => cathodes <= seven; when "1000" => cathodes <= eight; when "1001" => cathodes <= nine; when "1010" => cathodes <= a; when "1011" => cathodes <= b; when "1100" => cathodes <= c; when "1101" => cathodes <= d; when "1110" => cathodes <= e; when "1111" => cathodes <= f; when others => cathodes <= (others => '0'); end case;
cathodes_dot <= (not dot)&cathodes;
entity Encoder_onBoard is port ( switch : in STD_LOGIC_VECTOR(9 downto 0); led : out STD_LOGIC_VECTOR(3 downto 0); catodi : out STD_LOGIC_VECTOR(7 downto 0); anodi : out STD_LOGIC_VECTOR(7 downto 0)); end Encoder_onBoard;
component Encoder port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
component cathodes_manager port(value : in std_logic_vector(3 downto 0); dot : in std_logic; cathodes_dot : out std_logic_vector(7 downto 0)); end component;
signal ytemp : std_logic_vector (3 downto 0);
signal dot : std_logic;
anodi <= (others=>'0');
signal c : std_logic_vector (2 downto 0) := (others => '0');
counter <= c;
if(rising_edge(clock)) then if reset = '1' then c <= (others => '0'); elsif enable = '1' then c <= std_logic_vector(unsigned(c) + 1); end if; end if;
entity clock_filter is generic(CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500); Port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC); end clock_filter;
signal clockfx : std_logic := '0';
constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1;
clock_out <= clockfx;
if rising_edge(clock_in) then end if ;
variable counter : integer range 0 to count_max_value := 0;
variable index : integer range -10 to 10 := -5;
variable count : integer range 1 to 100 := 50;
variable value : integer range -1000 to 1000 := 0;
variable limit : integer range 0 to 255 := 255;
variable speed : integer range 50 to 200 := 100;
variable temperature : integer range -20 to 50 := 25;
variable power : integer range 0 to 5000 := 2000;
variable delay : integer range 0 to 100 := 10;
variable size : integer range 10 to 10000 := 1000;
if rising_edge(clock_in) then if( reset = '1') then counter := 0; clockfx <= '0'; counter := counter + 1; end if; end if;
if rising_edge(clock) then if( reset_sig = '1') then counter_var := 10; enable <= '1'; counter_var := counter_var + 2; end if; end if;
if rising_edge(clk_in) then if( clear_sig = '1') then idx := 5; stop_sig <= '0'; idx := idx + 3; end if; end if;
if rising_edge(clock_in) then if( rst_n = '1') then value := -100; enable_sig <= '1'; value := value - 10; end if; end if;
if rising_edge(clk) then if( clear_sig = '1') then limit := 255; start_signal <= '1'; limit := limit + 20; end if; end if;
if rising_edge(clock_in) then if( rst_n = '1') then num := 1000; enable_sig <= '0'; num := num - 100; end if; end if;
if rising_edge(clk) then if( reset_sig = '1') then value := 0; enable_sig <= '1'; value := value + 2; end if; end if;
entity ROM_selector_onboard is port (clock_in : in STD_LOGIC; reset_in : in STD_LOGIC; addr_strobe_in : in STD_LOGIC; anodes_out : out STD_LOGIC_VECTOR(7 downto 0); cathodes_out : out STD_LOGIC_VECTOR(7 downto 0)); end ROM_selector_onboard;
component ButtonDebouncer generic (CLK_period: integer := 10; btn_noise_time: integer := 10000000) port (RST : in STD_LOGIC; CLK : in STD_LOGIC; BTN : in STD_LOGIC; CLEARED_BTN : out STD_LOGIC); end component;
component ROM port (RST: in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end component;
component display_seven_segments generic (CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500) port (CLK : IN std_logic; RST : IN std_logic; VALUE : IN std_logic_vector(31 downto 0); ENABLE : IN std_logic_vector(7 downto 0); DOTS : IN std_logic_vector(7 downto 0); ANODES : OUT std_logic_vector(7 downto 0); CATHODES : OUT std_logic_vector(7 downto 0)); end component;
signal reset_n, read_strobe : std_logic;
signal value_temp : std_logic_vector(31 downto 0);
counter: counter_mod8 port map(clock=> clock_in, reset => reset_n, enable => read_strobe, counter => address_in);
mem: ROM port map (rst => reset_n, addr => address_in, data => value_temp);
seven_segment_array: display_seven_segments generic map(CLKIN_freq => 100000000, CLKOUT_freq => 500) port map(CLK => clock_in, RST => reset_n, value => value_temp, enable => "11111111", dots => "00000000", anodes => anodes_out, cathodes => cathodes_out);
entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;
entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;
type rom_type is array (0 to 7) of std_logic_vector(31 downto 0);
signal ROM : rom_type := (X"AAAAAAAA", X"BBBBBBBB", X"CCCCCCCC", X"DDDDDDDD", X"12345678", X"87654321", X"00112233", X"44556677");
type stato is (NOT_PRESSED, CHK_PRESSED, PRESSED, CHK_NOT_PRESSED);
signal BTN_state : stato := NOT_PRESSED;
constant max_count : integer := btn_noise_time/CLK_period;
if rising_edge(CLK) then if RST = '1' then BTN_state <= NOT_PRESSED; CLEARED_BTN <= '0'; end if; end if;
variable count: integer := 0;
if(index /= limit + 1) then end if;
if(data >= threshold) then end if;
if(sum /= difference) then end if;
count := count + 1;
case BTN_state is when NOT_PRESSED => ; when CHK_PRESSED => ; when PRESSED => ; when CHK_NOT_PRESSED => ; when others => ; end case ;
case status is when IDLE => ; when ACTIVE => ; when ERROR => ; when COMPLETED => ; when others => ; end case ;
case mode is when AUTO => ; when MANUAL => ; when SEMI_AUTO => ; when OFF => ; when others => ; end case ;
case state is when INIT => ; when PROCESSING => ; when WAITING => ; when FINISHED => ; when others => ; end case ;
case operation is when ADD => ; when SUBTRACT => ; when MULTIPLY => ; when DIVIDE => ; when others => ; end case ;
case status_code is when OK => ; when WARNING => ; when ERROR_CODE => ; when CRITICAL => ; when others => ; end case ;
case mode_code is when SAFE_MODE => ; when NORMAL_MODE => ; when SLEEP_MODE => ; when EMERGENCY_MODE => ; when others => ; end case ;
case state_code is when STARTUP => ; when RUNNING => ; when HALTED => ; when SHUTDOWN => ; when others => ; end case ;
case flag_code is when FLAG_1 => ; when FLAG_2 => ; when FLAG_3 => ; when FLAG_4 => ; when others => ; end case ;
count := 0;
CLEARED_BTN <= '1';
entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;
FF_D: process(clock) begin if(clock'event and clock='1') then if(reset='1') then y <= '0'; else y <= d; end if; end if; end process;
FF_D: process(clock) begin if(clock'event and clock='1') then if(reset='1') then y <= '0'; else y <= d; end if; end if; end process;
entity ripple_carry is port( X, Y: in std_logic_vector(7 downto 0); c_in: in std_logic; c_out: out std_logic; Z: out std_logic_vector(7 downto 0)); end ripple_carry;
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
s <= x xor y
result <= input_a nand input_b;
output <= operand1 and operand2;
out_signal <= data1 nor data2;
result_sig <= input_x xor input_y;
out_data <= dividend or divisor;
s_result <= data_in1 nand data_in2;
output_data <= val_a or val_b;
entity full_adder is port ( x, y, z : in std_logic; s, c : out std_logic); end full_adder; architecture struct_dataflow of full_adder is component half_adder port (x, y : in std_logic; s, c: out std_logic); end component; signal hs, hc, tc : std_logic; begin HA1: half_adder port map(x, y, hs, hc); HA2: half_adder port map(hs, z, s, tc); c <= tc or hc; end struct_dataflow;
architecture mul_arch of mul8x8 is begin p <= x * y; end mul_arch;
entity molt_rob is port( clock, reset, start: in std_logic; X, Y: in std_logic_vector(7 downto 0); P: out std_logic_vector(15 downto 0); stop_cu: out std_logic); end molt_rob;
component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;
component unita_operativa is port(X, Y: in std_logic_vector(7 downto 0); clock, reset: in std_logic; loadAQ, shift, loadM, sub, selM, selAQ, selF, count_in: in std_logic; count: out std_logic_vector(2 downto 0); P: out std_logic_vector(15 downto 0)); end component;
signal tempq0, temp_selM, temp_selAQ, temp_clock, temp_sub,temp_loadAQ: std_logic;
signal temp_count: std_logic_vector(2 downto 0);
signal temp_p: std_logic_vector(15 downto 0);
signal fine_conteggio: std_logic;
signal temp_shift, temp_fshift: std_logic;
signal temp_stop_cu: std_logic;
signal temp_reset_in: std_logic;
signal temp_selF: std_logic;
UC: unita_controllo port map (tempq0, clock, reset, start, temp_count, temp_loadM, temp_count_in, temp_loadAQ, temp_shift, temp_selM, temp_selAQ, temp_selF, temp_sub, temp_stop_cu);
UO: unita_operativa port map (X, Y, clock, reset, temp_loadAQ, temp_shift, temp_loadM, temp_sub, temp_selM, temp_selAQ, temp_selF, temp_count_in, temp_count, temp_p);
tempq0 <= temp_p(0);
signal_1 <= signal_2(0);
signal_5 <= signal_6(0);
signal_12 <= signal_11(4);
signal_13 <= signal_14(2);
signal_16 <= signal_15(1);
signal_17 <= signal_18(3);
S <= (OP_A xor OP_B) xor CIN;
entity RCA_Nbit is generic (N: natural range 0 to 32 := 8); port(OP_A_RCA, OP_B_RCA: in std_logic_vector(N-1 downto 0); CIN_RCA: in std_logic; S_RCA: out std_logic_vector(N-1 downto 0); COUT_RCA, OV: out std_logic); end RCA_Nbit;
signal cout_int: std_logic_vector(N-1 downto 0);
S_RCA <= s_int;
COUT_RCA <= cout_int(N-1);
FA_0: myFA port map(OP_A => OP_A_RCA(0), OP_B => OP_B_RCA(0), CIN => CIN_RCA, S => s_int(0), COUT => cout_int(0));
entity deglitcher is port (clk : in std_logic; rst_n : in std_logic; d : in std_logic; q : out std_logic); end entity deglitcher;
q : out std_logic
constant n : integer := 1000;
signal d_nxt : std_logic;
signal d_reg : std_logic;
signal q_nxt : std_logic;
signal q_reg : std_logic;
signal count_nxt : integer range 0 to n - 1;
signal count_reg : integer range 0 to n - 1;
if ((d xor d_reg) = '1') then ; end if;
count_nxt <= 0;
clk_i : in std_logic;
cs_i : in std_logic;
done_i : in std_logic;
data_0_o : out std_logic_vector(15 downto 0);
data_2_o : out std_logic_vector(15 downto 0);
data_3_o : out std_logic_vector(15 downto 0);
data_5_o : out std_logic_vector(15 downto 0);
ldac_i : in std_logic;
sda_i : in std_logic
constant DOUT_LEN : integer := 16;
constant DATA_LEN : integer := 24;
constant CLK_DIV : integer := 100;
signal i_sck_re_tk : std_logic;
signal i_sck_fe_tk : std_logic;
signal i_cs_re_tk : std_logic;
signal i_cs_fe_tk : std_logic;
signal i_ldac_cpy : std_logic;
signal i_ldac_re_tk : std_logic;
signal i_ldac_fe_tk : std_logic;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0);
i_sr_data <= (others => '0');
i_data_0 <= (others => '0');
i_data_2 <= (others => '0');
i_data_4 <= (others => '0');
i_data_5 <= (others => '0');
if i_sr_data(23 downto 16) = x"08" or i_sr_data(23 downto 16) = x"09"or i_sr_data(23 downto 16) = x"0A" or i_sr_data(23 downto 16) = x"0B" or i_sr_data(23 downto 16) = x"0C" then ; end if ;
if i_sr_data(23 downto 16) = x"08" then ; end if;
if foo(22 downto 15) = x"1A" then ; end if;
if bar(21 downto 14) = x"2B" then ; end if;
if baz(20 downto 13) = x"3C" then ; end if;
if abc(18 downto 11) = x"5E" then ; end if;
if ghi(16 downto 9) = x"77" then ; end if;
if jkl(15 downto 8) = x"88" then ; end if;
if mno(14 downto 7) = x"99" then ;end if;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_1_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_data_5_out : std_logic_vector(DOUT_LEN - 1 downto 0);
i_data_0 <= i_data_0(i_data_0'length - 2 downto 0) & i_bit_counter;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 2 downto 0) & i_ldac_cpy;
i_data_4 <= i_data_4(i_data_4'length - 2 downto 0) & i_sr_data;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 2 downto 0) & i_data_0;
i_sr_data <= i_sr_data(i_sr_data'length - 2 downto 0) & i_data_1_out;
i_data_0_out <= i_data_0_out(i_data_0_out'length - 2 downto 0) & i_data_2_out;
i_data_0 <= i_data_0(i_data_0'length - 3 downto 0) & i_bit_counter;
i_data_1_out <= i_data_1_out(i_data_1_out'length - 3 downto 0) & i_sck_cpy;
i_data_2 <= i_data_2(i_data_2'length - 3 downto 0) & i_cs_fe_tk;
i_data_4 <= i_data_4(i_data_4'length - 3 downto 0) & i_sr_data;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 3 downto 0) & i_data_0;
i_data_0 <= i_data_0(i_data_0'length - 4 downto 0) & i_bit_counter;
i_data_2 <= i_data_2(i_data_2'length - 4 downto 0) & i_cs_fe_tk;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 4 downto 0) & i_ldac_cpy;
i_data_4 <= i_data_4(i_data_4'length - 4 downto 0) & i_sr_data;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 4 downto 0) & i_data_0;
i_data_0_out <= i_data_0_out(i_data_0_out'length - 4 downto 0) & i_data_2_out;
i_data_1 <= i_data_1(i_data_1'length - 4 downto 0) & i_data_3_out;
data_0_o <= i_data_0_out when rst_n_i = '1' else (others => '0');
data_1_o <= i_data_1_out when rst_n_i = '1' else (others => '0');
data_3_o <= i_data_3_out when rst_n_i = '1' else (others => '0');
data_4_o <= i_data_4_out when rst_n_i = '1' else (others => '0');
data_5_o <= i_data_5_out when rst_n_i = '1' else (others => '0');
entity tb_dac is end tb_dac;
signal i_start_counter : integer range 0 to 400;
signal t_stb_counter : integer range 0 to 108;
signal t_clk_en : std_logic;
signal t_clk : std_logic;
signal t_scl : std_logic;
signal t_dac_val_0 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_1 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_2 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_3 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_4 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_dac_val_5 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal t_ldac : std_logic;
t_rst_n <= '0', '1' after CLK_HPER * 10;
t_clk <= '1' after CLK_HPER when t_clk = '0' else '0' after CLK_HPER;
t_clk_en <= '1';
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;
use std.textio.all;
library work;
use work.tb_AESA_if_pkg.all;
start_proc : process (t_clk) begin ; end process start_proc;
if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;
if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;
if i_start_counter = STB_DLY - 1 then t_stb <= '1'; end if;
clk_i => t_clk
data_0_o => t_dac_val_0
data_3_o => t_dac_val_3
data_4_o => t_dac_val_4
data_5_o => t_dac_val_5
ldac_i => t_ldac
sda_i => t_sda
clk_i => t_clk
rst_n_i => t_rst_n
clk_en_i => t_clk_en
start_i => t_start
done_o => t_done
ldac_o => t_ldac
cs_o => t_cs
clock_multiplier : integer := 5000000
clk : in std_logic;
rst_n : in std_logic;
enable : in std_logic;
signal tick_o_nxt : std_logic;
signal tick_o_reg : std_logic;
signal reg_count_reg : integer range 0 to clock_multiplier - 1;
if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0;
if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0;
tick_o_reg <= tick_o_nxt;
reg_count_reg <= reg_count_nxt;
expander : process (clk, rst_n, reg_count_reg, enable)
tick_o_nxt <= '0';
if enable = '1' then if reg_count_reg = clock_multiplier - 1 then tick_o_nxt <= '1'; reg_count_nxt <= 0;
if enable = '1' then if reg_count_reg = clock_multiplier - 1 then tick_o_nxt <= '1'; reg_count_nxt <= 0;
reg_count_nxt <= 0;
tick_o <= tick_o_reg;
constant unsaccoditempo : time := 550 ns;
constant t_clock_multiplier : integer := 50;
signal clk_t : std_logic := '0';
signal rst_n : std_logic := '1';
signal run : boolean := TRUE;
signal t_clk : std_logic;
signal t_tick_o : std_logic;
component TimeExpander generic (clock_multiplier : integer := 10000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end component TimeExpander;
clock_multiplier : integer := 10000000
use grlib.devices.all;
use techmap.gencomp.all;
use techmap.allclkgen.all;
library gaisler;
component GPIO is generic (BitWidth: integer); port ( IO_sel: in std_logic; IO: inout std_logic_vector (BitWidth-1 downto 0); WrtData: in std_logic_vector (BitWidth-1 downto 0); RdData: out std_logic_vector (BitWidth-1 downto 0)); end component;
component ALU is generic (BitWidth: integer); port ( A: in std_logic_vector (BitWidth-1 downto 0); B: in std_logic_vector (BitWidth-1 downto 0); Command: in std_logic_vector (3 downto 0); Cflag_in: in std_logic; Cflag_out: out std_logic; Result: out std_logic_vector (BitWidth-1 downto 0)); end component;
entity up_down_counter is generic ( WIDTH: positive := 8); port ( clk_en_p: in std_logic; up_down_p: in std_logic; value_p: out std_logic_vector(WIDTH - 1 downto 0); reset: in std_logic; clk: in std_logic); end up_down_counter;
component modn is generic( n:integer := 4 ); port( clk: in std_logic; inc: in std_logic; enable: in std_logic; reset: in std_logic; overflow: out std_logic; output: out std_logic_vector(f_log2(n)-1 downto 0)); end component;
component pulser is generic( delay:integer := 500000 ); port( clk: in std_logic; enable: in std_logic; output: out std_logic ); end component;
component PicoCPU is port( rst: in std_logic; clk: in std_logic; FlagOut: out std_logic_vector ( 3 downto 0); IO: inout std_logic_vector (CPU_Bitwidth-1 downto 0); output: out std_logic_vector ( CPU_Bitwidth-1 downto 0)); end component;
component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component;
component system_inverter_0_0 is port ( x : in STD_LOGIC; x_not : out STD_LOGIC); end component;
component system_util_vector_logic_0_0 is port ( Op1 : in STD_LOGIC_VECTOR ( 0 to 0 ); Op2 : in STD_LOGIC_VECTOR ( 0 to 0 ); Res : out STD_LOGIC_VECTOR ( 0 to 0 )); end component;
rotl: process(codoprotl, portArotl) begin if(codoprotl = "1101") then outrotl(0) <= portArotl(7); outrotl(7 downto 1) <= portArotl(6 downto 0); outFlagrotl <= '1'; else outrotl <= (others => 'Z'); outFlagrotl <= 'Z'; end if; end process rotl;
PRIORITY_REG_PROCESS:process (Clk, Rst, Priorreg_wrce, Dpen, Shift, Bus2ip_data, Master_id_in, master_id) begin if Clk'event and Clk = '1' then if Rst = RESET_ACTIVE then master_id <= C_RESET_VALUE; elsif Priorreg_wrce = '1' then master_id <= Bus2ip_data(BIT_INDEX to C_OPBDATA_WIDTH-1); elsif (Dpen = '1' and Shift = '1') then master_id <= Master_id_in; else master_id <= master_id; end if; end if; end process;
sync_carry: process (clk, reset) begin if reset = '1' then carry <= '0'; elsif rising_edge(clk) then carry <= carry_nxt; end if; end process;
process(control, data_in_array) begin case (control) is when "00" => data_out <= data_in_array(0); when "01" => data_out <= data_in_array(1); when "10" => data_out <= data_in_array(2); when "11" => data_out <= data_in_array(3); when others => data_out <= "0000"; end case; end process;
clk200p <= not clk200p after 2.5 ns;
data <= buskeep(data) after 5 ns;
clk <= not clk after ct * 1 ns;
stimulus : input <= X"00000000", X"00000008" after 10 ns, X"00000010" after 20 ns, X"00000018" after 30 ns, X"FFFFFFF8" after 40 ns, X"FFFFFFF0" after 50 ns, X"FFFFFF00" after 60 ns;
sys_rst_in <= '0', '1' after 200 ns;
TYPE hex_digit IS ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f');
TYPE direction is (LITTLE_ENDIAN, BIG_ENDIAN);
TYPE hex_number IS array (POSITIVE range <>) OF hex_digit;
TYPE hexstdlogic IS ARRAY (hex_digit'LOW TO hex_digit'HIGH) of std_logic_vector(3 DOWNTO 0);
TYPE stdlogic_boolean_table is array(std_ulogic, std_ulogic) of boolean;
if ((dci.eenaddr or dci.enaddr) = '1') or (r.dstate /= idle) or ((dsu = 1) and (dci.dsuen = '1')) or (r.flush = '1') or (is_fpga(memtech) = 1) then enable := (others => '1'); else enable := (others => '0'); end if;
if DSETS > 1 then if conv_integer(r.rndcnt) = (DSETS - 1) then v.rndcnt := (others => '0'); else v.rndcnt := r.rndcnt + 1; end if; end if;
if gls_reset = '1' then write_ack <= '0'; elsif rising_edge(gls_clk) then if ((wbs_strobe and wbs_write and wbs_cycle) = '1') then write_ack <= '1'; else write_ack <= '0'; end if; end if;
if (udbus/=X"0D" and udbus/=X"0A") then write(L,std_to_char(udbus)); end if;
if (vcount<=494 and vcount>=493) then VSync <= '0'; else VSync <= '1'; end if;
i.cmd_byte_addr <= r.haddr(29 downto 2) & "00";
vcc <= (others => '1');
memi.edac <= gpioo.val(2);
memi.bwidth <= gpioo.val(1 downto 0);
CPU_Bitwidth := CPU_Bitwidth+45;
CPU_Bitwidth := CPU_Bitwidth-78;
component osctimer generic(TIMER_DIV : string); port( DYNOSCDIS : in std_logic; TIMERRES : in std_logic; OSCOUT : out std_logic; TIMEROUT : out std_logic); end component;
component counter is generic (constant cnt_max : integer := 50000000); port ( iClk: in std_logic; iReset: in std_logic; is_forward: in std_logic; is_enabled: in std_logic; output_data: out std_logic_vector(7 downto 0)); end component;
component input_handler is generic (COUNT_MAX: integer := 500000); port (row_sel: in std_logic_vector(4 downto 0); clk: in std_logic; reset: in std_logic; key_out: out std_logic_vector(7 downto 0); col_sel: out std_logic_vector(3 downto 0); keypress_out: out std_logic); end component;
clk2xgen: if (clk2xen /= 0) generate clkena(1 downto 0) <= "11"; end generate;
c0: if (PCISYSCLK = 0) or (PCIEN = 0) generate clkint <= clkin; end generate c0;
if sela = '1' then q <= a; elsif selb = '1' then q <= b; else q <= c; end if;
if rising_edge(clk) then if clr = '0' then q <= '0'; else q <= d; end if;
gxa: IF (unsigned = 0) GENERATE cc(mantissa+10 DOWNTO mantissa+5) <= aa(32) & aa(32) & aa(32) & aa(32) & aa(32); END GENERATE;
gen_num:FOR N IN LOOP_COUNT-1 DOWNTO 0 GENERATE rd_gen_inst2:fifo_rng GENERIC MAP(WIDTH => 8, SEED => TB_SEED+N) PORT MAP(CLK => RD_CLK, RESET => RESET, RANDOM_NUM => rand_num(8*(N+1)-1 downto 8*N), ENABLE => pr_r_en ); END GENERATE;
TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);
TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic;
type data_t is array(0 to C_NUM_SENSORS - 1) of std_logic_vector (C_COUNTER_WIDTH - 1 downto 0);
type hsv_function is array ( 0 to 255) of integer;
address(0) <= '0';
noise(15) <= raw_lfsr(1);
outrotl(7 downto 1) <= portArotl(6 downto 0);
data_out <= data_in_array(0);
dbg_ila_probe0(31) <= cmd_fifo_empty;
case mcmmo.data(PT_ET_U downto PT_ET_D) is when ET_INV => inv := '1'; when ET_PTD => ptd := '1'; goon := '1'; when ET_PTE => pte := '1'; found := '1'; when ET_RVD => rvd := '1'; null; when others => null; end case;
case r.haddr(1 downto 0) is when "00" => wmask := "1101"; when "01" => wmask := "1110"; when "10" => wmask := "0111"; when others => wmask := "1011"; end case;
case ra.raddr(2 downto 2) is when "0" => rdata := r.hrdata(127 downto 0); when others => rdata := r.hrdata(255 downto 128); end case;
case w is when 'U' => w := 'X'; when 'X' => null; when '0' => w := w2; when '+' | '-' => if w2 /= '0' then w := 'X'; end if; end case;
CASE s IS WHEN '0' => RETURN ('0'); WHEN '1' => RETURN ('1'); WHEN OTHERS => RETURN ('0'); END CASE;
xenable <= enable when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');
buffer_Full <= '1' when (addr_i = "1111") else '0';
architecture rtl of clkmux_xilinx is component BUFGMUX port (O : out std_logic; I0, I1, S : in std_logic); end component; begin buf : bufgmux port map(S => sel, I0 => i0, I1 => i1, O => o); end architecture;
clk <= '0'; wait for clk_period; clk <= not clk; wait for clk_period;
wait until s0_arready = '1';
wait until rising_edge(clk);
wait until s0_awready = '1' and s0_wready = '1';
wait until clock='1';
constant REVISION : integer := 0;
constant MAX_CNT : natural := 32;
constant LATCH_CNT : boolean := clatch /= 0;
constant mcnt_none : mcnt_type := ('0', '0', zero32);
constant RES : reg_type := ('0', '0', '0', '0');
rst0 : rstgen port map (rst, clkm, cgo.clklock, rstn, rstraw);
u2: component ycbcr_to_rgb port map(clk => clk, y => y, cb => cb, cr => cr, red => red, green => green, blue => blue);
BSCAN_SPARTAN3_inst : BSCAN_SPARTAN3 port map ( CAPTURE => CAPTURE, DRCK1 => DRCK1, DRCK2 => open, RESET => open, SEL1 => SEL1, SEL2 => open, SHIFT => SHIFT, TDI => TDI, UPDATE => UPDATE, TDO1 => TDO1, TDO2 => open );
clkin1_bufg : BUFG port map (O => clk_100MHz_clk_video, I => clk_100MHz);
variable acc, acc1, acc2 : std_logic_vector(48 downto 0);
variable zero, rsigned, rmac : std_logic;
variable v : mul_regtype;
assert sim_done_i = '0' report "Simulation Complete for:" & AXI_CHANNEL severity note;
addr := to_integer(unsigned(ADR_I(10 downto 0)));
font_byte <= ram_font(to_integer(unsigned(font_address)));
initaddr := std_logic_vector((unsigned(initaddr) + 1));
with iThisRegAddr select iDataOutput <= iThisR0 when "00", iThisR1 when "01", iThisR2 when "10", sw when others;
with AC_I.use_logic select alu_logic_shift <= alu_logic when "01", not alu_logic when "11", alu_shift when others;
with GPIO_enable select GPIO_inout <= GPIO_write when '1', 'Z' when others;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity counter is generic (N : natural := 8); port ( clock : in std_logic; reset : in std_logic; enable : in std_logic; q : out std_logic_vector(N-1 downto 0) ); end entity counter; architecture behavioral of counter is begin process (clock, reset, enable) variable count : natural range 0 to N-1 := 0; begin if (reset = '1') then count := 0; elsif (rising_edge(clock) and enable = '1') then count := count + 1; end if ; q <= std_logic_vector(to_unsigned(count, N)); end process ; end architecture behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Register is Generic( N : integer := 8 ); Port( Clock : in std_logic; Reset : in std_logic; Enable : in std_logic; D : in std_logic_vector(N-1 downto 0); Q : out std_logic_vector(N-1 downto 0) ); end Register; architecture Behavioral of Register is begin process (Clock, Reset, Enable) variable reg : std_logic_vector(N-1 downto 0); begin if (Reset = '1') then reg := (others => '0'); elsif (rising_edge(Clock)) and (Enable = '1') then reg := D; end if ; Q <= reg; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity ShiftRegister is Generic( N : integer := 8 ); Port( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Serial_In : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Shift_Direction : in STD_LOGIC; Parallel_Out : out STD_LOGIC_VECTOR(N-1 downto 0) ); end ShiftRegister; architecture Behavioral of ShiftRegister is signal shift_register : STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clock, Reset) variable i : integer range 0 to N-1; begin if (Reset = '1') then shift_register <= (others => '0'); elsif (rising_edge(Clock)) then if (Shift_Enable = '1') then if (Shift_Direction = '1') then shift_register(i) <= Serial_In; i := i + 1; if (i = N-1) then i := 0; end if ; else shift_register(N-1 downto i+1) <= shift_register(i downto 0); shift_register(i) <= Serial_In; i := i + 1; if (i = N-1) then i := 0; end if ; end if ; end if ; end if ; end process ; Parallel_Out <= shift_register; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity ROM is generic ( M : natural := 256; N : natural := 8 ); port ( Address : in std_logic_vector(log2M-1 downto 0); Data_Out : out std_logic_vector(N-1 downto 0) ); end ROM; architecture Behavioral of ROM is begin process (Address) begin case Address is when "000" => Data_Out <= x"00"; when "001" => Data_Out <= x"01"; when "010" => Data_Out <= x"02"; when "011" => Data_Out <= x"03"; when "100" => Data_Out <= x"04"; when "101" => Data_Out <= x"05"; when "110" => Data_Out <= x"06"; when "111" => Data_Out <= x"07"; when others => Data_Out <= (others => 'Z'); end case ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity decoder is generic ( N: natural := 2; M: natural := 2 ); port ( enable: in std_logic; input: in std_logic_vector(N-1 downto 0); output: out std_logic_vector(M-1 downto 0) ); end decoder; architecture behavioral of decoder is begin process (enable, input) variable temp: std_logic_vector(M-1 downto 0); begin if enable = '1' then for i in 0 to M-1 loop temp(i) := input(i mod N); end loop ; output <= temp; else output <= (others => '0'); end if ; end process ; end behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity Encoder is port ( Input : in std_logic_vector(M-1 downto 0); Output : out std_logic_vector(N-1 downto 0) ); end entity ; architecture Behavioral of Encoder is begin process (Input) variable temp : std_logic_vector(N-1 downto 0); begin for i in M-1 downto 0 loop if Input(i) = '1' then temp := temp + "0" & Output; end if ; end loop ; Output <= temp; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity multiplexer is generic (N : natural := 2); port ( select : in std_logic_vector(log2(N) - 1 downto 0); data : in std_logic_vector(N * M - 1 downto 0); output : out std_logic_vector(M - 1 downto 0) ); end entity ; architecture behavioral of multiplexer is begin process (select, data) begin case select is when "0" => output <= data(M - 1 downto 0); when "1" => output <= data(2 * M - 1 downto M); when others => null; end case ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity demultiplexer is generic ( N: natural := 2; M: natural := 8; log2N: natural := 1 ); port ( select: in std_logic_vector(log2N-1 downto 0); data_in: in std_logic_vector(M-1 downto 0); data_out: out std_logic_vector(N*M-1 downto 0) ); end entity ; architecture behavioral of demultiplexer is begin process (select, data_in) variable sel: natural range 0 to N-1; variable data_out_tmp: std_logic_vector(M-1 downto 0); begin sel := to_integer(unsigned(select)); data_out_tmp := data_in; for i in 0 to N-1 loop if i = sel then data_out_tmp := data_in; else data_out_tmp := (others => '0'); end if ; end loop ; data_out <= data_out_tmp; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity Adder is generic (N : natural := 8); port (A, B: in std_logic_vector(N-1 downto 0); Carry_In: in std_logic; Sum: out std_logic_vector(N-1 downto 0); Carry_Out: out std_logic); end Adder; architecture Behavioral of Adder is begin process (A, B, Carry_In) variable carry : std_logic := '0'; variable sum : std_logic_vector(N-1 downto 0); begin for i in A'range loop if (i = A'high) then sum(i) <= A(i) xor B(i) xor carry; carry := A(i) and B(i) or (A(i) and carry) or (B(i) and carry); else sum(i) <= A(i) xor B(i) xor carry; carry := A(i) and B(i) or (A(i) and carry) or (B(i) and carry); end if ; end loop ; Carry_Out <= carry; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Subtractor is generic (N : natural := 8); port (A, B: in std_logic_vector(N-1 downto 0); Borrow_In: in std_logic; Difference: out std_logic_vector(N-1 downto 0); Borrow_Out: out std_logic); end Subtractor; architecture Behavioral of Subtractor is begin process (A, B, Borrow_In) variable temp : std_logic_vector(N-1 downto 0); begin if (Borrow_In = '1') then temp := A - B; Difference <= temp; Borrow_Out <= temp(N-1); else temp := A - B + "0"; Difference <= temp; Borrow_Out <= temp(N-1); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Multiplier is Port ( A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (M-1 downto 0); Product : out STD_LOGIC_VECTOR ((N+M)-1 downto 0)); end Multiplier; architecture Behavioral of Multiplier is begin Product <= A and B; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity Divider is generic (N: natural := 8; M: natural := 4); port (Dividend: in std_logic_vector(N-1 downto 0); Divisor: in std_logic_vector(M-1 downto 0); Quotient: out std_logic_vector(N-M+1 downto 0); Remainder: out std_logic_vector(M-1 downto 0)); end entity ; architecture Behavioral of Divider is begin process (Dividend, Divisor) variable quotient: unsigned(N-M+1 downto 0); variable remainder: unsigned(M-1 downto 0); begin quotient := resize(unsigned(Dividend), N-M+1); remainder := resize(unsigned(Divisor), M-1); for i in 0 to N-M loop if (remainder >= quotient) then remainder := remainder - quotient; quotient := quotient + 1; end if ; end loop ; Quotient <= std_logic_vector(quotient); Remainder <= std_logic_vector(remainder); end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Comparator is generic (N : natural := 8); port (A, B : in std_logic_vector(N-1 downto 0); A_GT_B, A_EQ_B, A_LT_B : out std_logic); end entity ; architecture Behavioral of Comparator is begin process (A, B) variable i : natural range 0 to N-1; begin for i in 0 to N-1 loop if A(i) > B(i) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif A(i) = B(i) then A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; else A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; end if ; end loop ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity BarrelShifter is generic ( N: natural := 8 ); port ( Data_In: in std_logic_vector(N-1 downto 0); Shift_Direction: in std_logic; Shift_Value: in natural range 0 to N-1; Data_Out: out std_logic_vector(N-1 downto 0) ); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (Data_In, Shift_Direction, Shift_Value) variable temp: std_logic_vector(N-1 downto 0); begin if (Shift_Direction = '0') then for i in 0 to N-1 loop if (i < Shift_Value) then temp(i) := Data_In(i+1); else temp(i) := Data_In(i); end if ; end loop ; elsif (Shift_Direction = '1') then for i in 0 to N-1 loop if (i > Shift_Value) then temp(i) := Data_In(i-1); else temp(i) := Data_In(i); end if ; end loop ; end if ; Data_Out <= temp; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PriorityEncoder is generic (N : natural := 8); port (Request : in std_logic_vector(N-1 downto 0); Grant : out std_logic_vector((log2(N))-1 downto 0); Valid : out std_logic); end PriorityEncoder; architecture Behavioral of PriorityEncoder is begin process (Request) variable temp : std_logic_vector(N-1 downto 0); variable index : natural range 0 to N-1; begin temp := Request; index := 0; for i in 0 to N-1 loop if (temp(i) = '1') then index := i; end if ; end loop ; Grant <= std_logic_vector(to_unsigned(index, log2(N))); Valid <= '1' when (index /= 0) else '0'; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FIFO is generic (N: natural := 8; M: natural := 32); port ( Clock: in std_logic; Reset: in std_logic; Write_Enable: in std_logic; Read_Enable: in std_logic; Data_In: in std_logic_vector(M-1 downto 0); Data_Out: out std_logic_vector(M-1 downto 0); Full: out std_logic; Empty: out std_logic ); end entity FIFO; architecture Behavioral of FIFO is type memory_type is array (N-1 downto 0) of std_logic_vector(M-1 downto 0); signal memory: memory_type; signal read_pointer, write_pointer: natural range 0 to N-1; begin process (Clock, Reset) variable temp: std_logic_vector(M-1 downto 0); begin if (Reset = '1') then read_pointer <= 0; write_pointer <= 0; memory <= (others => (others => '0')); elsif (rising_edge(Clock)) then if (Write_Enable = '1') then temp := Data_In; memory(write_pointer) <= temp; write_pointer <= write_pointer + 1; if (write_pointer = N-1) then write_pointer <= 0; end if ; end if ; if (Read_Enable = '1') then Data_Out <= memory(read_pointer); read_pointer <= read_pointer + 1; if (read_pointer = N-1) then read_pointer <= 0; end if ; end if ; end if ; end process ; Full <= '1' when write_pointer = read_pointer and Write_Enable = '1' else '0'; Empty <= '1' when read_pointer = write_pointer and Read_Enable = '1' else '0'; end architecture Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity FullAdder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; Carry_In : in STD_LOGIC; Sum : out STD_LOGIC; Carry_Out : out STD_LOGIC); end FullAdder; architecture Behavioral of FullAdder is begin Sum <= A xor B xor Carry_In; Carry_Out <= (A and B) or (Carry_In and (A xor B)); end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity HalfAdder is port (A, B: in std_logic; Sum: out std_logic; Carry_Out: out std_logic); end entity ; architecture Behavioral of HalfAdder is begin process (A, B) variable carry: std_logic; begin if A = '1' and B = '1' then Sum <= '0'; Carry_Out <= '1'; elsif A = '0' and B = '0' then Sum <= '0'; Carry_Out <= '0'; else Sum <= '1'; Carry_Out <= '0'; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity multiplexer is port ( a: in std_logic; b: in std_logic; select: in std_logic; output: out std_logic ); end entity ; architecture behavioral of multiplexer is begin process (a, b, select) begin if (select = '1') then output <= a; else output <= b; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity demux is port ( input : in std_logic; select : in std_logic; a : out std_logic; b : out std_logic ); end entity ; architecture behavioral of demux is begin process (input, select) begin if (select = '0') then a <= input; b <= '0'; else a <= '0'; b <= input; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity decoder is port (A: in std_logic; B: in std_logic; D0: out std_logic; D1: out std_logic; D2: out std_logic; D3: out std_logic); end decoder; architecture behavioral of decoder is begin process (A, B) variable tmp: std_logic; begin if (A = '0' and B = '0') then tmp := '1'; elsif (A = '0' and B = '1') then tmp := '0'; elsif (A = '1' and B = '0') then tmp := '0'; else tmp := '1'; end if ; D0 <= tmp; D1 <= not tmp; D2 <= tmp; D3 <= not tmp; end process ; end behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Encoder is Port ( D0 : in STD_LOGIC; D1 : in STD_LOGIC; D2 : in STD_LOGIC; D3 : in STD_LOGIC; A : out STD_LOGIC; B : out STD_LOGIC; Valid : out STD_LOGIC); end Encoder; architecture Behavioral of Encoder is begin process (D0, D1, D2, D3) variable temp : std_logic_vector(3 downto 0); begin temp := (D0 & D1 & D2 & D3); A <= temp(0); B <= temp(1); Valid <= '1'; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ShiftRegister is Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Serial_In : in STD_LOGIC; Shift_Left/Right : in STD_LOGIC; Q0 : out STD_LOGIC; Q1 : out STD_LOGIC; Q2 : out STD_LOGIC; Q3 : out STD_LOGIC; Serial_Out : out STD_LOGIC); end ShiftRegister; architecture Behavioral of ShiftRegister is begin process (Clock, Reset) variable reg: std_logic_vector(4 downto 0); begin if (Reset = '1') then reg := "0000"; elsif (rising_edge(Clock)) then if (Shift_Left/Right = '1') then reg := reg(3 downto 0) & reg(4); else reg := reg(3 downto 1) & reg(0); end if ; end if ; Q0 <= reg(0); Q1 <= reg(1); Q2 <= reg(2); Q3 <= reg(3); Serial_Out <= reg(4); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Comparator is Port ( A1 : in STD_LOGIC; A0 : in STD_LOGIC; B1 : in STD_LOGIC; B0 : in STD_LOGIC; A_GT_B : out STD_LOGIC; A_EQ_B : out STD_LOGIC; A_LT_B : out STD_LOGIC); end Comparator; architecture Behavioral of Comparator is begin process (A1, A0, B1, B0) variable a: std_logic_vector(2 downto 0); variable b: std_logic_vector(2 downto 0); begin a := (A1 & A0); b := (B1 & B0); if (a > b) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (a = b) then A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; else A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ParityChecker is Port ( A3 : in STD_LOGIC; A2 : in STD_LOGIC; A1 : in STD_LOGIC; A0 : in STD_LOGIC; Even_Parity : out STD_LOGIC; Odd_Parity : out STD_LOGIC); end ParityChecker; architecture Behavioral of ParityChecker is begin Even_Parity <= A3 xor A2 xor A1 xor A0; Odd_Parity <= not (A3 xor A2 xor A1 xor A0); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity BinaryCounter is Generic( N : integer := 8 ); Port( Clock : in std_logic; Reset : in std_logic; Count_Enable : in std_logic; Count : out std_logic_vector(N-1 downto 0) ); end BinaryCounter; architecture Behavioral of BinaryCounter is begin process (Clock, Reset) variable count : integer range 0 to 2**N - 1; begin if (Reset = '1') then count := 0; elsif (rising_edge(Clock)) then if (Count_Enable = '1') then count := count + 1; end if ; end if ; Count <= std_logic_vector(to_unsigned(count, N)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity LoadableRegister is generic ( M: natural := 8; CLOCK_FREQ: natural := 50_000_000 ); port ( Clock: in std_logic; Load_Enable: in std_logic; Data_In: in std_logic_vector(M-1 downto 0); Data_Out: out std_logic_vector(M-1 downto 0) ); end LoadableRegister; architecture Behavioral of LoadableRegister is begin process (Clock) begin if rising_edge(Clock) then if (Load_Enable = '1') then Data_Out <= Data_In; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity UniversalShiftRegister is generic ( P : natural := 8; ClockFrequency : natural := 50_000_000 ); port ( Clock : in std_logic; ShiftEnable : in std_logic; ShiftDirection : in std_logic; SerialIn : in std_logic_vector(P-1 downto 0); ParallelOut : out std_logic_vector(P-1 downto 0); SerialOut : out std_logic_vector(P-1 downto 0) ); end UniversalShiftRegister; architecture Behavioral of UniversalShiftRegister is begin process (Clock) variable shiftReg : std_logic_vector(P-1 downto 0); begin if rising_edge(Clock) then if ShiftEnable = '1' then if ShiftDirection = '0' then shiftReg := SerialIn & shiftReg(P-1 downto 1); else shiftReg := shiftReg(P-2 downto 0) & SerialIn; end if ; end if ; end if ; ParallelOut <= shiftReg; SerialOut <= shiftReg(P-1 downto P-8); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity dual_port_ram is Generic(K : integer := 8; L : integer := 32); Port(Clock : in std_logic; Write_Enable : in std_logic; Read_Enable : in std_logic; Write_Address : in unsigned(log2K-1 downto 0); Read_Address : in unsigned(log2K-1 downto 0); Data_In : in std_logic_vector(L-1 downto 0); Data_Out : out std_logic_vector(L-1 downto 0)); end dual_port_ram; architecture Behavioral of dual_port_ram is type ram_type is array (0 to K-1) of std_logic_vector(L-1 downto 0); signal ram : ram_type; begin process (Clock) begin if rising_edge(Clock) then if Write_Enable = '1' then ram(Write_Address) <= Data_In; end if ; if Read_Enable = '1' then Data_Out <= ram(Read_Address); end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity ProgrammableROM is Generic(M: integer := 256; N: integer := 32); Port(Address: in std_logic_vector(log2M-1 downto 0); Program_Enable: in std_logic; Program_Data_In: in std_logic_vector(N-1 downto 0); Data_Out: out std_logic_vector(N-1 downto 0)); end ProgrammableROM; architecture Behavioral of ProgrammableROM is type ROM_Type is array (0 to M-1) of std_logic_vector(N-1 downto 0); signal ROM: ROM_Type := (others => (others => '0')); begin process (Address, Program_Enable, Program_Data_In) variable Address_Int: integer; begin if (Program_Enable = '1') then Address_Int := to_integer(unsigned(Address)); ROM(Address_Int) <= Program_Data_In; end if ; Data_Out <= ROM(to_integer(unsigned(Address))); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity PriorityEncoder is Generic(M: integer := 2); Port(Request: in std_logic_vector(2**M-1 downto 0); Encoded_Output: out std_logic_vector(M-1 downto 0); Valid: out std_logic); end PriorityEncoder; architecture Behavioral of PriorityEncoder is signal temp: std_logic_vector(2**M-1 downto 0); begin temp <= Request; Encoded_Output <= temp(M-1 downto 0); Valid <= '1'; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity multiplexer is generic ( P : natural := 2; Q : natural := 1 ); port ( select : in std_logic_vector(P-1 downto 0); data_input : in std_logic_vector(P*Q-1 downto 0); data_output : out std_logic_vector(Q-1 downto 0) ); end entity ; architecture behavioral of multiplexer is begin process (select, data_input) variable temp : std_logic_vector(Q-1 downto 0); begin for i in 0 to P-1 loop if select(i) = '1' then temp := data_input((i+1)*Q-1 downto i*Q); exit; end if ; end loop ; data_output <= temp; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.NUMERIC_STD.all; entity demultiplexer is generic ( R: natural := 2; S: natural := 8 ); port ( select: in std_logic_vector(R-1 downto 0); data_in: in std_logic_vector(S-1 downto 0); data_out: out std_logic_vector(2**R*S-1 downto 0) ); end entity ; architecture behavioral of demultiplexer is begin process (select, data_in) variable temp: std_logic_vector(S-1 downto 0); begin for i in 0 to R-1 loop if select(i) = '1' then temp := data_in; end if ; data_out((2**R*S-1)-(i+1)) <= temp((S-1)-(i+1)); end loop ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity RippleCarryAdder is generic (N : integer := 8); port (Augend: in std_logic_vector(N-1 downto 0); Addend: in std_logic_vector(N-1 downto 0); Carry_In: in std_logic; Sum: out std_logic_vector(N-1 downto 0); Carry_Out: out std_logic); end RippleCarryAdder; architecture Behavioral of RippleCarryAdder is begin process (Augend, Addend, Carry_In) variable carry : std_logic := '0'; variable sum : std_logic_vector(N-1 downto 0); begin for i in 0 to N-1 loop if (i = 0) then sum(i) <= Augend(i) xor Addend(i) xor carry; else sum(i) <= sum(i-1) xor Augend(i) xor Addend(i) xor carry; end if ; end loop ; Carry_Out <= sum(N-1); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity ParallelSubtractor is generic ( M: natural := 8 ); port ( Minuend: in std_logic_vector(M-1 downto 0); Subtrahend: in std_logic_vector(M-1 downto 0); Borrow_In: in std_logic; Difference: out std_logic_vector(M-1 downto 0); Borrow_Out: out std_logic ); end ParallelSubtractor; architecture Behavioral of ParallelSubtractor is begin process (Minuend, Subtrahend, Borrow_In) variable temp: std_logic_vector(M-1 downto 0); variable borrow: std_logic; begin for i in M-1 downto 0 loop if (Minuend(i) = '1' and Subtrahend(i) = '1') then temp(i) := '0'; borrow := '1'; elsif (Minuend(i) = '1' and Subtrahend(i) = '0') then temp(i) := '1'; borrow := '0'; elsif (Minuend(i) = '0' and Subtrahend(i) = '1') then temp(i) := '1'; borrow := '1'; else temp(i) := '0'; borrow := '0'; end if ; end loop ; Difference <= temp; Borrow_Out <= borrow; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity sequential_multiplier is generic ( P : natural := 8; Q : natural := 8 ); port ( clk : in std_logic; a : in std_logic_vector(P-1 downto 0); b : in std_logic_vector(Q-1 downto 0); prod : out std_logic_vector((P+Q)-1 downto 0) ); end sequential_multiplier; architecture behavioral of sequential_multiplier is begin process (clk) variable temp : std_logic_vector(P+Q-1 downto 0); begin if rising_edge(clk) then temp := a & b; prod <= temp; end if ; end process ; end behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity magnitude_comparator is generic ( K: natural := 8 ); port ( A: in std_logic_vector(K-1 downto 0); B: in std_logic_vector(K-1 downto 0); A_GT_B: out std_logic; A_EQ_B: out std_logic; A_LT_B: out std_logic ); end entity ; architecture behavioral of magnitude_comparator is begin process (A, B) begin if (A > B) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (A = B) then A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; else A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity rotating_priority_encoder is generic (N: natural := 8); port ( Request: in std_logic_vector(N-1 downto 0); Output: out std_logic_vector(log2N-1 downto 0); Grant: out std_logic; Valid: out std_logic; Rotation_Bit: out std_logic ); end entity ; architecture behavioral of rotating_priority_encoder is begin process (Request) variable temp: std_logic_vector(N-1 downto 0); variable rotation_bit: std_logic; variable valid: std_logic; begin temp := Request; rotation_bit := '0'; valid := '0'; for i in 1 to N loop if (temp(N-1 downto 0) = "00000000") then rotation_bit := '1'; end if ; temp := temp(N-2 downto 0) & temp(N-1); end loop ; Output <= temp; Valid <= valid; Rotation_Bit <= rotation_bit; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity SynchronousFIFO is Generic ( M : integer := 8; P : integer := 32 ); Port ( Clock : in std_logic; Reset : in std_logic; Write_Enable : in std_logic; Read_Enable : in std_logic; Data_In : in std_logic_vector(P-1 downto 0); Data_Out : out std_logic_vector(P-1 downto 0); Full : out std_logic; Empty : out std_logic ); end SynchronousFIFO; architecture Behavioral of SynchronousFIFO is type FIFO_Type is array (M-1 downto 0) of std_logic_vector(P-1 downto 0); signal FIFO : FIFO_Type; signal Write_Pointer, Read_Pointer : integer range 0 to M-1; begin process (Clock) variable Temp : std_logic_vector(P-1 downto 0); begin if (rising_edge(Clock)) then if (Reset = '1') then Write_Pointer <= 0; Read_Pointer <= 0; FIFO <= (others => (others => '0')); elsif (Write_Enable = '1' and Read_Enable = '0') then Temp := Data_In; FIFO(Write_Pointer) <= Temp; Write_Pointer <= Write_Pointer + 1; if (Write_Pointer = M-1) then Write_Pointer <= 0; end if ; elsif (Read_Enable = '1' and Write_Enable = '0') then Data_Out <= FIFO(Read_Pointer); Read_Pointer <= Read_Pointer + 1; if (Read_Pointer = M-1) then Read_Pointer <= 0; end if ; end if ; end if ; end process ; Full <= '1' when Write_Pointer = Read_Pointer and Write_Enable = '1' else '0'; Empty <= '1' when Write_Pointer = Read_Pointer and Read_Enable = '1' else '0'; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity FullAdder is port (A, B: in std_logic; Carry_In: in std_logic; Sum: out std_logic; Carry_Out: out std_logic); end entity ; architecture Behavioral of FullAdder is begin process (A, B, Carry_In) variable temp: std_logic; begin temp := A xor B; Sum <= temp; Carry_Out <= temp and Carry_In; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity HalfAdder is port (A, B: in std_logic; Sum: out std_logic; Carry_Out: out std_logic); end entity ; architecture Behavioral of HalfAdder is begin process (A, B) variable carry: std_logic; begin if (A = '1' and B = '1') then Sum <= '0'; Carry_Out <= '1'; elsif (A = '0' and B = '0') then Sum <= '0'; Carry_Out <= '0'; else Sum <= '1'; Carry_Out <= '0'; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity 2-to-1_Multiplexer is Port ( Data0 : in STD_LOGIC; Data1 : in STD_LOGIC; Select : in STD_LOGIC; Data_Out : out STD_LOGIC); end 2-to-1_Multiplexer; architecture Behavioral of 2-to-1_Multiplexer is begin Data_Out <= (Select and Data0) or (not Select and Data1); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demux is Port ( Data_In : in STD_LOGIC; Select : in STD_LOGIC; Data_Out0 : out STD_LOGIC; Data_Out1 : out STD_LOGIC); end demux; architecture Behavioral of demux is begin process (Data_In, Select) begin if (Select = '0') then Data_Out0 <= Data_In; Data_Out1 <= '0'; else Data_Out0 <= '0'; Data_Out1 <= Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity 2-to-4_Decoder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; D0 : out STD_LOGIC; D1 : out STD_LOGIC; D2 : out STD_LOGIC; D3 : out STD_LOGIC); end 2-to-4_Decoder; architecture Behavioral of 2-to-4_Decoder is begin process (A, B) begin if (A = '0' and B = '0') then D0 <= '1'; D1 <= '0'; D2 <= '0'; D3 <= '0'; elsif (A = '0' and B = '1') then D0 <= '0'; D1 <= '1'; D2 <= '0'; D3 <= '0'; elsif (A = '1' and B = '0') then D0 <= '0'; D1 <= '0'; D2 <= '1'; D3 <= '0'; else D0 <= '0'; D1 <= '0'; D2 <= '0'; D3 <= '1'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity 4_to_2_Encoder is Port ( D0 : in STD_LOGIC; D1 : in STD_LOGIC; D2 : in STD_LOGIC; D3 : in STD_LOGIC; A : out STD_LOGIC; B : out STD_LOGIC; Valid : out STD_LOGIC); end 4_to_2_Encoder; architecture Behavioral of 4_to_2_Encoder is begin process (D0, D1, D2, D3) variable count : integer := 0; begin if (D0 = '1' and D1 = '0' and D2 = '0' and D3 = '0') then A <= '1'; B <= '0'; Valid <= '1'; elsif (D0 = '0' and D1 = '1' and D2 = '0' and D3 = '0') then A <= '0'; B <= '1'; Valid <= '1'; elsif (D0 = '0' and D1 = '0' and D2 = '1' and D3 = '0') then A <= '0'; B <= '0'; Valid <= '1'; elsif (D0 = '0' and D1 = '0' and D2 = '0' and D3 = '1') then A <= '1'; B <= '1'; Valid <= '1'; else A <= '0'; B <= '0'; Valid <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity shift_register is port ( clock: in std_logic; reset: in std_logic; shift_in: in std_logic; shift_left: in std_logic; shift_right: in std_logic; q0: out std_logic; q1: out std_logic; q2: out std_logic; q3: out std_logic; shift_out: out std_logic ); end entity ; architecture behavioral of shift_register is begin process (clock, reset) variable reg: std_logic_vector(3 downto 0); begin if (reset = '1') then reg := "0000"; elsif (rising_edge(clock)) then if (shift_left = '1') then reg := reg(2 downto 0) & reg(3); elsif (shift_right = '1') then reg := reg(2 downto 0) & reg(3); else reg := reg; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity updown_counter is port ( clock : in std_logic; reset : in std_logic; up_down : in std_logic; count_enable : in std_logic; q0, q1, q2, q3 : out std_logic ); end entity ; architecture behavioral of updown_counter is begin process (clock) variable counter : integer range 0 to 15 := 0; begin if rising_edge(clock) then if reset = '1' then counter := 0; elsif count_enable = '1' then if up_down = '1' then counter <= counter + 1; else counter <= counter - 1; end if ; end if ; end if ; q0 <= std_logic(counter(0)); q1 <= std_logic(counter(1)); q2 <= std_logic(counter(2)); q3 <= std_logic(counter(3)); end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity magnitude_comparator is Port ( A1 : in STD_LOGIC; A0 : in STD_LOGIC; B1 : in STD_LOGIC; B0 : in STD_LOGIC; A_GT_B : out STD_LOGIC; A_EQ_B : out STD_LOGIC; A_LT_B : out STD_LOGIC); end magnitude_comparator; architecture Behavioral of magnitude_comparator is begin process (A1, A0, B1, B0) variable a, b: integer range 0 to 3; begin if (A1 = '1' and A0 = '1') then a := 2; elsif (A1 = '1' and A0 = '0') then a := 1; else a := 0; end if ; if (B1 = '1' and B0 = '1') then b := 2; elsif (B1 = '1' and B0 = '0') then b := 1; else b := 0; end if ; if (a > b) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (a = b) then A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; else A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity parity_checker is Port ( D3 : in STD_LOGIC; D2 : in STD_LOGIC; D1 : in STD_LOGIC; D0 : in STD_LOGIC; Even_Parity : out STD_LOGIC; Odd_Parity : out STD_LOGIC); end parity_checker; architecture Behavioral of parity_checker is begin Even_Parity <= D0 xor D2 xor D3; Odd_Parity <= D1 xor D2 xor D3; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity barrel_shifter is port ( In3 : in std_logic; In2 : in std_logic; In1 : in std_logic; In0 : in std_logic; Shift_Left : in std_logic; Shift_Right : in std_logic; Shift_Amount : in std_logic_vector(2 downto 0); Out3 : out std_logic; Out2 : out std_logic; Out1 : out std_logic; Out0 : out std_logic ); end entity ; architecture behavioral of barrel_shifter is begin process (In3, In2, In1, In0, Shift_Left, Shift_Right, Shift_Amount) variable temp : std_logic_vector(3 downto 0); begin if (Shift_Left = '1') then for i in 0 to Shift_Amount loop temp := In3 & In2 & In1 & In0; In3 <= temp(3); In2 <= temp(2); In1 <= temp(1); In0 <= temp(0); end loop ; elsif (Shift_Right = '1') then for i in 0 to Shift_Amount loop temp := In3 & In2 & In1 & In0; In3 <= temp(0); In2 <= temp(1); In1 <= temp(2); In0 <= temp(3); end loop ; else Out3 <= 'X'; Out2 <= 'X'; Out1 <= 'X'; Out0 <= 'X'; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity EdgeDetector is port ( signal_in : in std_logic; rising_edge : out std_logic; falling_edge : out std_logic ); end entity ; architecture Behavioral of EdgeDetector is begin rising_edge <= '1' when (signal_in = '1') and (prev_signal_in = '0') else '0'; falling_edge <= '1' when (signal_in = '0') and (prev_signal_in = '1') else '0'; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity RingCounter is generic (N : natural := 8); port ( clock: in std_logic; reset: in std_logic; ring_count: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of RingCounter is begin process (clock, reset) variable counter : natural range 0 to N-1 := 0; begin if (reset = '1') then counter := 0; elsif (rising_edge(clock)) then counter := counter + 1; if (counter = N-1) then counter := 0; end if ; end if ; ring_count <= std_logic_vector(to_unsigned(counter, N)); end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity johnson_counter is Generic( N : integer := 8 ); Port( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Johnson_Count : out STD_LOGIC_VECTOR (N-1 downto 0) ); end johnson_counter; architecture Behavioral of johnson_counter is signal count : unsigned(N-1 downto 0); begin process (Clock, Reset) if (Reset = '1') then count <= (others => '0'); elsif (rising_edge(Clock)) then count <= count + 1; end if ; end process ; Johnson_Count <= std_logic_vector(count); end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity lfsr is generic ( N: natural := 8 ); port ( clock: in std_logic; reset: in std_logic; seed_value: in std_logic_vector(N-1 downto 0); lfsr_output: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of lfsr is begin process (clock, reset) variable reg: std_logic_vector(N-1 downto 0); begin if (reset = '1') then reg := seed_value; elsif (rising_edge(clock)) then reg := reg(N-2 downto 0) & reg(N-1); end if ; lfsr_output <= reg; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity FiniteStateMachine is Generic (N : integer := 2); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Input_Signals : in STD_LOGIC_VECTOR (N-1 downto 0); Current_State : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); Output_Signals : out STD_LOGIC_VECTOR (N-1 downto 0)); end FiniteStateMachine; architecture Behavioral of FiniteStateMachine is type State_Type is (State0, State1, ..., StateN-1); signal Current_State : State_Type; begin process (Clock) if rising_edge(Clock) then if Reset = '1' then Current_State <= State0; else case Current_State is when State0 => if Input_Signals(0) = '1' then Current_State <= State1; end if ; when State1 => if Input_Signals(1) = '1' then Current_State <= State2; end if ; ... when StateN-1 => if Input_Signals(N-1) = '1' then Current_State <= State0; end if ; end case ; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity B2GConverter is generic ( N: natural := 8; G: natural := 9; ); port ( Binary_Code: in std_logic_vector(N-1 downto 0); Gray_Code: out std_logic_vector(G-1 downto 0) ); end B2GConverter; architecture Behavioral of B2GConverter is begin process (Binary_Code) variable Gray_Code_temp: std_logic_vector(G-1 downto 0); begin for i in G-1 downto 0 loop if i = 0 then Gray_Code_temp(i) <= Binary_Code(i); else Gray_Code_temp(i) <= Gray_Code_temp(i-1) xor Binary_Code(i); end if ; end loop ; Gray_Code <= Gray_Code_temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity gray_to_binary is generic (N : integer := 8); port ( Gray_Code : in std_logic_vector(N-1 downto 0); Binary_Code : out std_logic_vector(N-1 downto 0) ); end entity ; architecture Behavioral of gray_to_binary is begin process (Gray_Code) variable binary_code : std_logic_vector(N-1 downto 0); begin for i in 0 to N-1 loop if Gray_Code(i) = '1' then binary_code(i) := '0'; else binary_code(i) := '1'; end if ; end loop ; Binary_Code <= binary_code; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Excess3ToBCDConverter is Port ( Excess3_Value : in STD_LOGIC_VECTOR (3 downto 0); BCD_Value : out STD_LOGIC_VECTOR (3 downto 0)); end Excess3ToBCDConverter; architecture Behavioral of Excess3ToBCDConverter is begin process (Excess3_Value) variable temp : integer range 0 to 9; begin if (Excess3_Value = "1110") then temp := 0; elsif (Excess3_Value = "1101") then temp := 1; elsif (Excess3_Value = "1011") then temp := 2; elsif (Excess3_Value = "0111") then temp := 3; elsif (Excess3_Value = "1001") then temp := 4; elsif (Excess3_Value = "0101") then temp := 5; elsif (Excess3_Value = "1010") then temp := 6; elsif (Excess3_Value = "0110") then temp := 7; elsif (Excess3_Value = "0011") then temp := 8; else temp := 9; end if ; BCD_Value <= std_logic_vector(to_unsigned(temp, 4)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity HammingCodeEncoder is Port ( Data_In : in STD_LOGIC_VECTOR (3 downto 0); Encoded_Data : out STD_LOGIC_VECTOR (6 downto 0)); end HammingCodeEncoder; architecture Behavioral of HammingCodeEncoder is begin Encoded_Data <= Data_In & "0"; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity HammingCodeDecoder is Port ( Encoded_Data : in STD_LOGIC_VECTOR (7 downto 0); Data_Out : out STD_LOGIC_VECTOR (3 downto 0); Error_Flag : out STD_LOGIC); end HammingCodeDecoder; architecture Behavioral of HammingCodeDecoder is begin Data_Out <= Encoded_Data(6 downto 4) when Encoded_Data(7) = '0' else (others => 'X'); Error_Flag <= '1' when Encoded_Data(7) = '1' and Encoded_Data(6 downto 4) /= Data_Out else '0'; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity crc_generator is generic (N : natural := 8); port ( clk : in std_logic; rst : in std_logic; data_in : in std_logic_vector(N-1 downto 0); polynomial : in std_logic_vector(M-1 downto 0); crc_value : out std_logic_vector(M-1 downto 0) ); end entity ; architecture behavioral of crc_generator is begin process (clk, rst) variable temp : std_logic_vector(M-1 downto 0); begin if rising_edge(clk) then if rst = '1' then temp := (others => '0'); else temp := polynomial; for i in 0 to N-1 loop if data_in(i) = '1' then temp := temp xor polynomial; end if ; end loop ; end if ; crc_value <= temp; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity crc_checker is generic ( N : natural := 8; M : natural := 8 ); port ( Data_In : in std_logic_vector(N-1 downto 0); Received_CRC : in std_logic_vector(M-1 downto 0); Polynomial : in std_logic_vector(M-1 downto 0); CRC_Match : out std_logic ); end entity ; architecture behavioral of crc_checker is begin process (Data_In, Received_CRC, Polynomial) variable data_reg : std_logic_vector(N-1 downto 0); variable received_crc_reg : std_logic_vector(M-1 downto 0); variable polynomial_reg : std_logic_vector(M-1 downto 0); begin data_reg := Data_In; received_crc_reg := Received_CRC; polynomial_reg := Polynomial; for i in 0 to M-1 loop if (polynomial_reg(i) = '1') then received_crc_reg := received_crc_reg xor data_reg; end if ; data_reg := data_reg sll 1; end loop ; CRC_Match <= '1' when (received_crc_reg = Polynomial) else '0'; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity PSConverter is generic ( N : natural := 8 ); port ( Clock : in std_logic; Parallel_In : in std_logic_vector(N-1 downto 0); Load_Enable : in std_logic; Serial_Out : out std_logic ); end PSConverter; architecture Behavioral of PSConverter is begin process (Clock) begin if (rising_edge(Clock)) then if (Load_Enable = '1') then Serial_Out <= Parallel_In(N-1); end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity serial_to_parallel is Generic( N : integer := 8 ); Port( Clock : in std_logic; Serial_In : in std_logic_vector(N-1 downto 0); Shift_Enable : in std_logic; Parallel_Out : out std_logic_vector(N-1 downto 0) ); end serial_to_parallel; architecture Behavioral of serial_to_parallel is begin process (Clock, Serial_In, Shift_Enable) variable temp : std_logic_vector(N-1 downto 0); begin if rising_edge(Clock) then if Shift_Enable = '1' then temp := Serial_In; end if ; Parallel_Out <= temp; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FloatingPointAdder is generic (N : natural := 32); port (A, B: in std_logic_vector(N-1 downto 0); Sum: out std_logic_vector(N-1 downto 0)); end entity ; architecture Behavioral of FloatingPointAdder is begin Sum <= A + B; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity floating_point_multiplier is generic (N : natural := 32); port (A, B: in std_logic_vector(N-1 downto 0); Product: out std_logic_vector(N-1 downto 0)); end entity ; architecture behavioral of floating_point_multiplier is begin Product <= A * B; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity fixed_point_divider is generic (N: natural := 8); port ( dividend: in signed(N-1 downto 0); divisor: in signed(N-1 downto 0); quotient: out signed(N-1 downto 0); remainder: out signed(N-1 downto 0) ); end entity ; architecture behavioral of fixed_point_divider is begin process (dividend, divisor) variable quotient_temp: signed(N-1 downto 0); variable remainder_temp: signed(N-1 downto 0); begin if (divisor = to_signed(0, N)) then quotient <= (others => '0'); remainder <= (others => '0'); else quotient_temp := dividend / divisor; remainder_temp := dividend mod divisor; quotient <= quotient_temp; remainder <= remainder_temp; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity signed_multiplier is generic ( N : natural := 8 ); port ( A, B: in std_logic_vector(N-1 downto 0); Product: out std_logic_vector((2*N)-1 downto 0) ); end entity ; architecture behavioral of signed_multiplier is begin Product <= A * B; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity UnsignedDivider is generic (N: natural := 8); port ( Dividend: in std_logic_vector(N-1 downto 0); Divisor: in std_logic_vector(N-1 downto 0); Quotient: out std_logic_vector(N-1 downto 0); Remainder: out std_logic_vector(N-1 downto 0) ); end UnsignedDivider; architecture Behavioral of UnsignedDivider is begin process (Dividend, Divisor) variable quotient: unsigned(N-1 downto 0); variable remainder: unsigned(N-1 downto 0); begin quotient := unsigned(Dividend) / unsigned(Divisor); remainder := unsigned(Dividend) mod unsigned(Divisor); Quotient <= std_logic_vector(quotient); Remainder <= std_logic_vector(remainder); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity pipelined_multiplier is generic ( N: natural := 8; M: natural := 8 ); port ( clk: in std_logic; a: in std_logic_vector(N-1 downto 0); b: in std_logic_vector(M-1 downto 0); product: out std_logic_vector((N+M)-1 downto 0) ); end entity ; architecture behavioral of pipelined_multiplier is signal a_reg, b_reg: std_logic_vector(N-1 downto 0); signal product_reg: std_logic_vector((N+M)-1 downto 0); begin process (clk) variable temp: std_logic_vector((N+M)-1 downto 0); begin if rising_edge(clk) then a_reg <= a; b_reg <= b; temp := a_reg * b_reg; product_reg <= temp; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity Floating_Point_Converter is generic (N : natural := 32; M : natural := 32); port (Fixed_Point : in std_logic_vector(N-1 downto 0); Float_Value : out std_logic_vector(M-1 downto 0)); end Floating_Point_Converter; architecture Behavioral of Floating_Point_Converter is begin process (Fixed_Point) variable Sign, Exponent, Mantissa : integer; begin Sign <= to_integer(unsigned(Fixed_Point(N-1 downto N-2))); Exponent <= to_integer(unsigned(Fixed_Point(N-3 downto N-4))); Mantissa <= to_integer(unsigned(Fixed_Point(N-5 downto 0))); Float_Value <= std_logic_vector(to_float(Sign, Exponent, Mantissa)); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity fixed_point_converter is generic ( M: natural := 32; N: natural := 16 ); port ( float_value: in std_logic_vector(M-1 downto 0); fixed_point: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of fixed_point_converter is begin process (float_value) variable fp_value: signed(M-1 downto 0); variable int_value: signed(N-1 downto 0); begin fp_value := signed(float_value); int_value := resize(fp_value, N); fixed_point <= std_logic_vector(int_value); end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity BinaryToBCDConverter is generic ( N: natural := 8; M: natural := 3; DIGITS: natural := 10; SEP: std_logic := '0'; ZERO: std_logic := '0' ); port ( Binary_Value: in std_logic_vector(N-1 downto 0); BCD_Value: out std_logic_vector((M*DIGITS)-1 downto 0) ); end BinaryToBCDConverter; architecture Behavioral of BinaryToBCDConverter is begin process (Binary_Value) variable temp: std_logic_vector(N-1 downto 0); variable BCD: std_logic_vector((M*DIGITS)-1 downto 0); begin BCD := (others => ZERO); for i in 0 to N-1 loop temp(i) := Binary_Value(i); if temp(i) = '1' then BCD := BCD + (DIGITS**i)*(SEP & "1"); end if ; end loop ; BCD_Value <= BCD; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity BCD_to_Binary is Generic(N: integer := 8); Port(BCD_Value: in std_logic_vector((N/3)+1-1 downto 0); Binary_Value: out std_logic_vector(N-1 downto 0)); end BCD_to_Binary; architecture Behavioral of BCD_to_Binary is begin process (BCD_Value) variable temp: std_logic_vector((N/3)+1-1 downto 0); begin for i in 0 to (N/3)-1 loop temp := BCD_Value((i+1)*3-1 downto i*3); case temp is when "000" => Binary_Value(i*4+3 downto i*4) <= "0000"; when "001" => Binary_Value(i*4+3 downto i*4) <= "0001"; when "010" => Binary_Value(i*4+3 downto i*4) <= "0010"; when "011" => Binary_Value(i*4+3 downto i*4) <= "0011"; when "100" => Binary_Value(i*4+3 downto i*4) <= "0100"; when "101" => Binary_Value(i*4+3 downto i*4) <= "0101"; when "110" => Binary_Value(i*4+3 downto i*4) <= "0110"; when "111" => Binary_Value(i*4+3 downto i*4) <= "0111"; end case ; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity ParallelInParallelOutShiftRegister is Generic (N : integer := 8); Port ( Clock : in STD_LOGIC; Load_Enable : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Shift_Direction : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end ParallelInParallelOutShiftRegister; architecture Behavioral of ParallelInParallelOutShiftRegister is signal shift_register : STD_LOGIC_VECTOR (N-1 downto 0); begin process (Clock) begin if rising_edge(Clock) then if Load_Enable = '1' then shift_register <= Data_In; elsif Shift_Enable = '1' and Shift_Direction = '0' then shift_register <= shift_register(N-2 downto 0) & shift_register(N-1); elsif Shift_Enable = '1' and Shift_Direction = '1' then shift_register <= shift_register(N-1 downto 1) & shift_register(0); end if ; end if ; end process ; Data_Out <= shift_register; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity JohnsonRingCounter is Generic(N : integer := 8); Port(Clock : in std_logic; Reset : in std_logic; Count : out std_logic_vector(N-1 downto 0)); end JohnsonRingCounter; architecture Behavioral of JohnsonRingCounter is begin process (Clock) variable counter : integer range 0 to 2**N - 1; begin if (Reset = '1') then counter := 0; elsif (rising_edge(Clock)) then counter := counter + 1; end if ; Count <= std_logic_vector(to_unsigned(counter, N)); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PRNG is generic ( N : natural := 32; SEED_VALUE : std_logic_vector(N-1 downto 0) := (others => '0'); RANDOM_NUMBER : std_logic_vector(N-1 downto 0); ); port ( clock : in std_logic; reset : in std_logic := '0'; seed_value : in std_logic_vector(N-1 downto 0) := SEED_VALUE; random_number : out std_logic_vector(N-1 downto 0); ); end PRNG; architecture behavioral of PRNG is begin process (clock, reset) variable state : std_logic_vector(N-1 downto 0); begin if (reset = '1') then state := SEED_VALUE; elsif (rising_edge(clock)) then state := state xor seed_value; end if ; random_number <= state; end process ; end behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FIR_Filter is generic ( N: natural := 8; M: natural := 3 ); port ( clk: in std_logic; rst: in std_logic; data_in: in std_logic_vector(N-1 downto 0); coefficients: in std_logic_vector(M*N-1 downto 0); filtered_output: out std_logic_vector(N-1 downto 0) ); end FIR_Filter; architecture Behavioral of FIR_Filter is signal data_reg: std_logic_vector(N-1 downto 0); signal coefficients_reg: std_logic_vector(M*N-1 downto 0); begin process (clk, rst) variable sum: std_logic_vector(N-1 downto 0); begin if (rst = '1') then data_reg <= (others => '0'); coefficients_reg <= (others => '0'); elsif (rising_edge(clk)) then sum := (others => '0'); for i in 0 to M-1 loop sum := std_logic_vector(unsigned(sum) + unsigned(coefficients_reg((i+1)*N-1 downto i*N))); end loop ; data_reg <= data_in; coefficients_reg <= coefficients; filtered_output <= sum; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PID_Controller is generic ( N: natural := 8 ); port ( Clock: in std_logic; Reset: in std_logic; Set_Point: in signed(N-1 downto 0); Measured_Value: in signed(N-1 downto 0); Kp, Ki, Kd: in signed(N-1 downto 0); Control_Output: out signed(N-1 downto 0) ); end PID_Controller; architecture Behavioral of PID_Controller is begin process (Clock, Reset) variable error: signed(N-1 downto 0); variable integral: signed(N-1 downto 0); variable derivative: signed(N-1 downto 0); begin if (Reset = '1') then error := (others => '0'); integral := (others => '0'); derivative := (others => '0'); elsif (Clock'event and Clock = '1') then error := Set_Point - Measured_Value; integral := integral + error * Ki; derivative := derivative + error * Kd; Control_Output <= Kp * error + integral + derivative; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity DigitalIntegrator is generic ( N : natural := 8 ); port ( Clock : in std_logic; Reset : in std_logic; Data_In : in std_logic_vector(N-1 downto 0); Integrated_Output : out std_logic_vector(N-1 downto 0) ); end DigitalIntegrator; architecture Behavioral of DigitalIntegrator is begin process (Clock, Reset) variable sum : unsigned(N-1 downto 0); begin if (Reset = '1') then sum := (others => '0'); elsif (rising_edge(Clock)) then sum := sum + Data_In; end if ; Integrated_Output <= std_logic_vector(sum); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Digital_Differentiator is Generic(N : integer := 8); Port(Clock : in std_logic; Data_In : in std_logic_vector(N-1 downto 0); Differentiated_Output : out std_logic_vector(N-1 downto 0)); end Digital_Differentiator; architecture Behavioral of Digital_Differentiator is begin process (Clock) variable temp : std_logic_vector(N-1 downto 0); begin if (rising_edge(Clock)) then temp := Data_In; Differentiated_Output <= temp - Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.NUMERIC_STD.all; entity frequency_divider is port ( clock: in std_logic; reset: in std_logic; divide_ratio: in std_logic_vector(N-1 downto 0); divided_clock: out std_logic ); end entity ; architecture behavioral of frequency_divider is begin process (clock, reset) variable counter: integer range 0 to N-1 := 0; begin if rising_edge(clock) then if reset = '1' then counter := 0; else if counter < divide_ratio then counter := counter + 1; else counter := 0; divided_clock <= not divided_clock; end if ; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.all; entity Edge_Detector is port ( Signal_In: in std_logic; Rising_Edge_Pulse: out std_logic; Falling_Edge_Pulse: out std_logic ); end entity ; architecture Behavioral of Edge_Detector is begin process (Signal_In) variable prev_signal: std_logic := '0'; begin if Signal_In'event then if Signal_In = '1' and prev_signal = '0' then Rising_Edge_Pulse <= '1'; Falling_Edge_Pulse <= '0'; elsif Signal_In = '0' and prev_signal = '1' then Rising_Edge_Pulse <= '0'; Falling_Edge_Pulse <= '1'; else Rising_Edge_Pulse <= '0'; Falling_Edge_Pulse <= '0'; end if ; prev_signal := Signal_In; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity GlitchFilter is Port ( Noisy_Signal : in STD_LOGIC; Filtered_Signal : out STD_LOGIC); end GlitchFilter; architecture Behavioral of GlitchFilter is begin process (Noisy_Signal) variable filtered_signal : std_logic := '0'; begin if rising_edge(Noisy_Signal) then filtered_signal := Noisy_Signal; end if ; Filtered_Signal <= filtered_signal; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Debouncer is Port ( Noisy_Button : in STD_LOGIC; Clean_Button_Pulse : out STD_LOGIC); end Debouncer; architecture Behavioral of Debouncer is begin process (Noisy_Button) variable count: integer range 0 to 15 := 0; begin if (Noisy_Button = '1') then count := count + 1; if (count >= 10) then Clean_Button_Pulse <= '1'; else Clean_Button_Pulse <= '0'; end if ; else count := 0; Clean_Button_Pulse <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity SchmittTriggerInput is Port ( Analog_In : in STD_LOGIC; Digital_Out : out STD_LOGIC); end SchmittTriggerInput; architecture Behavioral of SchmittTriggerInput is begin Digital_Out <= '1' when Analog_In > 0.5 else '0'; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity pulse_generator is port ( clock: in std_logic; reset: in std_logic; pulse_width: in unsigned(N-1 downto 0); pulse_out: out std_logic ); end entity ; architecture behavioral of pulse_generator is begin process (clock, reset) variable counter: unsigned(N-1 downto 0); begin if (reset = '1') then counter := (others => '0'); elsif (rising_edge(clock)) then counter := counter + 1; if (counter >= pulse_width) then pulse_out <= '1'; else pulse_out <= '0'; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity MonostableMultivibrator is Port ( Trigger : in STD_LOGIC; Pulse_Out : out STD_LOGIC; Pulse_Duration : in STD_LOGIC_VECTOR (N-1 downto 0)); end MonostableMultivibrator; architecture Behavioral of MonostableMultivibrator is begin process (Trigger) variable count: integer range 0 to Pulse_Duration; begin if Trigger = '1' then count := 0; while (count < Pulse_Duration) loop count := count + 1; wait for 1 ns; end loop ; Pulse_Out <= '1'; wait until falling_edge(Trigger); Pulse_Out <= '0'; else Pulse_Out <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity AsynchronousMultivibrator is Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Oscillating_Output : out STD_LOGIC); end AsynchronousMultivibrator; architecture Behavioral of AsynchronousMultivibrator is begin process (Clock, Reset) variable State : std_logic := '0'; begin if (Reset = '1') then State := '0'; elsif (rising_edge(Clock)) then State := not State; end if ; Oscillating_Output <= State; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity UpCounter is generic ( N: natural := 8 ); port ( Clk: in std_logic; Rst: in std_logic; En: in std_logic; Count: out std_logic_vector(N-1 downto 0) ); end entity ; architecture Behavioral of UpCounter is begin process (Clk, Rst, En) variable i: natural range 0 to N; begin if (Rst = '1') then Count <= (others => '0'); elsif (rising_edge(Clk)) then if (En = '1') then i := i + 1; Count <= std_logic_vector(to_unsigned(i, N)); end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity data_register is generic ( M : natural := 8 ); port ( clock : in std_logic; reset : in std_logic; load : in std_logic; data_in : in std_logic_vector(M-1 downto 0); data_out: out std_logic_vector(M-1 downto 0) ); end entity ; architecture behavioral of data_register is begin process (clock, reset) begin if (reset = '1') then data_out <= (others => '0'); elsif (rising_edge(clock)) then if (load = '1') then data_out <= data_in; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity BidirectionalShiftRegister is generic ( P: natural := 8 ); port ( Clk: in std_logic; Clear: in std_logic; Ser_In: in std_logic_vector(P-1 downto 0); Shift_En: in std_logic; Shift_Dir: in std_logic; Par_Out: out std_logic_vector(P-1 downto 0); Ser_Out: out std_logic_vector(P-1 downto 0) ); end BidirectionalShiftRegister; architecture Behavioral of BidirectionalShiftRegister is signal reg: std_logic_vector(P-1 downto 0); begin process (Clk, Clear) begin if (Clear = '1') then reg <= (others => '0'); elsif (rising_edge(Clk)) then if (Shift_En = '1') then if (Shift_Dir = '0') then reg <= reg(P-2 downto 0) & Ser_In(P-1); else reg <= Ser_In(P-1) & reg(P-1 downto 1); end if ; end if ; end if ; end process ; Par_Out <= reg; Ser_Out <= reg; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity dual_port_memory is Generic( K : integer := 8; L : integer := 32 ); Port( clk : in std_logic; write : in std_logic; address_w : in std_logic_vector((log2(K))-1 downto 0); address_r : in std_logic_vector((log2(K))-1 downto 0); data_write : in std_logic_vector(L-1 downto 0); data_read : out std_logic_vector(L-1 downto 0) ); end dual_port_memory; architecture behavioral of dual_port_memory is begin process (clk, write, address_w, address_r, data_write) variable memory : std_logic_vector(K*L-1 downto 0); begin if rising_edge(clk) then if write = '1' then memory(address_w) := data_write; end if ; data_read <= memory(address_r); end if ; end process ; end behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity ROM is generic ( M : integer := 256; N : integer := 8; AddrWidth : integer := log2(M) ); port ( Clk : in std_logic; Rst : in std_logic; Addr : in std_logic_vector(AddrWidth-1 downto 0); Data_Out : out std_logic_vector(N-1 downto 0) ); end entity ; architecture Behavioral of ROM is begin process (Clk, Rst) begin if (Rst = '1') then Data_Out <= (others => '0'); elsif (rising_edge(Clk)) then case Addr is when "000" => Data_Out <= x"00"; when "001" => Data_Out <= x"01"; when "010" => Data_Out <= x"02"; when others => Data_Out <= (others => 'X'); end case ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity PriorityEncoder is generic ( M: natural := 2 ); port ( Requests: in std_logic_vector(2**M-1 downto 0); Encoded: out std_logic_vector(M-1 downto 0); Valid: out std_logic ); end PriorityEncoder; architecture Behavioral of PriorityEncoder is begin process (Requests) variable EncodedTemp: std_logic_vector(M-1 downto 0); variable ValidTemp: std_logic; begin EncodedTemp := (others => '0'); ValidTemp := '0'; for i in Requests'range loop if Requests(i) = '1' then EncodedTemp := std_logic_vector(to_unsigned(i, M)); ValidTemp := '1'; end if ; end loop ; Encoded <= EncodedTemp; Valid <= ValidTemp; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity data_multiplexer is generic (N : natural := 2); port ( Sel : in std_logic_vector((log2(N))-1 downto 0); Data_Inputs : in std_logic_vector(N*M-1 downto 0); Data_Out : out std_logic_vector(M-1 downto 0) ); end entity ; architecture behavioral of data_multiplexer is begin process (Sel, Data_Inputs) variable i : natural range 0 to N-1 := 0; begin case Sel is when "0" => Data_Out <= Data_Inputs((i+1)*M-1 downto i*M); when "1" => Data_Out <= Data_Inputs((i+2)*M-1 downto (i+1)*M); when others => Data_Out <= (others => '0'); end case ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity data_demultiplexer is generic ( N: natural := 2; M: natural := 8 ); port ( Sel: in std_logic_vector(log2(N) - 1 downto 0); Data_In: in std_logic_vector(M - 1 downto 0); Data_Outs: out std_logic_vector(N * M - 1 downto 0) ); end entity ; architecture behavioral of data_demultiplexer is begin process (Sel, Data_In) variable sel_index: natural range 0 to N - 1; variable data_out: std_logic_vector(M - 1 downto 0); begin sel_index := to_integer(unsigned(Sel)); data_out := Data_In; for i in 0 to N - 1 loop if (i = sel_index) then Data_Outs(M * (i + 1) - 1 downto M * i) <= data_out; else Data_Outs(M * (i + 1) - 1 downto M * i) <= (others => '0'); end if ; end loop ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity AdderCircuit is generic ( N : natural := 8 ); port ( A, B: in std_logic_vector(N-1 downto 0); Cin: in std_logic; Sum: out std_logic_vector(N-1 downto 0); Cout: out std_logic ); end AdderCircuit; architecture Behavioral of AdderCircuit is begin process (A, B, Cin) variable temp : std_logic_vector(N-1 downto 0); begin temp := A + B + Cin; Sum <= temp(N-1 downto 0); Cout <= temp(N); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity Subtractor is generic ( M: natural := 8 ); port ( X: in std_logic_vector(M-1 downto 0); Y: in std_logic_vector(M-1 downto 0); Borrow_In: in std_logic; Diff: out std_logic_vector(M-1 downto 0); Borrow_Out: out std_logic ); end entity Subtractor; architecture Behavioral of Subtractor is begin process (X, Y, Borrow_In) variable temp: std_logic_vector(M-1 downto 0); begin temp := X - Y - Borrow_In; Diff <= temp; Borrow_Out <= temp(M-1); end process ; end architecture Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity Comparator is generic ( K: natural := 8 ); port ( Value1: in std_logic_vector(K-1 downto 0); Value2: in std_logic_vector(K-1 downto 0); Greater: out std_logic; Equal: out std_logic; Smaller: out std_logic ); end entity ; architecture Behavioral of Comparator is begin process (Value1, Value2) begin if (Value1 > Value2) then Greater <= '1'; Equal <= '0'; Smaller <= '0'; elsif (Value1 = Value2) then Greater <= '0'; Equal <= '1'; Smaller <= '0'; else Greater <= '0'; Equal <= '0'; Smaller <= '1'; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity BarrelShifter is generic ( N: natural := 8 ); port ( Data_In: in std_logic_vector(N-1 downto 0); Shift_Left, Shift_Right: in std_logic; Shift_Amount: in unsigned(N-1 downto 0); Data_Out: out std_logic_vector(N-1 downto 0) ); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (Data_In, Shift_Left, Shift_Right, Shift_Amount) variable temp: std_logic_vector(N-1 downto 0); begin if (Shift_Left = '1') then for i in 0 to N-1 loop temp(i) := Data_In(i+Shift_Amount); end loop ; Data_Out <= temp; elsif (Shift_Right = '1') then for i in 0 to N-1 loop temp(i) := Data_In(N-1-i+Shift_Amount); end loop ; Data_Out <= temp; else Data_Out <= Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity PriorityEncoder is Generic (N: integer := 8); Port ( Requests : in STD_LOGIC_VECTOR (N-1 downto 0); Encoded : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); Request_Valid : out STD_LOGIC ); end PriorityEncoder; architecture Behavioral of PriorityEncoder is begin Encoded <= Requests(Requests'high) & Requests(Requests'high-1 downto 0); Request_Valid <= '1'; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FIFO_Buffer is generic ( N: natural := 8; M: natural := 32 ); port ( Clk: in std_logic; Reset: in std_logic; Write_En: in std_logic; Read_En: in std_logic; Data_In: in std_logic_vector(M-1 downto 0); Data_Out: out std_logic_vector(M-1 downto 0); Full_Flag: out std_logic; Empty_Flag: out std_logic ); end entity FIFO_Buffer; architecture Behavioral of FIFO_Buffer is type buffer_type is array (N-1 downto 0) of std_logic_vector(M-1 downto 0); signal buffer: buffer_type := (others => (others => '0')); signal read_pointer, write_pointer: natural range 0 to N-1; begin process (Clk) variable temp: std_logic_vector(M-1 downto 0); begin if rising_edge(Clk) then if Reset = '1' then read_pointer <= 0; write_pointer <= 0; buffer <= (others => (others => '0')); elsif Write_En = '1' and Full_Flag = '0' then temp := Data_In; buffer(write_pointer) <= temp; if write_pointer = N-1 then write_pointer <= 0; else write_pointer <= write_pointer + 1; end if ; elsif Read_En = '1' and Empty_Flag = '0' then Data_Out <= buffer(read_pointer); if read_pointer = N-1 then read_pointer <= 0; else read_pointer <= read_pointer + 1; end if ; end if ; end if ; end process ; Full_Flag <= '1' when write_pointer = read_pointer and Write_En = '1' else '0'; Empty_Flag <= '1' when read_pointer = write_pointer and Read_En = '1' else '0'; end architecture Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity FullAdder is port (A, B: in std_logic; Carry_In: in std_logic; Sum: out std_logic; Carry_Out: out std_logic); end entity ; architecture Behavioral of FullAdder is begin process (A, B, Carry_In) variable carry: std_logic; begin if (Carry_In = '1') then carry := '1'; else carry := '0'; end if ; if (A = '1' and B = '1') then Sum <= '1'; Carry_Out <= carry xor '1'; elsif (A = '0' and B = '0') then Sum <= '0'; Carry_Out <= carry; else Sum <= A xor B; Carry_Out <= carry; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity HalfAdder is port ( A: in std_logic; B: in std_logic; Sum: out std_logic; Carry_Out: out std_logic ); end entity ; architecture Behavioral of HalfAdder is begin Sum <= A xor B; Carry_Out <= A and B; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity 2-to-1_Multiplexer is port ( Data0 : in std_logic; Data1 : in std_logic; Sel : in std_logic; Data_Out : out std_logic ); end entity ; architecture Behavioral of 2-to-1_Multiplexer is begin Data_Out <= (Data0 and not Sel) or (Data1 and Sel); end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demux is Port ( Data_In : in STD_LOGIC; Sel : in STD_LOGIC; Out0 : out STD_LOGIC; Out1 : out STD_LOGIC); end demux; architecture Behavioral of demux is begin process (Data_In, Sel) begin if (Sel = '0') then Out0 <= Data_In; Out1 <= '0'; else Out0 <= '0'; Out1 <= Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity 2-to-4_Decoder is port (A: in std_logic; B: in std_logic; D0: out std_logic; D1: out std_logic; D2: out std_logic; D3: out std_logic); end 2-to-4_Decoder; architecture Behavioral of 2-to-4_Decoder is begin process (A, B) begin case (A & B) is when "00" => D0 <= '1'; D1 <= '0'; D2 <= '0'; D3 <= '0'; when "01" => D0 <= '0'; D1 <= '1'; D2 <= '0'; D3 <= '0'; when "10" => D0 <= '0'; D1 <= '0'; D2 <= '1'; D3 <= '0'; when "11" => D0 <= '0'; D1 <= '0'; D2 <= '0'; D3 <= '1'; end case ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity 4_to_2_encoder is port ( I0, I1, I2, I3: in std_logic; A, B: out std_logic; Valid: out std_logic ); end entity ; architecture behavioral of 4_to_2_encoder is begin process (I0, I1, I2, I3) begin if (I0 = '1' and I1 = '0' and I2 = '0' and I3 = '0') then A <= '1'; B <= '0'; Valid <= '1'; elsif (I0 = '0' and I1 = '1' and I2 = '0' and I3 = '0') then A <= '0'; B <= '1'; Valid <= '1'; elsif (I0 = '0' and I1 = '0' and I2 = '1' and I3 = '0') then A <= '0'; B <= '0'; Valid <= '1'; elsif (I0 = '0' and I1 = '0' and I2 = '0' and I3 = '1') then A <= '1'; B <= '1'; Valid <= '1'; else A <= '0'; B <= '0'; Valid <= '0'; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity shift_register is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Ser_In : in STD_LOGIC_VECTOR (3 downto 0); Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Q0 : out STD_LOGIC; Q1 : out STD_LOGIC; Q2 : out STD_LOGIC; Q3 : out STD_LOGIC; Ser_Out : out STD_LOGIC_VECTOR (3 downto 0)); end shift_register; architecture Behavioral of shift_register is begin process (Clk, Reset) variable reg: std_logic_vector(3 downto 0); begin if (Reset = '1') then reg := "0000"; elsif (rising_edge(Clk)) then if (Shift_Left = '1') then reg := reg(2 downto 0) & reg(3); elsif (Shift_Right = '1') then reg := reg(3 downto 1) & reg(0); end if ; end if ; Q0 <= reg(0); Q1 <= reg(1); Q2 <= reg(2); Q3 <= reg(3); Ser_Out <= reg; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity updown_counter is port ( clock: in std_logic; rst: in std_logic; updown: in std_logic; en: in std_logic; count0: out std_logic; count1: out std_logic; count2: out std_logic; count3: out std_logic ); end entity ; architecture behavioral of updown_counter is begin process (clock, rst) variable counter: unsigned(3 downto 0); begin if (rst = '1') then counter := (others => '0'); elsif (rising_edge(clock)) then if (en = '1') then if (updown = '1') then counter <= counter + 1; else counter <= counter - 1; end if ; end if ; end if ; count0 <= counter(0); count1 <= counter(1); count2 <= counter(2); count3 <= counter(3); end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity magnitude_comparator is port (A1, A0, B1, B0: in std_logic; A_Greater, A_Equal, A_Smaller: out std_logic); end entity ; architecture behavioral of magnitude_comparator is begin process (A1, A0, B1, B0) variable a, b: integer range 0 to 3; begin if (A1 = '1' and A0 = '1') then a := 2; elsif (A1 = '1' and A0 = '0') then a := 1; else a := 0; end if ; if (B1 = '1' and B0 = '1') then b := 2; elsif (B1 = '1' and B0 = '0') then b := 1; else b := 0; end if ; if (a > b) then A_Greater <= '1'; A_Equal <= '0'; A_Smaller <= '0'; elsif (a = b) then A_Greater <= '0'; A_Equal <= '1'; A_Smaller <= '0'; else A_Greater <= '0'; A_Equal <= '0'; A_Smaller <= '1'; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity parity_checker is Port ( D3 : in STD_LOGIC; D2 : in STD_LOGIC; D1 : in STD_LOGIC; D0 : in STD_LOGIC; Even : out STD_LOGIC; Odd : out STD_LOGIC); end parity_checker; architecture Behavioral of parity_checker is begin process (D3, D2, D1, D0) variable parity: std_logic; begin parity := D3 xor D2 xor D1 xor D0; Even <= '1' when parity = '0' else '0'; Odd <= '1' when parity = '1' else '0'; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity barrel_shifter is Port ( In3 : in STD_LOGIC; In2 : in STD_LOGIC; In1 : in STD_LOGIC; In0 : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Shift_Amt : in STD_LOGIC_VECTOR (3 downto 0); Out3 : out STD_LOGIC; Out2 : out STD_LOGIC; Out1 : out STD_LOGIC; Out0 : out STD_LOGIC); end barrel_shifter; architecture Behavioral of barrel_shifter is begin process (In3, In2, In1, In0, Shift_Left, Shift_Right, Shift_Amt) variable temp : STD_LOGIC_VECTOR (3 downto 0); begin if (Shift_Left = '1') then temp := Shift_Amt & In3 & In2 & In1 & In0; elsif (Shift_Right = '1') then temp := In3 & In2 & In1 & In0 & Shift_Amt; else temp := In3 & In2 & In1 & In0; end if ; Out3 <= temp(3); Out2 <= temp(2); Out1 <= temp(1); Out0 <= temp(0); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity EdgeDetector is Port ( Signal_In : in STD_LOGIC; Rising_Edge : out STD_LOGIC; Falling_Edge : out STD_LOGIC); end EdgeDetector; architecture Behavioral of EdgeDetector is begin process (Signal_In) variable prev_signal : STD_LOGIC := '0'; begin if (Signal_In = '1' and prev_signal = '0') then Rising_Edge <= '1'; else Rising_Edge <= '0'; end if ; if (Signal_In = '0' and prev_signal = '1') then Falling_Edge <= '1'; else Falling_Edge <= '0'; end if ; prev_signal := Signal_In; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity majority_voter is port (A, B, C: in std_logic; Majority_Val: out std_logic); end entity ; architecture behavioral of majority_voter is begin Majority_Val <= A when A = B and A /= C else B when B = C and B /= A else C when C = A and C /= B else 'X'; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity ring_counter is Generic(N : integer := 8); Port(Clk : in std_logic; Rst : in std_logic; Ring_Count : out std_logic_vector(N-1 downto 0)); end entity ; architecture Behavioral of ring_counter is begin process (Clk, Rst) variable counter : integer range 0 to N-1; begin if (Rst = '1') then counter := 0; elsif (rising_edge(Clk)) then counter := counter + 1; if (counter = N-1) then counter := 0; end if ; end if ; Ring_Count <= std_logic_vector(to_unsigned(counter, N)); end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity johnson_counter is Generic(N : integer := 8); Port(Clock : in std_logic; Reset : in std_logic; Johnson_Count : out std_logic_vector(N-1 downto 0)); end entity ; architecture Behavioral of johnson_counter is begin process (Clock, Reset) variable count : integer range 0 to N-1 := 0; begin if (Reset = '1') then count := 0; elsif (rising_edge(Clock)) then count := count + 1; if (count = N-1) then count := 0; end if ; end if ; Johnson_Count <= std_logic_vector(to_unsigned(count, N)); end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity lfsr is generic (N : natural := 8); port ( Clk : in std_logic; Rst : in std_logic; Seed : in std_logic_vector(N-1 downto 0); LFSR_Out : out std_logic_vector(N-1 downto 0) ); end entity lfsr; architecture behavioral of lfsr is begin process (Clk, Rst) variable reg : std_logic_vector(N-1 downto 0); begin if (Rst = '1') then reg := Seed; elsif (rising_edge(Clk)) then reg := reg(N-2 downto 0) & reg(N-1); end if ; LFSR_Out <= reg; end process ; end architecture behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FiniteStateMachine is generic ( N: natural := 2; log2N: natural := 1 ); port ( clock: in std_logic; reset: in std_logic; inputs: in std_logic_vector((log2N-1) downto 0); state: out std_logic_vector((log2N-1) downto 0); outputs: out std_logic_vector((log2N-1) downto 0) ); end FiniteStateMachine; architecture Behavioral of FiniteStateMachine is begin process (clock, reset) variable state_reg: std_logic_vector((log2N-1) downto 0); variable outputs_reg: std_logic_vector((log2N-1) downto 0); begin if (reset = '1') then state_reg := (others => '0'); outputs_reg := (others => '0'); elsif (rising_edge(clock)) then case state_reg is when "00" => if (inputs(0) = '1') then state_reg := "01"; else state_reg := "00"; end if ; outputs_reg := "00"; when "01" => if (inputs(1) = '1') then state_reg := "10"; else state_reg := "01"; end if ; outputs_reg := "01"; when "10" => if (inputs(2) = '1') then state_reg := "11"; else state_reg := "10"; end if ; outputs_reg := "10"; when "11" => if (inputs(3) = '1') then state_reg := "00"; else state_reg := "11"; end if ; outputs_reg := "11"; when others => state_reg := (others => '0'); outputs_reg := (others => '0'); end case ; end if ; state <= state_reg; outputs <= outputs_reg; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity B2GConverter is generic (N : integer := 8); port (Binary : in std_logic_vector(N-1 downto 0); Gray_Code : out std_logic_vector(N-1 downto 0)); end B2GConverter; architecture Behavioral of B2GConverter is begin process (Binary) variable temp : std_logic_vector(N-1 downto 0); begin for i in 0 to N-1 loop if Binary(i) = '1' then temp(i) := '0'; else temp(i) := '1'; end if ; end loop ; Gray_Code <= temp; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity gray_to_binary is generic (N : natural := 8); port ( Gray_Code : in std_logic_vector(N-1 downto 0); Binary : out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of gray_to_binary is begin process (Gray_Code) variable tmp : std_logic_vector(N-1 downto 0); begin for i in 0 to N-1 loop if (i = 0) then tmp(i) := Gray_Code(i); else tmp(i) := Gray_Code(i) xor Gray_Code(i-1); end if ; end loop ; Binary <= tmp; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Dual_Port_FIFO is Generic ( M : integer := 8; N : integer := 32 ); Port ( Clk : in std_logic; Rst : in std_logic; Write_En : in std_logic; Read_En : in std_logic; Data_Write : in std_logic_vector(N-1 downto 0); Data_Read : out std_logic_vector(N-1 downto 0); Full_Flag : out std_logic; Empty_Flag : out std_logic ); end Dual_Port_FIFO; architecture Behavioral of Dual_Port_FIFO is type FIFO_Type is array (M-1 downto 0) of std_logic_vector(N-1 downto 0); signal FIFO : FIFO_Type := (others => (others => '0')); signal Write_Ptr, Read_Ptr : integer range 0 to M-1; begin process (Clk) begin if rising_edge(Clk) then if Rst = '1' then Write_Ptr <= 0; Read_Ptr <= 0; elsif Write_En = '1' and Full_Flag = '0' then FIFO(Write_Ptr) <= Data_Write; Write_Ptr <= (Write_Ptr + 1) mod M; end if ; end if ; end process ; process (Clk) begin if rising_edge(Clk) then if Read_En = '1' and Empty_Flag = '0' then Data_Read <= FIFO(Read_Ptr); Read_Ptr <= (Read_Ptr + 1) mod M; end if ; end if ; end process ; Full_Flag <= '1' when Write_Ptr = Read_Ptr and Write_En = '1' else '0'; Empty_Flag <= '1' when Write_Ptr = Read_Ptr and Read_En = '1' else '0'; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity BCD_to_Excess3 is Port ( BCD_In : in STD_LOGIC_VECTOR (3 downto 0); Excess3_Out : out STD_LOGIC_VECTOR (2 downto 0)); end BCD_to_Excess3; architecture Behavioral of BCD_to_Excess3 is begin process (BCD_In) variable Excess3 : std_logic_vector(2 downto 0); begin case BCD_In is when "0000" => Excess3 := "000"; when "0001" => Excess3 := "001"; when "0010" => Excess3 := "010"; when "0011" => Excess3 := "011"; when "0100" => Excess3 := "100"; when "0101" => Excess3 := "101"; when "0110" => Excess3 := "110"; when "0111" => Excess3 := "111"; when others => Excess3 := "000"; end case ; Excess3_Out <= Excess3; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Excess3ToBCDConverter is Port ( Excess3_In : in STD_LOGIC_VECTOR (3 downto 0); BCD_Out : out STD_LOGIC_VECTOR (3 downto 0)); end Excess3ToBCDConverter; architecture Behavioral of Excess3ToBCDConverter is begin process (Excess3_In) variable temp: STD_LOGIC_VECTOR (3 downto 0); begin case Excess3_In is when "000" => BCD_Out <= "0000"; when "001" => BCD_Out <= "0001"; when "010" => BCD_Out <= "0010"; when "011" => BCD_Out <= "0011"; when "100" => BCD_Out <= "0100"; when "101" => BCD_Out <= "0101"; when "110" => BCD_Out <= "0110"; when "111" => BCD_Out <= "0111"; when others => BCD_Out <= "XXXX"; end case ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity HammingEncoder is port ( Data_In : in std_logic_vector(3 downto 0); Encoded : out std_logic_vector(6 downto 0) ); end entity ; architecture Behavioral of HammingEncoder is begin Encoded <= "1" & Data_In(3 downto 0); end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity HammingDecoder is Port ( Encoded : in STD_LOGIC_VECTOR (7 downto 0); Data_Out : out STD_LOGIC_VECTOR (3 downto 0); Error_Detected : out STD_LOGIC; clk : in STD_LOGIC; rst : in STD_LOGIC); end HammingDecoder; architecture Behavioral of HammingDecoder is begin process (clk, rst) variable error_detected : boolean := false; variable data_out : std_logic_vector(3 downto 0); begin if (rst = '1') then error_detected := false; data_out := (others => '0'); elsif (rising_edge(clk)) then case Encoded is when "0000000" => data_out := "0000"; when "0000001" => data_out := "0001"; when "0000010" => data_out := "0010"; when "0000011" => data_out := "0011"; when "0000100" => data_out := "0100"; when "0000101" => data_out := "0101"; when "0000110" => data_out := "0110"; when "0000111" => data_out := "0111"; when "0001000" => data_out := "1000"; when "0001001" => data_out := "1001"; when "0001010" => data_out := "1010"; when "0001011" => data_out := "1011"; when "0001100" => data_out := "1100"; when "0001101" => data_out := "1101"; when "0001110" => data_out := "1110"; when "0001111" => data_out := "1111"; when others => error_detected := true; end case ; end if ; Data_Out <= data_out; Error_Detected <= error_detected; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity crc_generator is generic (N : natural := 8); port ( clk : in std_logic; rst : in std_logic; data_in : in std_logic_vector(N-1 downto 0); polynomial: in std_logic_vector(M-1 downto 0); crc_value: out std_logic_vector(M-1 downto 0) ); end entity ; architecture behavioral of crc_generator is begin process (clk, rst) variable reg : std_logic_vector(N-1 downto 0); variable poly : std_logic_vector(M-1 downto 0); begin if rising_edge(clk) then if rst = '1' then reg := (others => '0'); else reg := data_in; end if ; poly := polynomial; for i in 0 to N-1 loop if poly(i) = '1' then reg := reg xor data_in; end if ; end loop ; crc_value <= reg; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity crc_checker is generic (N : natural := 32; M : natural := 8); port (Data_In : in std_logic_vector(N-1 downto 0); Received_CRC : in std_logic_vector(M-1 downto 0); Polynomial : in std_logic_vector(M-1 downto 0); CRC_Match : out std_logic); end entity ; architecture behavioral of crc_checker is signal data_reg : std_logic_vector(N-1 downto 0); signal received_crc_reg : std_logic_vector(M-1 downto 0); signal polynomial_reg : std_logic_vector(M-1 downto 0); signal crc_match_reg : std_logic; begin process (Data_In, Received_CRC, Polynomial) variable data_poly_xor : std_logic_vector(N-1 downto 0); variable received_crc_poly_xor : std_logic_vector(M-1 downto 0); begin data_poly_xor := Data_In xor Polynomial; received_crc_poly_xor := Received_CRC xor Polynomial; crc_match_reg <= '1' when data_poly_xor = received_crc_poly_xor else '0'; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity ps_converter is generic (N : natural := 8); port ( Clk : in std_logic; Parallel_In : in std_logic_vector(N-1 downto 0); Load_En : in std_logic; Serial_Out : out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of ps_converter is begin process (Clk, Parallel_In, Load_En) begin if rising_edge(Clk) then if Load_En = '1' then Serial_Out <= Parallel_In; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity serial_to_parallel_converter is generic (N: natural := 8); port ( Clk: in std_logic; Serial_In: in std_logic_vector(N-1 downto 0); Shift_En: in std_logic; Parallel_Out: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of serial_to_parallel_converter is begin process (Clk) variable temp: std_logic_vector(N-1 downto 0); begin if rising_edge(Clk) then if Shift_En = '1' then temp := Serial_In; Parallel_Out <= temp; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FloatingPointAdder is generic ( N : natural := 32 ); port ( A, B: in std_logic_vector(N-1 downto 0); Sum: out std_logic_vector(N-1 downto 0) ); end entity ; architecture Behavioral of FloatingPointAdder is begin process (A, B) begin for i in A'range loop Sum(i) <= A(i) xor B(i); end loop ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity floating_point_multiplier is generic ( N : natural := 32; P : natural := 8; R : natural := 23 ); port ( A, B: in std_logic_vector(N-1 downto 0); Product: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of floating_point_multiplier is begin process (A, B) variable temp : std_logic_vector(N-1 downto 0); begin temp := A * B; Product <= temp; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity fixed_point_divider is generic ( N: natural := 8; R: natural := 2; S: natural := 16 ); port ( clk: in std_logic; rst: in std_logic; dividend: in signed(N-1 downto 0); divisor: in signed(N-1 downto 0); quotient: out signed(R-1 downto 0); remainder: out signed(R-1 downto 0) ); end entity ; architecture behavioral of fixed_point_divider is signal accumulator: signed(S-1 downto 0); begin process (clk, rst) begin if (rst = '1') then accumulator <= (others => '0'); elsif (rising_edge(clk)) then accumulator <= accumulator + dividend; quotient <= accumulator(R-1 downto 0); remainder <= accumulator(S-1 downto R+1); end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity signed_multiplier is generic (N : natural := 8); port (A, B: in std_logic_vector(N-1 downto 0); Product: out std_logic_vector((2*N)-1 downto 0)); end entity ; architecture behavioral of signed_multiplier is begin Product <= A * B; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity UnsignedDivider is generic ( N: natural := 8; Q: natural := 8; R: natural := 8; P: natural := 16 ); port ( clk: in std_logic; rst: in std_logic; numerator: in unsigned(N-1 downto 0); denominator: in unsigned(N-1 downto 0); quotient: out unsigned(Q-1 downto 0); remainder: out unsigned(R-1 downto 0) ); end UnsignedDivider; architecture Behavioral of UnsignedDivider is signal partial_product: unsigned(P-1 downto 0); begin process (clk, rst) variable quotient_tmp: unsigned(Q-1 downto 0); variable remainder_tmp: unsigned(R-1 downto 0); begin if (rst = '1') then quotient <= (others => '0'); remainder <= (others => '0'); elsif (rising_edge(clk)) then partial_product <= numerator * denominator; quotient_tmp := partial_product(Q-1 downto 0); remainder_tmp := partial_product(P-1 downto Q); quotient <= quotient_tmp; remainder <= remainder_tmp; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PipelinedMultiplier is generic ( N: natural := 8; M: natural := 8; R: natural := 2; W: natural := 32 ); port ( Clk: in std_logic; Factor1: in std_logic_vector(N-1 downto 0); Factor2: in std_logic_vector(M-1 downto 0); Product: out std_logic_vector(N+M-1 downto 0) ); end PipelinedMultiplier; architecture Behavioral of PipelinedMultiplier is type StateType is (Idle, Multiply, Write); signal State: StateType; signal Count: natural range 0 to R-1; signal ProductReg: std_logic_vector(W-1 downto 0); begin process (Clk) variable Result: std_logic_vector(N+M-1 downto 0); begin if rising_edge(Clk) then case State is when Idle => Count <= 0; ProductReg <= (others => '0'); Result := std_logic_vector(unsigned(Factor1) * unsigned(Factor2)); State <= Multiply; when Multiply => if Count < R-1 then Result := std_logic_vector(unsigned(Result) + unsigned(Factor1) * unsigned(Factor2)); Count <= Count + 1; else ProductReg <= Result; State <= Write; end if ; when Write => Product <= ProductReg; State <= Idle; end case ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity fixed_to_float is generic (N : natural := 8; M : natural := 32); port (Fixed_Value: in std_logic_vector(N-1 downto 0); Float_Value: out std_logic_vector(M-1 downto 0)); end entity ; architecture behavioral of fixed_to_float is begin process (Fixed_Value) variable frac : unsigned(M-N-1 downto 0); variable exp : integer range 0 to M-1; begin frac := resize(unsigned(Fixed_Value), M-N); exp := N - 1; Float_Value <= std_logic_vector(to_float(frac, exp)); end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity BCD_to_Binary is generic (N: natural := 8); port (BCD_Value: in std_logic_vector(N/4-1 downto 0); Binary_Value: out std_logic_vector(N-1 downto 0)); end BCD_to_Binary; architecture Behavioral of BCD_to_Binary is begin process (BCD_Value) variable temp: std_logic_vector(N/4-1 downto 0); begin for i in 0 to N/4-1 loop case BCD_Value(i) is when "0" => temp(i) := '0'; when "1" => temp(i) := '1'; when "2" => temp(i) := '2'; when "3" => temp(i) := '3'; when "4" => temp(i) := '4'; when "5" => temp(i) := '5'; when "6" => temp(i) := '6'; when "7" => temp(i) := '7'; when "8" => temp(i) := '8'; when "9" => temp(i) := '9'; end case ; end loop ; Binary_Value <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity bcd_converter is generic (N: natural := 8); port ( Binary_Value: in std_logic_vector(N-1 downto 0); BCD_Value: out std_logic_vector((N/3)+1-1 downto 0) ); end entity ; architecture Behavioral of bcd_converter is begin process (Binary_Value) variable temp: std_logic_vector(N-1 downto 0); variable BCD: std_logic_vector((N/3)+1-1 downto 0); begin for i in 0 to N-1 loop if Binary_Value(i) = '1' then temp := temp + (2**i); end if ; end loop ; BCD := temp mod 10; BCD_Value <= BCD; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity shift_register is generic (N : natural := 8); port ( clk : in std_logic; load : in std_logic; shift_en: in std_logic; shift_dir: in std_logic; parallel_in: in std_logic_vector(N-1 downto 0); parallel_out: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of shift_register is begin process (clk, load, shift_en, shift_dir, parallel_in) variable temp : std_logic_vector(N-1 downto 0); begin if (rising_edge(clk)) then if (load = '1') then temp := parallel_in; elsif (shift_en = '1' and shift_dir = '0') then temp := temp(N-2 downto 0) & temp(N-1); elsif (shift_en = '1' and shift_dir = '1') then temp := temp(N-1 downto 1) & temp(0); end if ; end if ; parallel_out <= temp; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity JohnsonRingCounter is generic (N : natural := 8); port (Clk, Reset: in std_logic; Johnson_Count: out std_logic_vector(N-1 downto 0)); end JohnsonRingCounter; architecture Behavioral of JohnsonRingCounter is begin process (Clk) variable count : natural range 0 to N-1 := 0; begin if (Reset = '1') then count := 0; elsif (rising_edge(Clk)) then count := count + 1; if (count = N-1) then count := 0; end if ; end if ; Johnson_Count <= std_logic_vector(to_unsigned(count, N)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity PRNG is Generic(N: integer := 32); Port(Clock: in std_logic; Seed: in std_logic_vector(N-1 downto 0); Random_Number: out std_logic_vector(N-1 downto 0)); end PRNG; architecture Behavioral of PRNG is begin process (Clock) variable seed_reg: std_logic_vector(N-1 downto 0); variable random_number_reg: std_logic_vector(N-1 downto 0); begin if (rising_edge(Clock)) then random_number_reg := seed_reg; for i in 0 to N-1 loop if (random_number_reg(i) = '0') then random_number_reg(i) <= '1'; else random_number_reg(i) <= '0'; end if ; end loop ; seed_reg := random_number_reg; end if ; Random_Number <= random_number_reg; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity IIRFilter is generic ( N: natural := 8; M: natural := 3 ); port ( clk: in std_logic; rst: in std_logic; Input_Data: in std_logic_vector(N-1 downto 0); Coeffs: in std_logic_vector(M*N-1 downto 0); Filtered_Data: out std_logic_vector(N-1 downto 0) ); end IIRFilter; architecture Behavioral of IIRFilter is begin process (clk, rst) variable x: std_logic_vector(N-1 downto 0); variable y: std_logic_vector(N-1 downto 0); variable c: std_logic_vector(M*N-1 downto 0); begin if rst = '1' then x := (others => '0'); y := (others => '0'); c := (others => '0'); elsif rising_edge(clk) then x := Input_Data; c := Coeffs; for i in 0 to M-1 loop y := y + c(i*N+N-1 downto i*N) * x; end loop ; end if ; Filtered_Data <= y; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PID_Controller is generic ( N : natural := 8 ); port ( Clk : in std_logic; Rst : in std_logic; Set_Point : in signed(N-1 downto 0); Process_Value : in signed(N-1 downto 0); Kp : in signed(N-1 downto 0); Ki : in signed(N-1 downto 0); Kd : in signed(N-1 downto 0); Control_Output : out signed(N-1 downto 0) ); end entity ; architecture Behavioral of PID_Controller is begin process (Clk, Rst) variable error : signed(N-1 downto 0); variable integral : signed(N-1 downto 0); variable derivative : signed(N-1 downto 0); begin if (Rst = '1') then error := (others => '0'); integral := (others => '0'); derivative := (others => '0'); elsif (rising_edge(Clk)) then error := Set_Point - Process_Value; integral := integral + error; derivative := derivative + error - previous_error; Control_Output <= Kp * error + Ki * integral + Kd * derivative; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity DigitalIntegrator is generic ( N : natural := 8 ); port ( clk, reset : in std_logic; input_data : in std_logic_vector(N-1 downto 0); integrated_data : out std_logic_vector(N-1 downto 0) ); end DigitalIntegrator; architecture Behavioral of DigitalIntegrator is begin process (clk, reset) variable temp : std_logic_vector(N-1 downto 0); begin if (reset = '1') then temp := (others => '0'); elsif (rising_edge(clk)) then temp := input_data; end if ; integrated_data <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Digital_Differentiator is Generic(N: integer := 8); Port(Clk: in std_logic; Input_Data: in std_logic_vector(N-1 downto 0); Differentiated_Data: out std_logic_vector(N-1 downto 0)); end Digital_Differentiator; architecture Behavioral of Digital_Differentiator is begin process (Clk) variable temp: std_logic_vector(N-1 downto 0); begin if (rising_edge(Clk)) then temp := Input_Data; Differentiated_Data <= temp(N-2 downto 0) & '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PWM_Generator is generic ( N: natural := 8 ); port ( Clock: in std_logic; Reset: in std_logic; Duty_Cycle: in std_logic_vector(N-1 downto 0); PWM_Out: out std_logic ); end entity ; architecture Behavioral of PWM_Generator is begin process (Clock, Reset) variable duty_cycle_reg: std_logic_vector(N-1 downto 0); variable pwm_out_reg: std_logic; begin if (Reset = '1') then duty_cycle_reg := (others => '0'); pwm_out_reg := '0'; elsif (rising_edge(Clock)) then duty_cycle_reg := Duty_Cycle; if (duty_cycle_reg = "1") then pwm_out_reg <= not pwm_out_reg; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity FrequencyDivider is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Divide_Ratio : in STD_LOGIC_VECTOR (N-1 downto 0); Divided_Clk : out STD_LOGIC); end FrequencyDivider; architecture Behavioral of FrequencyDivider is begin process (Clk, Reset) variable counter : integer range 0 to N; begin if (Reset = '1') then counter := 0; elsif (rising_edge(Clk)) then counter := counter + 1; if (counter = Divide_Ratio) then counter := 0; Divided_Clk <= not Divided_Clk; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; entity edge_detector is port ( signal_in : in std_logic; rising_edge_pulse : out std_logic; falling_edge_pulse : out std_logic ); end entity ; architecture behavioral of edge_detector is begin process (signal_in) variable last_value : std_logic := '0'; begin if signal_in'event then if signal_in = '1' and last_value = '0' then rising_edge_pulse <= '1'; elsif signal_in = '0' and last_value = '1' then falling_edge_pulse <= '1'; else rising_edge_pulse <= '0'; falling_edge_pulse <= '0'; end if ; last_value := signal_in; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity glitch_filter is port ( Noisy_In : in std_logic; Filtered_Out : out std_logic ); end entity ; architecture behavioral of glitch_filter is begin process (Noisy_In) begin if rising_edge(Noisy_In) then Filtered_Out <= '1'; else Filtered_Out <= '0'; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity debounce_circuit is Port ( button_in : in STD_LOGIC; debounced_pulse : out STD_LOGIC); end debounce_circuit; architecture Behavioral of debounce_circuit is begin process (button_in) variable counter : integer range 0 to 10 := 0; begin if (button_in = '1') then counter := counter + 1; if (counter >= 5) then debounced_pulse <= '1'; end if ; else counter := 0; debounced_pulse <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.all; entity Schmitt_Trigger is port ( Analog_In : in std_logic; Digital_Out : out std_logic ); end entity ; architecture Behavioral of Schmitt_Trigger is begin Digital_Out <= '1' when Analog_In > 0.5 else '0'; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity pulse_generator is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Pulse_Width : in STD_LOGIC_VECTOR (N-1 downto 0); Pulse_Out : out STD_LOGIC); end pulse_generator; architecture Behavioral of pulse_generator is begin process (Clk, Reset) variable counter : integer range 0 to 2**N-1 := 0; begin if (Reset = '1') then Pulse_Out <= '0'; elsif (rising_edge(Clk)) then if (counter < 2**N-1) then counter := counter + 1; else counter := 0; end if ; Pulse_Out <= '1' when (counter = Pulse_Width) else '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity MonostableMultivibrator is generic ( N: natural := 8; TRIGGER_IN: std_logic := '0'; PULSE_OUT: std_logic := '1' ); port ( clk: in std_logic; rst: in std_logic; pulse_duration: in unsigned(N-1 downto 0); trigger_in: in std_logic := '0'; pulse_out: out std_logic := '1' ); end MonostableMultivibrator; architecture Behavioral of MonostableMultivibrator is begin process (clk, rst) variable counter: unsigned(N-1 downto 0); begin if (rst = '1') then pulse_out <= '0'; counter := (others => '0'); elsif (rising_edge(clk)) then if (trigger_in = '1') then pulse_out <= '1'; counter := pulse_duration; else if (counter > 0) then counter := counter - 1; else pulse_out <= '0'; end if ; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity AsynchronousMultivibrator is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Oscillating_Out : out STD_LOGIC); end AsynchronousMultivibrator; architecture Behavioral of AsynchronousMultivibrator is begin process (Clk, Reset) variable state: std_logic := '0'; begin if (Reset = '1') then state := '0'; elsif (rising_edge(Clk)) then state := not state; end if ; Oscillating_Out <= state; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Counter_Nbit is Generic(N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Enable : in STD_LOGIC; Q : out STD_LOGIC_VECTOR (N-1 downto 0)); end Counter_Nbit; architecture Behavioral of Counter_Nbit is signal count : unsigned(N-1 downto 0) := (others => '0'); begin process (Clock, Reset, Enable) begin if Reset = '1' then count <= (others => '0'); elsif rising_edge(Clock) and Enable = '1' then count <= count + 1; end if ; end process ; Q <= std_logic_vector(count); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Register_NBit is Generic(N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Enable : in STD_LOGIC; D : in STD_LOGIC_VECTOR (N-1 downto 0); Q : out STD_LOGIC_VECTOR (N-1 downto 0)); end Register_NBit; architecture Behavioral of Register_NBit is begin process (Clock, Reset) begin if Reset = '1' then Q <= (others => '0'); elsif rising_edge(Clock) and Enable = '1' then Q <= D; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity shift_register is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Serial_In : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Shift_Direction : in STD_LOGIC; Parallel_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end shift_register; architecture Behavioral of shift_register is signal reg: STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clock, Reset) begin if Reset = '1' then reg <= (others => '0'); elsif rising_edge(Clock) and Shift_Enable = '1' then if Shift_Direction = '0' then reg <= reg(N-2 downto 0) & Serial_In; else reg <= Serial_In & reg(N-1 downto 1); end if ; end if ; end process ; Parallel_Out <= reg; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ROM is Generic( M : integer := 8; N : integer := 32 ); Port ( Address : in STD_LOGIC_VECTOR (log2M-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (N-1 downto 0) ); end ROM; architecture Behavioral of ROM is type rom_type is array(0 to M-1) of std_logic_vector(N-1 downto 0); constant myROM : rom_type := ( "00000000000000000000000000000000", "00000000000000000000000000000001", "11111111111111111111111111111111" ); begin process (Address) begin Data_Out <= myROM(to_integer(unsigned(Address))); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Multiplexer is Generic(N : positive := 2; M : positive := 8); Port ( Select : in STD_LOGIC_VECTOR (log2(N)-1 downto 0); Data : in STD_LOGIC_VECTOR ((N*M)-1 downto 0); Output : out STD_LOGIC_VECTOR (M-1 downto 0)); end Multiplexer; architecture Behavioral of Multiplexer is begin process (Select, Data) variable index : integer := to_integer(unsigned(Select)); begin Output <= Data((index+1)*M-1 downto index*M); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity demultiplexer is Generic(N : natural := 2; M : natural := 8); Port ( Select : in STD_LOGIC_VECTOR (log2N-1 downto 0); Data_In : in STD_LOGIC_VECTOR ((N*M)-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (M-1 downto 0)); end demultiplexer; architecture Behavioral of demultiplexer is begin process (Select, Data_In) begin for i in 0 to N-1 loop if Select = std_logic_vector(to_unsigned(i, log2N)) then Data_Out <= Data_In((i+1)*M-1 downto i*M); end if ; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Adder is Generic ( N : natural := 8 ); Port ( A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (N-1 downto 0); Carry_In : in STD_LOGIC; Sum : out STD_LOGIC_VECTOR (N-1 downto 0); Carry_Out : out STD_LOGIC); end Adder; architecture Behavioral of Adder is begin process (A, B, Carry_In) variable tempSum : STD_LOGIC_VECTOR (N downto 0); begin tempSum := (others => '0'); for i in 0 to N-1 loop tempSum(i) := A(i) xor B(i) xor Carry_In; Carry_Out <= (A(i) and B(i)) or (B(i) and Carry_In) or (A(i) and Carry_In); end loop ; Sum <= tempSum(N-1 downto 0); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Subtractor is Generic ( N : natural := 8 ); Port ( A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (N-1 downto 0); Borrow_In : in STD_LOGIC; Difference : out STD_LOGIC_VECTOR (N-1 downto 0); Borrow_Out : out STD_LOGIC); end Subtractor; architecture Behavioral of Subtractor is begin process (A, B, Borrow_In) variable borrow: std_logic := Borrow_In; variable diff: std_logic_vector(N-1 downto 0); begin for i in 0 to N-1 loop diff(i) := A(i) xor B(i) xor borrow; borrow := (not A(i)) and (B(i) or borrow); end loop ; Difference <= diff; Borrow_Out <= borrow; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Multiplier is Generic ( N : natural := 8; M : natural := 8 ); Port ( A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (M-1 downto 0); Product : out STD_LOGIC_VECTOR ((N+M)-1 downto 0)); end Multiplier; architecture Behavioral of Multiplier is begin Product <= std_logic_vector(signed(A) * signed(B)); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Divider is Generic(N : natural := 8; M : natural := 3); Port ( Dividend : in STD_LOGIC_VECTOR (N-1 downto 0); Divisor : in STD_LOGIC_VECTOR (M-1 downto 0); Quotient : out STD_LOGIC_VECTOR (N-M+1-1 downto 0); Remainder : out STD_LOGIC_VECTOR (M-1 downto 0)); end Divider; architecture Behavioral of Divider is begin process (Dividend, Divisor) variable temp_quotient : STD_LOGIC_VECTOR (N-M+1-1 downto 0); variable temp_remainder : STD_LOGIC_VECTOR (M-1 downto 0); begin temp_quotient := (others => '0'); temp_remainder := Dividend; for i in 0 to N-M loop if temp_remainder >= Divisor then temp_quotient(i) := '1'; temp_remainder := temp_remainder - Divisor; end if ; end loop ; Quotient <= temp_quotient; Remainder <= temp_remainder; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity BarrelShifter is Generic(N : natural := 8); Port ( Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Shift_Direction : in STD_LOGIC; Shift_Value : in STD_LOGIC_VECTOR (log2(N)-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (Data_In, Shift_Direction, Shift_Value) variable temp : unsigned(N-1 downto 0); begin temp := unsigned(Data_In); if Shift_Direction = '0' then temp := shift_left(temp, to_integer(unsigned(Shift_Value))); else temp := shift_right(temp, to_integer(unsigned(Shift_Value))); end if ; Data_Out <= std_logic_vector(temp); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity priority_encoder is Generic(N : positive := 8); Port ( request : in STD_LOGIC_VECTOR (N-1 downto 0); grant : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); valid : out STD_LOGIC); end priority_encoder; architecture Behavioral of priority_encoder is begin process (request) variable max_index : natural := N-1; begin valid <= '0'; grant <= (others => '0'); for i in 0 to N-1 loop if request(i) = '1' then max_index := i; exit; end if ; end loop ; if max_index < N then valid <= '1'; grant <= std_logic_vector(to_unsigned(max_index, log2(N))); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity fifo is Generic (N : integer := 8; M : integer := 16); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Write_Enable : in STD_LOGIC; Read_Enable : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (M-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (M-1 downto 0); Full : out STD_LOGIC; Empty : out STD_LOGIC); end fifo; architecture Behavioral of fifo is type mem_array is array(0 to N-1) of STD_LOGIC_VECTOR (M-1 downto 0); signal memory : mem_array := (others => (others => '0')); signal write_ptr, read_ptr : integer range 0 to N-1 := 0; begin process (Clock) begin if rising_edge(Clock) then if Reset = '1' then write_ptr <= 0; read_ptr <= 0; Full <= '0'; Empty <= '1'; elsif Write_Enable = '1' and Full = '0' then memory(write_ptr) <= Data_In; write_ptr := (write_ptr + 1) mod N; if write_ptr = read_ptr then Full <= '1'; end if ; Empty <= '0'; elsif Read_Enable = '1' and Empty = '0' then Data_Out <= memory(read_ptr); read_ptr := (read_ptr + 1) mod N; if write_ptr = read_ptr then Empty <= '1'; end if ; Full <= '0'; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity FullAdder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; Carry_In : in STD_LOGIC; Sum : out STD_LOGIC; Carry_Out : out STD_LOGIC); end FullAdder; architecture Behavioral of FullAdder is begin Sum <= A XOR B XOR Carry_In; Carry_Out <= (A AND B) OR (B AND Carry_In) OR (A AND Carry_In); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity HalfAdder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; Sum : out STD_LOGIC; Carry_Out : out STD_LOGIC); end HalfAdder; architecture Behavioral of HalfAdder is begin Sum <= A xor B; Carry_Out <= A and B; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity decoder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; D0 : out STD_LOGIC; D1 : out STD_LOGIC; D2 : out STD_LOGIC; D3 : out STD_LOGIC); end decoder; architecture Behavioral of decoder is begin process (A, B) begin if A = '0' and B = '0' then D0 <= '1'; D1 <= '0'; D2 <= '0'; D3 <= '0'; elsif A = '0' and B = '1' then D0 <= '0'; D1 <= '1'; D2 <= '0'; D3 <= '0'; elsif A = '1' and B = '0' then D0 <= '0'; D1 <= '0'; D2 <= '1'; D3 <= '0'; else D0 <= '0'; D1 <= '0'; D2 <= '0'; D3 <= '1'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Encoder is Port ( D0 : in STD_LOGIC; D1 : in STD_LOGIC; D2 : in STD_LOGIC; D3 : in STD_LOGIC; A : out STD_LOGIC; B : out STD_LOGIC; Valid : out STD_LOGIC); end Encoder; architecture Behavioral of Encoder is begin process (D0, D1, D2, D3) begin case (D0 & D1 & D2 & D3) is when "0000" => A <= '0'; B <= '0'; Valid <= '0'; when "0001" => A <= '0'; B <= '1'; Valid <= '1'; when "0010" => A <= '1'; B <= '0'; Valid <= '1'; when "0011" => A <= '1'; B <= '1'; Valid <= '1'; when others => A <= 'X'; B <= 'X'; Valid <= 'X'; end case ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity up_down_counter is Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; UpDown : in STD_LOGIC; Enable : in STD_LOGIC; Q0, Q1, Q2, Q3 : out STD_LOGIC); end up_down_counter; architecture Behavioral of up_down_counter is signal count: unsigned(3 downto 0) := (others => '0'); begin process (Clock, Reset, Enable) begin if Reset = '1' then count <= (others => '0'); elsif rising_edge(Clock) and Enable = '1' then if UpDown = '1' then count <= count + 1; else count <= count - 1; end if ; end if ; end process ; Q0 <= count(0); Q1 <= count(1); Q2 <= count(2); Q3 <= count(3); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Comparator_2bit is Port ( A1 : in STD_LOGIC; A0 : in STD_LOGIC; B1 : in STD_LOGIC; B0 : in STD_LOGIC; A_GT_B : out STD_LOGIC; A_EQ_B : out STD_LOGIC; A_LT_B : out STD_LOGIC); end Comparator_2bit; architecture Behavioral of Comparator_2bit is begin A_GT_B <= '1' when (A1 > B1) else '0'; A_EQ_B <= '1' when (A1 = B1 and A0 = B0) else '0'; A_LT_B <= '1' when (A1 < B1) else '0'; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity BarrelShifter is Port ( A3 : in STD_LOGIC; A2 : in STD_LOGIC; A1 : in STD_LOGIC; A0 : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Value : in STD_LOGIC_VECTOR (2 downto 0); Q3 : out STD_LOGIC; Q2 : out STD_LOGIC; Q1 : out STD_LOGIC; Q0 : out STD_LOGIC); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (A3, A2, A1, A0, Shift_Left, Shift_Value) variable temp : STD_LOGIC_VECTOR (3 downto 0); begin temp := A3 & A2 & A1 & A0; if Shift_Left = '1' then Q3 <= temp(to_integer(unsigned(Shift_Value)) + 3); Q2 <= temp(to_integer(unsigned(Shift_Value)) + 2); Q1 <= temp(to_integer(unsigned(Shift_Value)) + 1); Q0 <= temp(to_integer(unsigned(Shift_Value))); else Q3 <= temp(3 - to_integer(unsigned(Shift_Value))); Q2 <= temp(2 - to_integer(unsigned(Shift_Value))); Q1 <= temp(1 - to_integer(unsigned(Shift_Value))); Q0 <= temp(0 - to_integer(unsigned(Shift_Value))); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity loadable_register is Generic ( M : natural := 8 ); Port ( Clock : in STD_LOGIC; Load_Enable : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (M-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (M-1 downto 0)); end loadable_register; architecture Behavioral of loadable_register is begin process (Clock, Load_Enable) begin if rising_edge(Clock) then if Load_Enable = '1' then Data_Out <= Data_In; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity UniversalShiftRegister is Port ( Clock : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Shift_Direction : in STD_LOGIC; Serial_In : in STD_LOGIC; Parallel_Out : out STD_LOGIC_VECTOR (P-1 downto 0); Serial_Out : out STD_LOGIC); end UniversalShiftRegister; architecture Behavioral of UniversalShiftRegister is signal shiftReg: STD_LOGIC_VECTOR(P-1 downto 0) := (others => '0'); begin process (Clock, Shift_Enable) begin if rising_edge(Clock) and Shift_Enable = '1' then if Shift_Direction = '0' then shiftReg <= shiftReg(P-2 downto 0) & Serial_In; else shiftReg <= Serial_In & shiftReg(P-1 downto 1); end if ; end if ; end process ; Parallel_Out <= shiftReg; Serial_Out <= shiftReg(0); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity dual_port_ram is Generic ( K : natural := 8; L : natural := 32 ); Port ( Clock : in STD_LOGIC; Write_Enable : in STD_LOGIC; Read_Enable : in STD_LOGIC; Write_Address : in unsigned(log2(K)-1 downto 0); Read_Address : in unsigned(log2(K)-1 downto 0); Data_In : in STD_LOGIC_VECTOR (L-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (L-1 downto 0) ); end dual_port_ram; architecture Behavioral of dual_port_ram is type ram_type is array (0 to K-1) of std_logic_vector(L-1 downto 0); signal RAM : ram_type := (others => (others => '0')); begin process (Clock, Write_Enable, Read_Address, Data_In) begin if rising_edge(Clock) then if Write_Enable = '1' then RAM(to_integer(Write_Address)) <= Data_In; end if ; end if ; Data_Out <= RAM(to_integer(Read_Address)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity ProgrammableROM is Generic (M : natural := 8; N : natural := 32); Port ( Address : in STD_LOGIC_VECTOR (log2(M)-1 downto 0); Program_Enable : in STD_LOGIC; Program_Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end ProgrammableROM; architecture Behavioral of ProgrammableROM is type ROM_Type is array(0 to M-1) of STD_LOGIC_VECTOR(N-1 downto 0); signal ROM : ROM_Type := (others => (others => '0')); begin process (Address, Program_Enable, Program_Data_In) begin if Program_Enable = '1' then ROM(to_integer(unsigned(Address))) <= Program_Data_In; end if ; Data_Out <= ROM(to_integer(unsigned(Address))); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity binary_decoder is Port ( Enable : in STD_LOGIC; Code : in STD_LOGIC_VECTOR (N-1 downto 0); Decoded_Output : out STD_LOGIC_VECTOR ((2**N)-1 downto 0)); end binary_decoder; architecture Behavioral of binary_decoder is begin process (Enable, Code) begin if Enable = '1' then Decoded_Output <= (others => '0'); Decoded_Output((2**N)-1 downto 0)(to_integer(unsigned(Code))) <= '1'; else Decoded_Output <= (others => '0'); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity priority_encoder is Generic(M : integer := 8); Port ( Request : in STD_LOGIC_VECTOR (2**M-1 downto 0); Encoded_Output : out STD_LOGIC_VECTOR (M-1 downto 0); Valid : out STD_LOGIC); end priority_encoder; architecture Behavioral of priority_encoder is begin process (Request) variable temp : integer := 0; begin Valid <= '0'; for i in M-1 downto 0 loop if Request(2**i - 1) = '1' then Encoded_Output <= std_logic_vector(to_unsigned(i, M)); Valid <= '1'; exit; end if ; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Multiplexer is Generic (P : natural := 2; Q : natural := 8); Port ( Select : in STD_LOGIC_VECTOR (P-1 downto 0); Data_Input : in STD_LOGIC_VECTOR ((2**P)-1 downto 0)(Q-1 downto 0); Data_Output : out STD_LOGIC_VECTOR (Q-1 downto 0)); end Multiplexer; architecture Behavioral of Multiplexer is begin process (Select, Data_Input) begin Data_Output <= Data_Input(to_integer(unsigned(Select))); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Demultiplexer is Generic(R : natural := 3; S : natural := 8); Port ( Select : in STD_LOGIC_VECTOR (R-1 downto 0); Data_In : in STD_LOGIC_VECTOR ((2**R)*S-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (S-1 downto 0)); end Demultiplexer; architecture Behavioral of Demultiplexer is begin process (Select, Data_In) variable index : natural := 0; begin for i in 0 to 2**R-1 loop if Select = std_logic_vector(to_unsigned(i, R)) then index := i*S; Data_Out <= Data_In(index+S-1 downto index); end if ; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity RippleCarryAdder is Generic ( N : natural := 8 ); Port ( Augend : in STD_LOGIC_VECTOR (N-1 downto 0); Addend : in STD_LOGIC_VECTOR (N-1 downto 0); Carry_In : in STD_LOGIC; Sum : out STD_LOGIC_VECTOR (N-1 downto 0); Carry_Out : out STD_LOGIC); end RippleCarryAdder; architecture Behavioral of RippleCarryAdder is signal carry : STD_LOGIC_VECTOR(N downto 0) := (others => '0'); begin process (Augend, Addend, Carry_In) variable tempSum : STD_LOGIC_VECTOR(N-1 downto 0); begin tempSum := Augend xor Addend; carry <= (Augend and Addend) or (Carry_In and tempSum); Sum <= tempSum; Carry_Out <= carry(N); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ParallelSubtractor is Generic ( M : natural := 8 ); Port ( Minuend : in STD_LOGIC_VECTOR (M-1 downto 0); Subtrahend : in STD_LOGIC_VECTOR (M-1 downto 0); Borrow_In : in STD_LOGIC; Difference : out STD_LOGIC_VECTOR (M-1 downto 0); Borrow_Out : out STD_LOGIC); end ParallelSubtractor; architecture Behavioral of ParallelSubtractor is begin process (Minuend, Subtrahend, Borrow_In) variable borrow : std_logic := Borrow_In; begin for i in 0 to M-1 loop Difference(i) <= Minuend(i) xor Subtrahend(i) xor borrow; borrow := (Minuend(i) and Subtrahend(i)) or (borrow and (Minuend(i) or Subtrahend(i))); end loop ; Borrow_Out <= borrow; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity sequential_multiplier is Generic ( P : natural := 8; Q : natural := 8 ); Port ( clk : in STD_LOGIC; multiplicand : in STD_LOGIC_VECTOR (P-1 downto 0); multiplier : in STD_LOGIC_VECTOR (Q-1 downto 0); product : out STD_LOGIC_VECTOR ((P+Q)-1 downto 0) ); end sequential_multiplier; architecture Behavioral of sequential_multiplier is begin process (clk) variable temp_product : unsigned((P+Q)-1 downto 0) := (others => '0'); begin if rising_edge(clk) then temp_product := unsigned(multiplicand) * unsigned(multiplier); product <= std_logic_vector(temp_product); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity magnitude_comparator is Generic ( K : integer := 8 ); Port ( A : in STD_LOGIC_VECTOR (K-1 downto 0); B : in STD_LOGIC_VECTOR (K-1 downto 0); A_GT_B : out STD_LOGIC; A_EQ_B : out STD_LOGIC; A_LT_B : out STD_LOGIC); end magnitude_comparator; architecture Behavioral of magnitude_comparator is begin process (A, B) begin if (unsigned(A) > unsigned(B)) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (unsigned(A) < unsigned(B)) then A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; else A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity BidirectionalShiftRegister is Generic( L : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Parallel_In : in STD_LOGIC_VECTOR (L-1 downto 0); Parallel_Out : out STD_LOGIC_VECTOR (L-1 downto 0); Serial_Out : out STD_LOGIC); end BidirectionalShiftRegister; architecture Behavioral of BidirectionalShiftRegister is signal ShiftReg : STD_LOGIC_VECTOR (L-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then ShiftReg <= (others => '0'); elsif rising_edge(Clock) then if Shift_Left = '1' and Shift_Right = '0' then ShiftReg <= ShiftReg(L-2 downto 0) & Parallel_In(L-1); elsif Shift_Left = '0' and Shift_Right = '1' then ShiftReg <= Parallel_In(0) & ShiftReg(L-1 downto 1); end if ; end if ; end process ; Parallel_Out <= ShiftReg; Serial_Out <= ShiftReg(0); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity rotating_priority_encoder is Generic (N : natural := 8); Port ( Request : in STD_LOGIC_VECTOR (N-1 downto 0); Grant : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); Valid : out STD_LOGIC; Rotation_Bit : out STD_LOGIC); end rotating_priority_encoder; architecture Behavioral of rotating_priority_encoder is begin process (Request) variable max_index : natural := 0; begin Valid <= '0'; Rotation_Bit <= '0'; for i in 0 to N-1 loop if Request(i) = '1' then max_index := i; Valid <= '1'; end if ; end loop ; Grant <= std_logic_vector(to_unsigned(max_index, log2(N))); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity FullAdder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; Carry_In : in STD_LOGIC; Sum : out STD_LOGIC; Carry_Out : out STD_LOGIC); end FullAdder; architecture Behavioral of FullAdder is begin Sum <= A XOR B XOR Carry_In; Carry_Out <= (A AND B) OR (B AND Carry_In) OR (Carry_In AND A); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity HalfAdder is Port ( A : in STD_LOGIC; B : in STD_LOGIC; Sum : out STD_LOGIC; Carry_Out : out STD_LOGIC); end HalfAdder; architecture Behavioral of HalfAdder is begin Sum <= A XOR B; Carry_Out <= A AND B; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity mux_2to1 is Port ( Data0 : in STD_LOGIC; Data1 : in STD_LOGIC; Select : in STD_LOGIC; Data_Out : out STD_LOGIC); end mux_2to1; architecture Behavioral of mux_2to1 is begin process (Data0, Data1, Select) begin case Select is when '0' => Data_Out <= Data0; when '1' => Data_Out <= Data1; when others => Data_Out <= 'X'; end case ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity one_to_two_demux is Port ( Data_In : in STD_LOGIC; Select : in STD_LOGIC; Data_Out0 : out STD_LOGIC; Data_Out1 : out STD_LOGIC); end one_to_two_demux; architecture Behavioral of one_to_two_demux is begin process (Data_In, Select) begin if Select = '0' then Data_Out0 <= Data_In; Data_Out1 <= '0'; elsif Select = '1' then Data_Out0 <= '0'; Data_Out1 <= Data_In; else Data_Out0 <= '0'; Data_Out1 <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity decoder_2to4 is Port ( A : in STD_LOGIC; B : in STD_LOGIC; D0 : out STD_LOGIC; D1 : out STD_LOGIC; D2 : out STD_LOGIC; D3 : out STD_LOGIC); end decoder_2to4; architecture Behavioral of decoder_2to4 is begin process (A, B) begin case (B & A) is when "00" => D0 <= '1'; D1 <= '0'; D2 <= '0'; D3 <= '0'; when "01" => D0 <= '0'; D1 <= '1'; D2 <= '0'; D3 <= '0'; when "10" => D0 <= '0'; D1 <= '0'; D2 <= '1'; D3 <= '0'; when others => D0 <= '0'; D1 <= '0'; D2 <= '0'; D3 <= '1'; end case ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity four_to_two_encoder is Port ( D0 : in STD_LOGIC; D1 : in STD_LOGIC; D2 : in STD_LOGIC; D3 : in STD_LOGIC; A : out STD_LOGIC; B : out STD_LOGIC; Valid : out STD_LOGIC); end four_to_two_encoder; architecture Behavioral of four_to_two_encoder is begin process (D0, D1, D2, D3) begin if (D0 = '1') then A <= '1'; B <= '0'; Valid <= '1'; elsif (D1 = '1') then A <= '0'; B <= '1'; Valid <= '1'; elsif (D2 = '1') then A <= '0'; B <= '0'; Valid <= '1'; elsif (D3 = '1') then A <= '1'; B <= '1'; Valid <= '1'; else A <= '0'; B <= '0'; Valid <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity shift_register is Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Shift_In : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Q0 : out STD_LOGIC; Q1 : out STD_LOGIC; Q2 : out STD_LOGIC; Q3 : out STD_LOGIC; Shift_Out : out STD_LOGIC); end shift_register; architecture Behavioral of shift_register is signal reg: std_logic_vector(3 downto 0) := (others => '0'); begin process (Clock, Reset) begin if rising_edge(Clock) then if Reset = '1' then reg <= (others => '0'); else if Shift_Left = '1' then reg <= reg(2 downto 0) & Shift_In; elsif Shift_Right = '1' then reg <= Shift_In & reg(3 downto 1); end if ; end if ; end if ; end process ; Q0 <= reg(0); Q1 <= reg(1); Q2 <= reg(2); Q3 <= reg(3); Shift_Out <= reg(3); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity up_down_counter is Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Up_Down : in STD_LOGIC; Count_Enable : in STD_LOGIC; Q0, Q1, Q2, Q3 : out STD_LOGIC); end up_down_counter; architecture Behavioral of up_down_counter is signal count: unsigned(3 downto 0) := (others => '0'); begin process (Clock, Reset, Count_Enable) begin if rising_edge(Clock) then if Reset = '1' then count <= (others => '0'); elsif Count_Enable = '1' then if Up_Down = '0' then count <= count - 1; else count <= count + 1; end if ; end if ; end if ; end process ; Q0 <= count(0); Q1 <= count(1); Q2 <= count(2); Q3 <= count(3); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity magnitude_comparator is Port ( A1 : in STD_LOGIC; A0 : in STD_LOGIC; B1 : in STD_LOGIC; B0 : in STD_LOGIC; A_GT_B : out STD_LOGIC; A_EQ_B : out STD_LOGIC; A_LT_B : out STD_LOGIC); end magnitude_comparator; architecture Behavioral of magnitude_comparator is begin process (A1, A0, B1, B0) begin if (A1 > B1) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (A1 < B1) then A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; else if (A0 > B0) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (A0 < B0) then A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; else A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity parity_checker is Port ( D3 : in STD_LOGIC; D2 : in STD_LOGIC; D1 : in STD_LOGIC; D0 : in STD_LOGIC; Even_Parity : out STD_LOGIC; Odd_Parity : out STD_LOGIC); end parity_checker; architecture Behavioral of parity_checker is begin process (D3, D2, D1, D0) variable sum : integer := 0; begin sum := 0; if (D3 = '1') then sum := sum + 1; end if ; if (D2 = '1') then sum := sum + 1; end if ; if (D1 = '1') then sum := sum + 1; end if ; if (D0 = '1') then sum := sum + 1; end if ; Even_Parity <= not(sum mod 2) after 5 ns; Odd_Parity <= sum mod 2 after 5 ns; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity BarrelShifter is Port ( In3 : in STD_LOGIC; In2 : in STD_LOGIC; In1 : in STD_LOGIC; In0 : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Shift_Amount : in STD_LOGIC_VECTOR (1 downto 0); Out3 : out STD_LOGIC; Out2 : out STD_LOGIC; Out1 : out STD_LOGIC; Out0 : out STD_LOGIC); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (In3, In2, In1, In0, Shift_Left, Shift_Right, Shift_Amount) variable temp : STD_LOGIC_VECTOR (3 downto 0); begin temp := In3 & In2 & In1 & In0; if Shift_Left = '1' then Out3 <= temp(to_integer(unsigned(Shift_Amount)) + 3); Out2 <= temp(to_integer(unsigned(Shift_Amount)) + 2); Out1 <= temp(to_integer(unsigned(Shift_Amount)) + 1); Out0 <= temp(to_integer(unsigned(Shift_Amount))); elsif Shift_Right = '1' then Out3 <= temp(3 - to_integer(unsigned(Shift_Amount))); Out2 <= temp(2 - to_integer(unsigned(Shift_Amount))); Out1 <= temp(1 - to_integer(unsigned(Shift_Amount))); Out0 <= temp(0 - to_integer(unsigned(Shift_Amount))); else Out3 <= In3; Out2 <= In2; Out1 <= In1; Out0 <= In0; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity EdgeDetector is Port ( Signal_In : in STD_LOGIC; Rising_Edge : out STD_LOGIC; Falling_Edge : out STD_LOGIC); end EdgeDetector; architecture Behavioral of EdgeDetector is signal prev_signal : STD_LOGIC := '0'; begin process (Signal_In) begin if rising_edge(Signal_In) then Rising_Edge <= '1'; Falling_Edge <= '0'; elsif falling_edge(Signal_In) then Rising_Edge <= '0'; Falling_Edge <= '1'; else Rising_Edge <= '0'; Falling_Edge <= '0'; end if ; prev_signal <= Signal_In; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ring_counter is Generic(N : natural := 8); Port ( clk : in STD_LOGIC; rst : in STD_LOGIC; ring_count : out STD_LOGIC_VECTOR (N-1 downto 0)); end ring_counter; architecture Behavioral of ring_counter is begin process (clk, rst) begin if rst = '1' then ring_count <= (others => '0'); elsif rising_edge(clk) then ring_count <= std_logic_vector(unsigned(ring_count) + 1); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity LinearFeedbackShiftRegister is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Seed_Value : in STD_LOGIC_VECTOR (N-1 downto 0); LFSR_Output : out STD_LOGIC_VECTOR (N-1 downto 0)); end LinearFeedbackShiftRegister; architecture Behavioral of LinearFeedbackShiftRegister is begin process (Clock, Reset) variable LFSR : STD_LOGIC_VECTOR (N-1 downto 0); begin if Reset = '1' then LFSR := Seed_Value; elsif rising_edge(Clock) then LFSR := LFSR(N-2 downto 0) & (LFSR(N-1) xor LFSR(N-3) xor LFSR(N-4) xor '1'); end if ; LFSR_Output <= LFSR; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity FiniteStateMachine is Generic(N : natural := 4); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Input_Signals : in STD_LOGIC_VECTOR (N-1 downto 0); Current_State : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); Output_Signals : out STD_LOGIC_VECTOR (N-1 downto 0)); end FiniteStateMachine; architecture Behavioral of FiniteStateMachine is type StateType is range 0 to N-1; signal CurrentStateReg, NextState : StateType := 0; begin process (Clock, Reset) begin if Reset = '1' then CurrentStateReg <= 0; elsif rising_edge(Clock) then CurrentStateReg <= NextState; end if ; end process ; process (Input_Signals, CurrentStateReg) begin case CurrentStateReg is when 0 => if Input_Signals(0) = '1' then NextState <= 1; else NextState <= 0; end if ; when others => NextState <= CurrentStateReg; end case ; end process ; Current_State <= std_logic_vector(to_unsigned(CurrentStateReg, log2(N))); Output_Signals <= Input_Signals; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity binary_to_gray is Generic ( N : natural := 8 ); Port ( Binary_Code : in STD_LOGIC_VECTOR (N-1 downto 0); Gray_Code : out STD_LOGIC_VECTOR (N-1 downto 0)); end binary_to_gray; architecture Behavioral of binary_to_gray is begin process (Binary_Code) begin Gray_Code(0) <= Binary_Code(0); for i in 1 to N-1 loop Gray_Code(i) <= Binary_Code(i) xor Binary_Code(i-1); end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity gray_to_binary is Generic ( N : natural := 8 ); Port ( Gray_Code : in STD_LOGIC_VECTOR (N-1 downto 0); Binary_Code : out STD_LOGIC_VECTOR (N-1 downto 0)); end gray_to_binary; architecture Behavioral of gray_to_binary is begin process (Gray_Code) variable temp : STD_LOGIC_VECTOR (N-1 downto 0); begin temp := Gray_Code; for i in 1 to N-1 loop temp(i) := temp(i) xor temp(i-1); end loop ; Binary_Code <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity excess3_to_bcd is Port ( Excess3_Value : in STD_LOGIC_VECTOR (3 downto 0); BCD_Value : out STD_LOGIC_VECTOR (3 downto 0)); end excess3_to_bcd; architecture Behavioral of excess3_to_bcd is begin process (Excess3_Value) variable temp: integer range 0 to 15 := 0; begin temp := conv_integer(unsigned(Excess3_Value)) + 6; BCD_Value <= std_logic_vector(to_unsigned(temp, 4)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity HammingCodeEncoder is Port ( Data_In : in STD_LOGIC_VECTOR (3 downto 0); Encoded_Data : out STD_LOGIC_VECTOR (6 downto 0)); end HammingCodeEncoder; architecture Behavioral of HammingCodeEncoder is begin process (Data_In) begin Encoded_Data(0) <= Data_In(0) xor Data_In(1) xor Data_In(2) xor Data_In(3); Encoded_Data(1) <= Data_In(0) xor Data_In(1) xor Data_In(3); Encoded_Data(2) <= Data_In(0) xor Data_In(2) xor Data_In(3); Encoded_Data(3) <= Data_In(1) xor Data_In(2) xor Data_In(3); Encoded_Data(4) <= Data_In(0); Encoded_Data(5) <= Data_In(1); Encoded_Data(6) <= Data_In(2); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity crc_generator is Generic (N : natural := 8; M : natural := 16); Port ( Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Polynomial : in STD_LOGIC_VECTOR (M-1 downto 0); CRC_Value : out STD_LOGIC_VECTOR (M-1 downto 0)); end crc_generator; architecture Behavioral of crc_generator is begin process (Data_In, Polynomial) variable crc_reg : STD_LOGIC_VECTOR (M-1 downto 0); begin crc_reg := (others => '0'); for i in 0 to N-1 loop crc_reg(0) <= Data_In(i) xor crc_reg(0); for j in 1 to M-1 loop crc_reg(j) <= crc_reg(j-1) xor Polynomial(j) xor crc_reg(0); end loop ; end loop ; CRC_Value <= crc_reg; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity crc_checker is Generic (N : natural := 8; M : natural := 16); Port ( Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Received_CRC : in STD_LOGIC_VECTOR (M-1 downto 0); Polynomial : in STD_LOGIC_VECTOR (M-1 downto 0); CRC_Match : out STD_LOGIC); end crc_checker; architecture Behavioral of crc_checker is begin process (Data_In, Received_CRC, Polynomial) variable calculated_crc : STD_LOGIC_VECTOR (M-1 downto 0); begin calculated_crc := Data_In; for i in 0 to N-1 loop if calculated_crc(M-1) = '1' then calculated_crc := Polynomial XOR (calculated_crc(M-2 downto 0) & '0'); else calculated_crc := calculated_crc(M-2 downto 0) & '0'; end if ; end loop ; CRC_Match <= (calculated_crc = Received_CRC); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity serial_to_parallel is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Serial_In : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Parallel_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end serial_to_parallel; architecture Behavioral of serial_to_parallel is signal temp : STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clock, Shift_Enable) begin if rising_edge(Clock) then if Shift_Enable = '1' then temp <= temp(N-2 downto 0) & Serial_In; end if ; end if ; end process ; Parallel_Out <= temp; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.FLOAT_PACK.ALL; entity FloatingPointAdder is Generic (N : natural := 32); Port (A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (N-1 downto 0); Sum : out STD_LOGIC_VECTOR (N-1 downto 0)); end FloatingPointAdder; architecture Behavioral of FloatingPointAdder is signal A_float, B_float, Sum_float : float32; begin A_float <= to_float(A, 8, 23); B_float <= to_float(B, 8, 23); Sum_float <= A_float + B_float; Sum <= to_slv(Sum_float); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.FLOAT_PACK.ALL; entity FloatingPointMultiplier is Generic (N : natural := 32); Port (A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (N-1 downto 0); Product : out STD_LOGIC_VECTOR (N-1 downto 0)); end FloatingPointMultiplier; architecture Behavioral of FloatingPointMultiplier is signal A_float, B_float, Product_float : float32; begin A_float <= to_float(A, 8, 23); B_float <= to_float(B, 8, 23); Product_float <= A_float * B_float; Product <= to_slv(Product_float); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity fixed_point_divider is Generic(N : natural := 8); Port ( dividend : in signed(N-1 downto 0); divisor : in signed(N-1 downto 0); quotient : out signed(N-1 downto 0); remainder : out signed(N-1 downto 0)); end fixed_point_divider; architecture Behavioral of fixed_point_divider is begin process (dividend, divisor) variable temp_quotient : signed(N-1 downto 0); variable temp_remainder : signed(N-1 downto 0); begin temp_quotient := (others => '0'); temp_remainder := dividend; for i in 0 to N-1 loop if temp_remainder >= divisor then temp_remainder := temp_remainder - divisor; temp_quotient(i) := '1'; end if ; end loop ; quotient <= temp_quotient; remainder <= temp_remainder; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity signed_multiplier is Generic(N : natural := 8); Port ( A : in SIGNED (N-1 downto 0); B : in SIGNED (N-1 downto 0); Product : out SIGNED ((2*N)-1 downto 0)); end signed_multiplier; architecture Behavioral of signed_multiplier is begin Product <= A * B; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity unsigned_divider is Generic(N : positive := 8); Port ( dividend : in unsigned(N-1 downto 0); divisor : in unsigned(N-1 downto 0); quotient : out unsigned(N-1 downto 0); remainder : out unsigned(N-1 downto 0)); end unsigned_divider; architecture Behavioral of unsigned_divider is begin process (dividend, divisor) variable temp_quotient : unsigned(N-1 downto 0); variable temp_remainder : unsigned(N-1 downto 0); begin temp_quotient := (others => '0'); temp_remainder := dividend; for i in 0 to N-1 loop if temp_remainder >= divisor then temp_remainder := temp_remainder - divisor; temp_quotient(i) := '1'; end if ; end loop ; quotient <= temp_quotient; remainder <= temp_remainder; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity pipelined_multiplier is Generic ( N : natural := 8; M : natural := 16 ); Port ( clk : in STD_LOGIC; A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (M-1 downto 0); product : out STD_LOGIC_VECTOR ((N+M)-1 downto 0)); end pipelined_multiplier; architecture Behavioral of pipelined_multiplier is signal partial_product : STD_LOGIC_VECTOR (N+M-1 downto 0); begin process (clk) begin if rising_edge(clk) then partial_product <= A * B; end if ; end process ; product <= partial_product; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Floating_Point_Converter is Generic (N : natural := 8; M : natural := 32); Port ( fixed_point : in signed(N-1 downto 0); float_value : out std_logic_vector(M-1 downto 0)); end Floating_Point_Converter; architecture Behavioral of Floating_Point_Converter is begin process (fixed_point) variable int_part : signed(N-2 downto 0); variable frac_part : unsigned(N-1 downto 0); variable exp : integer; variable result : std_logic_vector(M-1 downto 0); begin if fixed_point >= 0 then int_part := resize(fixed_point, N-2); frac_part := unsigned(fixed_point) rem 2**N; exp := N - count_leading_zeros(frac_part) - 1; result := "00000000000000000000000000000000" & std_logic_vector(int_part); else int_part := resize(-fixed_point, N-2); frac_part := unsigned(-fixed_point) rem 2**N; exp := N - count_leading_zeros(frac_part) - 1; result := "10000000000000000000000000000000" & std_logic_vector(int_part); end if ; float_value <= result; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity fixed_point_converter is Generic ( M : natural := 32; N : natural := 16 ); Port ( float_value : in signed(M-1 downto 0); fixed_point : out signed(N-1 downto 0)); end fixed_point_converter; architecture Behavioral of fixed_point_converter is begin process (float_value) begin fixed_point <= resize(float_value, N); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity binary_to_bcd is Generic (N : natural := 8); Port (Binary_Value : in STD_LOGIC_VECTOR (N-1 downto 0); BCD_Value : out STD_LOGIC_VECTOR (((N/3)+1)*4-1 downto 0)); end binary_to_bcd; architecture Behavioral of binary_to_bcd is begin process (Binary_Value) variable temp : unsigned(N downto 0); variable result : unsigned((((N/3)+1)*4)-1 downto 0); begin temp := unsigned('0' & Binary_Value); result := (others => '0'); for i in N-1 downto 0 loop result(result'left-3 downto 0) := result(result'left downto 4); result(3 downto 0) := std_logic_vector(temp(i) & "000"); for j in 0 to ((N/3)+1)-1 loop if result((j+1)*4-1 downto j*4) > "0100" then result((j+1)*4-1 downto j*4) := result((j+1)*4-1 downto j*4) + "0011"; end if; end loop; end loop; BCD_Value <= std_logic_vector(result); end process; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity bcd_to_binary is Generic(N : integer := 8); Port ( BCD_Value : in STD_LOGIC_VECTOR ((N/3)+1-1 downto 0); Binary_Value : out STD_LOGIC_VECTOR (N-1 downto 0)); end bcd_to_binary; architecture Behavioral of bcd_to_binary is begin process (BCD_Value) variable temp : STD_LOGIC_VECTOR ((N/3)+1-1 downto 0); variable result : STD_LOGIC_VECTOR (N-1 downto 0); begin temp := BCD_Value; result := (others => '0'); for i in 0 to (N/3)-1 loop case temp(i) is when '0' => result((i*3)+2 downto (i*3)) := "000"; when '1' => result((i*3)+2 downto (i*3)) := "001"; when '2' => result((i*3)+2 downto (i*3)) := "010"; when '3' => result((i*3)+2 downto (i*3)) := "011"; when '4' => result((i*3)+2 downto (i*3)) := "100"; when '5' => result((i*3)+2 downto (i*3)) := "101"; when '6' => result((i*3)+2 downto (i*3)) := "110"; when '7' => result((i*3)+2 downto (i*3)) := "111"; when others => null; end case ; end loop ; Binary_Value <= result; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ParallelInParallelOutShiftRegister is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Load_Enable : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Shift_Direction : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end ParallelInParallelOutShiftRegister; architecture Behavioral of ParallelInParallelOutShiftRegister is signal reg : STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clock) begin if rising_edge(Clock) then if Load_Enable = '1' then reg <= Data_In; elsif Shift_Enable = '1' then if Shift_Direction = '0' then reg <= reg(N-2 downto 0) & reg(N-1); else reg <= reg(0) & reg(N-1 downto 1); end if ; end if ; end if ; end process ; Data_Out <= reg; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity JohnsonRingCounter is Generic(N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Count : out STD_LOGIC_VECTOR (N-1 downto 0)); end JohnsonRingCounter; architecture Behavioral of JohnsonRingCounter is signal tempCount : unsigned(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then tempCount <= (others => '0'); elsif rising_edge(Clock) then tempCount <= tempCount + 1; end if ; end process ; Count <= std_logic_vector(tempCount); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity PRNG is Generic(N : integer := 8); Port ( Clock : in STD_LOGIC; Seed_Value : in STD_LOGIC_VECTOR (N-1 downto 0); Random_Number : out STD_LOGIC_VECTOR (N-1 downto 0)); end PRNG; architecture Behavioral of PRNG is begin process (Clock) variable seed : unsigned(Seed_Value'range); begin if rising_edge(Clock) then seed := seed + 1; Random_Number <= std_logic_vector(seed); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity fir_filter is Generic ( N : natural := 8; M : natural := 5 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Data_In : in signed(N-1 downto 0); Coefficients : in signed(M*N-1 downto 0); Filtered_Output : out signed(N-1 downto 0) ); end fir_filter; architecture Behavioral of fir_filter is type coeff_array is array (0 to M-1) of signed(N-1 downto 0); signal coeffs : coeff_array := (others => (others => '0')); begin process (Clock, Reset) variable accumulator : signed(2*N-1 downto 0); begin if Reset = '1' then Filtered_Output <= (others => '0'); accumulator := (others => '0'); elsif rising_edge(Clock) then for i in 0 to M-1 loop coeffs(i) <= Coefficients((i+1)*N-1 downto i*N); end loop ; accumulator := (others => '0'); for i in 0 to M-1 loop accumulator := accumulator + Data_In * coeffs(i); end loop ; Filtered_Output <= accumulator(N-1 downto 0); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity infinite_impulse_response_filter is Generic ( N : natural := 8; M : natural := 5 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Coefficients : in STD_LOGIC_MATRIX(M-1 downto 0, N-1 downto 0); Filtered_Output : out STD_LOGIC_VECTOR (N-1 downto 0) ); end infinite_impulse_response_filter; architecture Behavioral of infinite_impulse_response_filter is type delay_line_array is array (M-1 downto 0) of STD_LOGIC_VECTOR(N-1 downto 0); signal delay_line : delay_line_array; begin process (Clock, Reset) begin if Reset = '1' then delay_line <= (others => (others => '0')); Filtered_Output <= (others => '0'); elsif rising_edge(Clock) then for i in 0 to M-2 loop delay_line(i+1) <= delay_line(i); end loop ; delay_line(0) <= Data_In; Filtered_Output <= (others => '0'); for i in 0 to M-1 loop Filtered_Output := Filtered_Output + signed(delay_line(i)) * signed(Coefficients(i, N-1 downto 0)); end loop ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Digital_PID_Controller is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Set_Point : in STD_LOGIC_VECTOR (N-1 downto 0); Measured_Value : in STD_LOGIC_VECTOR (N-1 downto 0); Kp, Ki, Kd : in STD_LOGIC_VECTOR (N-1 downto 0); Control_Output : out STD_LOGIC_VECTOR (N-1 downto 0)); end Digital_PID_Controller; architecture Behavioral of Digital_PID_Controller is signal Error, Proportional, Integral, Derivative, Output : signed(N-1 downto 0); begin process (Clock) begin if rising_edge(Clock) then if Reset = '1' then Error <= (others => '0'); Proportional <= (others => '0'); Integral <= (others => '0'); Derivative <= (others => '0'); Output <= (others => '0'); else Error <= signed(Set_Point) - signed(Measured_Value); Proportional <= Error; Integral <= Integral + Error; Derivative <= Derivative + (Error - Proportional); Output <= Proportional * signed(Kp) + Integral * signed(Ki) + Derivative * signed(Kd); end if ; end if ; end process ; Control_Output <= std_logic_vector(Output); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity DigitalIntegrator is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Integrated_Output : out STD_LOGIC_VECTOR (N-1 downto 0)); end DigitalIntegrator; architecture Behavioral of DigitalIntegrator is signal Accumulator : STD_LOGIC_VECTOR (N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then Accumulator <= (others => '0'); elsif rising_edge(Clock) then Accumulator <= std_logic_vector(unsigned(Accumulator) + unsigned(Data_In)); end if ; end process ; Integrated_Output <= Accumulator; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity pulse_width_modulator is Generic (N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Duty_Cycle : in STD_LOGIC_VECTOR (N-1 downto 0); PWM_Output : out STD_LOGIC); end pulse_width_modulator; architecture Behavioral of pulse_width_modulator is signal counter : unsigned(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then counter <= (others => '0'); PWM_Output <= '0'; elsif rising_edge(Clock) then if counter < unsigned(Duty_Cycle) then PWM_Output <= '1'; else PWM_Output <= '0'; end if ; counter <= counter + 1; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity frequency_divider is Generic (N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Divide_Ratio : in UNSIGNED(N-1 downto 0); Divided_Clock : out STD_LOGIC); end frequency_divider; architecture Behavioral of frequency_divider is signal counter : UNSIGNED(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then counter <= (others => '0'); Divided_Clock <= '0'; elsif rising_edge(Clock) then if counter < Divide_Ratio then counter <= counter + 1; else counter <= (others => '0'); Divided_Clock <= not Divided_Clock; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity EdgeDetectorWithPulseStretcher is Port ( Signal_In : in STD_LOGIC; Rising_Edge_Pulse : out STD_LOGIC; Falling_Edge_Pulse : out STD_LOGIC); end EdgeDetectorWithPulseStretcher; architecture Behavioral of EdgeDetectorWithPulseStretcher is signal rising_edge_reg, falling_edge_reg : std_logic := '0'; begin process (Signal_In) begin if rising_edge(Signal_In) then rising_edge_reg <= '1'; else rising_edge_reg <= '0'; end if ; end process ; Rising_Edge_Pulse <= rising_edge_reg and not falling_edge_reg; process (Signal_In) begin if falling_edge(Signal_In) then falling_edge_reg <= '1'; else falling_edge_reg <= '0'; end if ; end process ; Falling_Edge_Pulse <= not rising_edge_reg and falling_edge_reg; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity GlitchFilterInput is Port ( Noisy_Signal : in STD_LOGIC; Filtered_Signal : out STD_LOGIC); end GlitchFilterInput; architecture Behavioral of GlitchFilterInput is signal delay_line : STD_LOGIC := '0'; begin process (Noisy_Signal) begin if rising_edge(Noisy_Signal) then delay_line <= '1'; elsif falling_edge(Noisy_Signal) then delay_line <= '0'; end if ; end process ; Filtered_Signal <= delay_line; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Debouncer is Port ( Noisy_Button : in STD_LOGIC; Clean_Button_Pulse : out STD_LOGIC); end Debouncer; architecture Behavioral of Debouncer is signal debounce_counter : unsigned(7 downto 0) := (others => '0'); signal last_button_state : std_logic := '0'; begin process (Noisy_Button, debounce_counter, last_button_state) begin if rising_edge(Noisy_Button) then debounce_counter <= debounce_counter + 1; if debounce_counter = x"FF" then Clean_Button_Pulse <= '1'; last_button_state <= '0'; end if ; elsif falling_edge(Noisy_Button) then debounce_counter <= (others => '0'); if last_button_state = '0' then Clean_Button_Pulse <= '1'; last_button_state <= '1'; end if ; else Clean_Button_Pulse <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity SchmittTriggerInput is Port ( Analog_In : in STD_LOGIC; Digital_Out : out STD_LOGIC); end SchmittTriggerInput; architecture Behavioral of SchmittTriggerInput is signal last_value, current_value : STD_LOGIC := '0'; begin process (Analog_In) begin if rising_edge(Analog_In) then last_value <= current_value; current_value <= Analog_In; end if ; end process ; Digital_Out <= '1' when (current_value = '1' and last_value = '0') else '0'; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity MonostableMultivibrator is Generic( N : natural := 8 ); Port ( Trigger : in STD_LOGIC; Pulse_Out : out STD_LOGIC); end MonostableMultivibrator; architecture Behavioral of MonostableMultivibrator is signal Counter : unsigned(N-1 downto 0) := (others => '0'); begin process (Trigger, Counter) begin if rising_edge(Trigger) then Counter <= (others => '0'); elsif Counter < 2**N-1 then Counter <= Counter + 1; end if ; Pulse_Out <= '0' when Counter < 2**(N-1) else '1'; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity AstableMultivibrator is Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Oscillating_Output : out STD_LOGIC); end AstableMultivibrator; architecture Behavioral of AstableMultivibrator is signal count: unsigned(31 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then count <= (others => '0'); elsif rising_edge(Clock) then count <= count + 1; end if ; end process ; Oscillating_Output <= std_logic(count(31)); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity UpCounter is Generic(N : natural := 8); Port ( Clk : in STD_LOGIC; Rst : in STD_LOGIC; En : in STD_LOGIC; Count : out STD_LOGIC_VECTOR (N-1 downto 0)); end UpCounter; architecture Behavioral of UpCounter is signal count_reg : unsigned(N-1 downto 0) := (others => '0'); begin process (Clk, Rst, En) begin if rising_edge(Clk) then if Rst = '1' then count_reg <= (others => '0'); elsif En = '1' then count_reg <= count_reg + 1; end if ; end if ; end process ; Count <= std_logic_vector(count_reg); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity data_register is Generic ( M : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Load : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (M-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (M-1 downto 0)); end data_register; architecture Behavioral of data_register is begin process (Clock, Reset) begin if Reset = '1' then Data_Out <= (others => '0'); elsif rising_edge(Clock) and Load = '1' then Data_Out <= Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity BidirectionalShiftRegister is Port ( Clk : in STD_LOGIC; Clear : in STD_LOGIC; Ser_In : in STD_LOGIC; Shift_En : in STD_LOGIC; Shift_Dir : in STD_LOGIC; Par_Out : out STD_LOGIC_VECTOR (P-1 downto 0); Ser_Out : out STD_LOGIC); end BidirectionalShiftRegister; architecture Behavioral of BidirectionalShiftRegister is signal ShiftReg: STD_LOGIC_VECTOR (P-1 downto 0) := (others => '0'); begin process (Clk, Clear, Shift_En, Shift_Dir) begin if Clear = '1' then ShiftReg <= (others => '0'); elsif rising_edge(Clk) and Shift_En = '1' then if Shift_Dir = '0' then ShiftReg <= ShiftReg(P-2 downto 0) & Ser_In; else ShiftReg <= Ser_In & ShiftReg(P-1 downto 1); end if ; end if ; end process ; Par_Out <= ShiftReg; Ser_Out <= ShiftReg(0) when Shift_Dir = '0' else ShiftReg(P-1); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity dual_port_memory is Generic(K : natural := 8; L : natural := 32); Port ( Clock : in STD_LOGIC; Write : in STD_LOGIC; Address_W : in STD_LOGIC_VECTOR (log2K-1 downto 0); Address_R : in STD_LOGIC_VECTOR (log2K-1 downto 0); Data_Write : in STD_LOGIC_VECTOR (L-1 downto 0); Data_Read : out STD_LOGIC_VECTOR (L-1 downto 0)); end dual_port_memory; architecture Behavioral of dual_port_memory is type mem_array is array(0 to K-1) of std_logic_vector(L-1 downto 0); signal memory : mem_array := (others => (others => '0')); begin process (Clock, Write, Address_W, Data_Write) begin if rising_edge(Clock) then if Write = '1' then memory(to_integer(unsigned(Address_W))) <= Data_Write; end if ; end if ; end process ; Data_Read <= memory(to_integer(unsigned(Address_R))); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ROM is Generic( M : natural := 1024; N : natural := 8 ); Port ( Addr : in STD_LOGIC_VECTOR (log2m-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (n-1 downto 0)); end ROM; architecture Behavioral of ROM is type mem_array is array(0 to m-1) of std_logic_vector(n-1 downto 0); signal memory : mem_array := (others => (others => '0')); begin process (Addr) begin if rising_edge(clk) then Data_Out <= memory(to_integer(unsigned(Addr))); end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity priority_encoder is Generic(M : natural := 8); Port ( requests : in STD_LOGIC_VECTOR (2**M-1 downto 0); encoded : out STD_LOGIC_VECTOR (M-1 downto 0); valid : out STD_LOGIC); end priority_encoder; architecture Behavioral of priority_encoder is begin process (requests) variable max_index : natural := M-1; begin valid <= '0'; for i in 2**M-1 downto 0 loop if requests(i) = '1' then encoded <= std_logic_vector(to_unsigned(max_index, M)); valid <= '1'; exit; end if ; max_index := max_index - 1; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity data_multiplexer is Generic (N : natural := 2; M : natural := 8); Port ( Sel : in STD_LOGIC_VECTOR (log2(N)-1 downto 0); Data_Inputs : in STD_LOGIC_VECTOR ((N-1)*M downto 0); Data_Out : out STD_LOGIC_VECTOR (M-1 downto 0)); end data_multiplexer; architecture Behavioral of data_multiplexer is begin process (Sel, Data_Inputs) variable index : natural := 0; begin for i in 0 to N-1 loop if Sel = std_logic_vector(to_unsigned(i, log2(N))) then index := i*M; Data_Out <= Data_Inputs(index+M-1 downto index); end if ; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity data_demux is Generic (log2N : natural := 3; M : natural := 8); Port ( Sel : in STD_LOGIC_VECTOR (log2N-1 downto 0); Data_In : in STD_LOGIC_VECTOR (M-1 downto 0); Data_Outs : out STD_LOGIC_VECTOR ((2**log2N)-1 downto 0)); end data_demux; architecture Behavioral of data_demux is begin process (Sel, Data_In) begin for i in 0 to 2**log2N-1 loop if Sel = std_logic_vector(to_unsigned(i, log2N)) then Data_Outs(i*M+M-1 downto i*M) <= Data_In; else Data_Outs(i*M+M-1 downto i*M) <= (others => '0'); end if ; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity NBitAdder is Generic(N : natural := 8); Port ( A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (N-1 downto 0); Cin : in STD_LOGIC; Sum : out STD_LOGIC_VECTOR (N-1 downto 0); Cout : out STD_LOGIC); end NBitAdder; architecture Behavioral of NBitAdder is signal tempSum: STD_LOGIC_VECTOR(N downto 0); begin tempSum(0) <= Cin; for i in 0 to N-1 loop tempSum(i+1) <= A(i) xor B(i) xor tempSum(i); Sum(i) <= A(i) xor B(i) xor tempSum(i); end loop; Cout <= tempSum(N); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Subtractor is Generic( M : natural := 8); Port ( X : in STD_LOGIC_VECTOR (M-1 downto 0); Y : in STD_LOGIC_VECTOR (M-1 downto 0); Borrow_In : in STD_LOGIC; Diff : out STD_LOGIC_VECTOR (M-1 downto 0); Borrow_Out : out STD_LOGIC); end Subtractor; architecture Behavioral of Subtractor is begin process (X, Y, Borrow_In) variable borrow : STD_LOGIC := Borrow_In; begin for i in 0 to M-1 loop Diff(i) <= X(i) xor Y(i) xor borrow; borrow := (X(i) and Y(i)) or (borrow and (X(i) or Y(i))); end loop ; Borrow_Out <= borrow; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity MultiplierUnit is Generic ( N : natural := 8; M : natural := 16 ); Port ( Factor1 : in STD_LOGIC_VECTOR (N-1 downto 0); Factor2 : in STD_LOGIC_VECTOR (M-1 downto 0); Product : out STD_LOGIC_VECTOR ((N+M)-1 downto 0) ); end MultiplierUnit; architecture Behavioral of MultiplierUnit is begin process (Factor1, Factor2) begin Product <= std_logic_vector(signed(Factor1) * signed(Factor2)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity DividerUnit is Generic (N : integer := 8; M : integer := 4); Port ( Numerator : in STD_LOGIC_VECTOR (N-1 downto 0); Denominator : in STD_LOGIC_VECTOR (M-1 downto 0); Quotient : out STD_LOGIC_VECTOR (N-M+1-1 downto 0); Remainder : out STD_LOGIC_VECTOR (M-1 downto 0)); end DividerUnit; architecture Behavioral of DividerUnit is begin process (Numerator, Denominator) variable tempQuotient : unsigned(N-M+1-1 downto 0); variable tempRemainder : unsigned(M-1 downto 0); begin tempQuotient := (others => '0'); tempRemainder := unsigned(Numerator); for i in 0 to N-1 loop if tempRemainder >= unsigned(Denominator) then tempRemainder := tempRemainder - unsigned(Denominator); tempQuotient := tempQuotient + 1; end if ; end loop ; Quotient <= std_logic_vector(tempQuotient); Remainder <= std_logic_vector(tempRemainder); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ComparatorCircuit is Generic(K : natural := 8); Port ( Value1 : in STD_LOGIC_VECTOR (K-1 downto 0); Value2 : in STD_LOGIC_VECTOR (K-1 downto 0); Greater : out STD_LOGIC; Equal : out STD_LOGIC; Smaller : out STD_LOGIC); end ComparatorCircuit; architecture Behavioral of ComparatorCircuit is begin process (Value1, Value2) begin if (Value1 > Value2) then Greater <= '1'; Equal <= '0'; Smaller <= '0'; elsif (Value1 < Value2) then Greater <= '0'; Equal <= '0'; Smaller <= '1'; else Greater <= '0'; Equal <= '1'; Smaller <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity BarrelShifter is Generic ( N : natural := 8 ); Port ( Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Shift_Left, Shift_Right : in STD_LOGIC; Shift_Amount : in INTEGER range 0 to N-1; Data_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (Data_In, Shift_Left, Shift_Right, Shift_Amount) begin if Shift_Left = '1' then Data_Out <= std_logic_vector(shift_left(unsigned(Data_In), Shift_Amount)); elsif Shift_Right = '1' then Data_Out <= std_logic_vector(shift_right(unsigned(Data_In), Shift_Amount)); else Data_Out <= Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity fifo_buffer is Generic(N : integer := 8; M : integer := 16); Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Write_En : in STD_LOGIC; Read_En : in STD_LOGIC; Data_In : in STD_LOGIC_VECTOR (M-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (M-1 downto 0); Full_Flag : out STD_LOGIC; Empty_Flag : out STD_LOGIC); end fifo_buffer; architecture Behavioral of fifo_buffer is type mem_array is array(0 to N-1) of STD_LOGIC_VECTOR (M-1 downto 0); signal memory : mem_array := (others => (others => '0')); signal rd_ptr, wr_ptr : integer range 0 to N-1 := 0; begin process (Clk) begin if rising_edge(Clk) then if Reset = '1' then rd_ptr <= 0; wr_ptr <= 0; Full_Flag <= '0'; Empty_Flag <= '1'; elsif Write_En = '1' and Full_Flag = '0' then memory(wr_ptr) <= Data_In; wr_ptr := (wr_ptr + 1) mod N; Full_Flag <= (rd_ptr = wr_ptr); Empty_Flag <= '0'; elsif Read_En = '1' and Empty_Flag = '0' then Data_Out <= memory(rd_ptr); rd_ptr := (rd_ptr + 1) mod N; Full_Flag <= '0'; Empty_Flag <= (rd_ptr = wr_ptr); end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity one_to_two_demux is Port ( Data_In : in STD_LOGIC; Sel : in STD_LOGIC; Out0 : out STD_LOGIC; Out1 : out STD_LOGIC); end one_to_two_demux; architecture Behavioral of one_to_two_demux is begin process (Data_In, Sel) begin if Sel = '0' then Out0 <= Data_In; Out1 <= '0'; else Out0 <= '0'; Out1 <= Data_In; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity decoder_2to4 is Port ( A : in STD_LOGIC; B : in STD_LOGIC; D0 : out STD_LOGIC; D1 : out STD_LOGIC; D2 : out STD_LOGIC; D3 : out STD_LOGIC); end decoder_2to4; architecture Behavioral of decoder_2to4 is begin process (A, B) begin case (A & B) is when "00" => D0 <= '1'; D1 <= '0'; D2 <= '0'; D3 <= '0'; when "01" => D0 <= '0'; D1 <= '1'; D2 <= '0'; D3 <= '0'; when "10" => D0 <= '0'; D1 <= '0'; D2 <= '1'; D3 <= '0'; when "11" => D0 <= '0'; D1 <= '0'; D2 <= '0'; D3 <= '1'; end case ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity four_to_two_encoder is Port ( I0 : in STD_LOGIC; I1 : in STD_LOGIC; I2 : in STD_LOGIC; I3 : in STD_LOGIC; A : out STD_LOGIC; B : out STD_LOGIC; Valid : out STD_LOGIC); end four_to_two_encoder; architecture Behavioral of four_to_two_encoder is begin process (I0, I1, I2, I3) begin if (I0 = '1') then A <= '1'; B <= '0'; Valid <= '1'; elsif (I1 = '1') then A <= '0'; B <= '1'; Valid <= '1'; elsif (I2 = '1') then A <= '0'; B <= '0'; Valid <= '1'; else A <= '1'; B <= '1'; Valid <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity shift_register is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Ser_In : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Q0, Q1, Q2, Q3 : out STD_LOGIC; Ser_Out : out STD_LOGIC); end shift_register; architecture Behavioral of shift_register is signal reg: std_logic_vector(3 downto 0) := (others => '0'); begin process (Clk, Reset) begin if Reset = '1' then reg <= (others => '0'); elsif rising_edge(Clk) then if Shift_Left = '1' then reg <= reg(2 downto 0) & Ser_In; elsif Shift_Right = '1' then reg <= Ser_In & reg(3 downto 1); end if ; end if ; end process ; Q0 <= reg(0); Q1 <= reg(1); Q2 <= reg(2); Q3 <= reg(3); Ser_Out <= reg(3); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity updown_counter is Port ( Clock : in STD_LOGIC; Rst : in STD_LOGIC; UpDown : in STD_LOGIC; En : in STD_LOGIC; Count0 : out STD_LOGIC; Count1 : out STD_LOGIC; Count2 : out STD_LOGIC; Count3 : out STD_LOGIC); end updown_counter; architecture Behavioral of updown_counter is signal count: unsigned(3 downto 0) := (others => '0'); begin process (Clock, Rst, En) begin if rising_edge(Clock) then if Rst = '1' then count <= (others => '0'); elsif En = '1' then if UpDown = '1' then count <= count + 1; else count <= count - 1; end if ; end if ; end if ; end process ; Count0 <= std_logic(count(0)); Count1 <= std_logic(count(1)); Count2 <= std_logic(count(2)); Count3 <= std_logic(count(3)); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity parity_checker is Port ( D3 : in STD_LOGIC; D2 : in STD_LOGIC; D1 : in STD_LOGIC; D0 : in STD_LOGIC; Even : out STD_LOGIC; Odd : out STD_LOGIC); end parity_checker; architecture Behavioral of parity_checker is begin process (D3, D2, D1, D0) variable sum: integer := 0; begin sum := 0; if D3 = '1' then sum := sum + 1; end if ; if D2 = '1' then sum := sum + 1; end if ; if D1 = '1' then sum := sum + 1; end if ; if D0 = '1' then sum := sum + 1; end if ; if sum mod 2 = 0 then Even <= '1'; Odd <= '0'; else Even <= '0'; Odd <= '1'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity BarrelShifter is Port ( In3 : in STD_LOGIC; In2 : in STD_LOGIC; In1 : in STD_LOGIC; In0 : in STD_LOGIC; Shift_Left : in STD_LOGIC; Shift_Right : in STD_LOGIC; Shift_Amt : in STD_LOGIC_VECTOR (1 downto 0); Out3 : out STD_LOGIC; Out2 : out STD_LOGIC; Out1 : out STD_LOGIC; Out0 : out STD_LOGIC); end BarrelShifter; architecture Behavioral of BarrelShifter is begin process (In3, In2, In1, In0, Shift_Left, Shift_Right, Shift_Amt) variable temp : STD_LOGIC_VECTOR (3 downto 0); begin temp := In3 & In2 & In1 & In0; if Shift_Left = '1' then Out3 <= temp(to_integer(unsigned(Shift_Amt))+3); Out2 <= temp(to_integer(unsigned(Shift_Amt))+2); Out1 <= temp(to_integer(unsigned(Shift_Amt))+1); Out0 <= temp(to_integer(unsigned(Shift_Amt))); elsif Shift_Right = '1' then Out3 <= temp(3-to_integer(unsigned(Shift_Amt))); Out2 <= temp(2-to_integer(unsigned(Shift_Amt))); Out1 <= temp(1-to_integer(unsigned(Shift_Amt))); Out0 <= temp(0-to_integer(unsigned(Shift_Amt))); else Out3 <= In3; Out2 <= In2; Out1 <= In1; Out0 <= In0; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ring_counter is Generic(N : natural := 8); Port ( Clk : in STD_LOGIC; Rst : in STD_LOGIC; Ring_Count : out STD_LOGIC_VECTOR (N-1 downto 0)); end ring_counter; architecture Behavioral of ring_counter is begin process (Clk, Rst) begin if rising_edge(Clk) then if Rst = '1' then Ring_Count <= (others => '0'); else Ring_Count <= std_logic_vector(unsigned(Ring_Count) + 1); end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Johnson_Counter is Generic(N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Johnson_Count : out STD_LOGIC_VECTOR (N-1 downto 0)); end Johnson_Counter; architecture Behavioral of Johnson_Counter is signal count : STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clock, Reset) begin if rising_edge(Clock) then if Reset = '1' then count <= (others => '0'); else count <= count(N-2 downto 0) & not count(N-1); end if; end if; end process; Johnson_Count <= count; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity LinearFeedbackShiftRegister is Generic(N : natural := 8); Port ( Clk : in STD_LOGIC; Rst : in STD_LOGIC; Seed : in STD_LOGIC_VECTOR (N-1 downto 0); LFSR_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end LinearFeedbackShiftRegister; architecture Behavioral of LinearFeedbackShiftRegister is begin process (Clk, Rst) variable LFSR : STD_LOGIC_VECTOR (N-1 downto 0); begin if rising_edge(Clk) then if Rst = '1' then LFSR := Seed; else end if ; end if ; LFSR_Out <= LFSR; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity FiniteStateMachine is Generic(N : natural := 4); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Inputs : in STD_LOGIC_VECTOR ((N-1) downto 0); State : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); Outputs : out STD_LOGIC_VECTOR ((N-1) downto 0)); end FiniteStateMachine; architecture Behavioral of FiniteStateMachine is type state_type is range 0 to N-1; signal current_state : state_type := 0; begin process (Clock, Reset) begin if Reset = '1' then current_state <= 0; elsif rising_edge(Clock) then case current_state is when 0 => current_state <= 1; when 1 => current_state <= 2; end case ; end if ; end process ; State <= std_logic_vector(to_unsigned(current_state, log2(N))); Outputs <= Inputs; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity binary_to_gray is Generic(N : natural := 8); Port ( Binary : in STD_LOGIC_VECTOR (N-1 downto 0); Gray_Code : out STD_LOGIC_VECTOR (N-1 downto 0)); end binary_to_gray; architecture Behavioral of binary_to_gray is begin Gray_Code(0) <= Binary(0); process (Binary) begin for i in 1 to N-1 loop Gray_Code(i) <= Binary(i) xor Binary(i-1); end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity gray_to_binary is Generic(N : natural := 8); Port ( Gray_Code : in STD_LOGIC_VECTOR (N-1 downto 0); Binary : out STD_LOGIC_VECTOR (N-1 downto 0)); end gray_to_binary; architecture Behavioral of gray_to_binary is begin process (Gray_Code) variable temp : STD_LOGIC_VECTOR(N-1 downto 0); begin temp := Gray_Code; for i in 1 to N-1 loop temp(i) := temp(i) xor temp(i-1); end loop ; Binary <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity bcd_to_excess3 is Port ( BCD_In : in STD_LOGIC_VECTOR (3 downto 0); Excess3_Out : out STD_LOGIC_VECTOR (3 downto 0)); end bcd_to_excess3; architecture Behavioral of bcd_to_excess3 is begin process (BCD_In) begin Excess3_Out <= std_logic_vector(unsigned(BCD_In) + 3); end process; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity excess3_to_bcd is Port ( Excess3_In : in STD_LOGIC_VECTOR (3 downto 0); BCD_Out : out STD_LOGIC_VECTOR (3 downto 0)); end excess3_to_bcd; architecture Behavioral of excess3_to_bcd is begin process (Excess3_In) variable temp : integer range 0 to 15 := 0; begin temp := conv_integer(unsigned(Excess3_In)) - 3; BCD_Out <= std_logic_vector(to_unsigned(temp, BCD_Out'length)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity crc_generator is Generic (N : natural := 8; M : natural := 16); Port ( Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Polynomial : in STD_LOGIC_VECTOR (M-1 downto 0); CRC_Value : out STD_LOGIC_VECTOR (M-1 downto 0)); end crc_generator; architecture Behavioral of crc_generator is begin process (Data_In, Polynomial) variable temp_crc : STD_LOGIC_VECTOR (M-1 downto 0); begin temp_crc := (others => '0'); for i in 0 to N-1 loop if Data_In(i) = '1' then temp_crc := temp_crc xor Polynomial; end if ; end loop ; CRC_Value <= temp_crc; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity crc_checker is Generic(N : natural := 8; M : natural := 16); Port ( Data_In : in STD_LOGIC_VECTOR (N-1 downto 0); Received_CRC : in STD_LOGIC_VECTOR (M-1 downto 0); Polynomial : in STD_LOGIC_VECTOR (M-1 downto 0); CRC_Match : out STD_LOGIC); end crc_checker; architecture Behavioral of crc_checker is begin process (Data_In, Received_CRC, Polynomial) variable temp_crc : STD_LOGIC_VECTOR (M-1 downto 0); begin temp_crc := Received_CRC; for i in 0 to N-1 loop if Data_In(i) = '1' then temp_crc := temp_crc XOR Polynomial; end if ; temp_crc := temp_crc(M-2 downto 0) & temp_crc(M-1); end loop ; CRC_Match <= '1' when temp_crc = (others => '0') else '0'; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity serial_to_parallel is Generic ( N : natural := 8 ); Port ( Clk : in STD_LOGIC; Serial_In : in STD_LOGIC; Shift_En : in STD_LOGIC; Parallel_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end serial_to_parallel; architecture Behavioral of serial_to_parallel is signal shift_reg : STD_LOGIC_VECTOR(N-1 downto 0) := (others => '0'); begin process (Clk, Shift_En) begin if rising_edge(Clk) then if Shift_En = '1' then shift_reg <= shift_reg(N-2 downto 0) & Serial_In; end if ; end if ; end process ; Parallel_Out <= shift_reg; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.FLOAT_PACK.ALL; entity FloatingPointAdder is Generic (N : integer := 32); Port (A : in STD_LOGIC_VECTOR (N-1 downto 0); B : in STD_LOGIC_VECTOR (N-1 downto 0); Sum : out STD_LOGIC_VECTOR (N-1 downto 0)); end FloatingPointAdder; architecture Behavioral of FloatingPointAdder is signal A_float, B_float, Sum_float : float32; begin A_float <= to_float(A, 8, 23); B_float <= to_float(B, 8, 23); Sum_float <= A_float + B_float; Sum <= to_slv(Sum_float); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.FLOAT_PACK.ALL; entity FloatingPointMultiplier is Generic(N : natural := 32); Port (A : in STD_LOGIC_VECTOR(N-1 downto 0); B : in STD_LOGIC_VECTOR(N-1 downto 0); Product : out STD_LOGIC_VECTOR(N-1 downto 0)); end FloatingPointMultiplier; architecture Behavioral of FloatingPointMultiplier is signal A_float, B_float, Product_float : float32; begin A_float <= to_float(A, 8, 23); B_float <= to_float(B, 8, 23); Product_float <= A_float * B_float; Product <= to_slv(Product_float); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity fixed_point_divider is Generic ( N : natural := 8 ); Port ( dividend : in signed(N-1 downto 0); divisor : in signed(N-1 downto 0); quotient : out signed(N-1 downto 0); remainder : out signed(N-1 downto 0)); end fixed_point_divider; architecture Behavioral of fixed_point_divider is begin process (dividend, divisor) variable temp_quotient : signed(N-1 downto 0); variable temp_remainder : signed(N-1 downto 0); begin temp_quotient := (others => '0'); temp_remainder := dividend; for i in 0 to N-1 loop if temp_remainder >= divisor then temp_remainder := temp_remainder - divisor; temp_quotient(i) := '1'; end if ; end loop ; quotient <= temp_quotient; remainder <= temp_remainder; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity unsigned_divider is Generic ( N : natural := 8 ); Port ( numerator : in unsigned(N-1 downto 0); denominator : in unsigned(N-1 downto 0); quotient : out unsigned(N-1 downto 0); remainder : out unsigned(N-1 downto 0)); end unsigned_divider; architecture Behavioral of unsigned_divider is begin process (numerator, denominator) variable temp_quotient : unsigned(N-1 downto 0); variable temp_remainder : unsigned(N-1 downto 0); begin temp_quotient := (others => '0'); temp_remainder := numerator; for i in 0 to N-1 loop if temp_remainder >= denominator then temp_remainder := temp_remainder - denominator; temp_quotient(i) := '1'; end if ; end loop ; quotient <= temp_quotient; remainder <= temp_remainder; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity PipelinedMultiplier is Generic (N : natural := 8; M : natural := 16); Port ( Clk : in STD_LOGIC; Factor1 : in SIGNED(N-1 downto 0); Factor2 : in SIGNED(M-1 downto 0); Product : out SIGNED((N+M)-1 downto 0)); end PipelinedMultiplier; architecture Behavioral of PipelinedMultiplier is signal partial_product : SIGNED((N+M)-1 downto 0); begin process (Clk) begin if rising_edge(Clk) then partial_product <= Factor1 * Factor2; end if ; end process ; Product <= partial_product; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.FLOAT_PACK.ALL; entity fixed_to_float is Generic (N : natural := 8; M : natural := 32); Port (fixed_value : in signed(N-1 downto 0); float_value : out std_logic_vector(M-1 downto 0)); end fixed_to_float; architecture Behavioral of fixed_to_float is signal float_value_internal : float32; begin process (fixed_value) begin float_value_internal <= to_float(fixed_value, 0); float_value <= to_slv(float_value_internal); end process; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity bcd_to_binary is Generic(N : integer := 8); Port ( BCD_Value : in STD_LOGIC_VECTOR ((N/4)-1 downto 0); Binary_Value : out STD_LOGIC_VECTOR (N-1 downto 0)); end bcd_to_binary; architecture Behavioral of bcd_to_binary is begin process (BCD_Value) variable temp : STD_LOGIC_VECTOR (N-1 downto 0); begin for i in 0 to N/4 - 1 loop temp((i+1)*4-1 downto i*4) := BCD_Value(i); end loop ; Binary_Value <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity binary_to_bcd is Port ( Binary_Value : in STD_LOGIC_VECTOR ((N-1) downto 0); BCD_Value : out STD_LOGIC_VECTOR (((N/3)+1)-1 downto 0)); end binary_to_bcd; architecture Behavioral of binary_to_bcd is begin process (Binary_Value) variable temp : STD_LOGIC_VECTOR ((N/3)+1-1 downto 0); begin for i in 0 to (N/3)-1 loop temp((i*4+3) downto (i*4)) := Binary_Value(((N-1)-(i*4)) downto ((N-1)-(i*4)+3)); end loop ; BCD_Value <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity parallel_in_parallel_out_shift_register is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Load : in STD_LOGIC; Shift_En : in STD_LOGIC; Shift_Dir : in STD_LOGIC; Parallel_In : in STD_LOGIC_VECTOR (N-1 downto 0); Parallel_Out : out STD_LOGIC_VECTOR (N-1 downto 0)); end parallel_in_parallel_out_shift_register; architecture Behavioral of parallel_in_parallel_out_shift_register is signal reg : STD_LOGIC_VECTOR(N-1 downto 0) := (others => '0'); begin process (Clock, Load, Shift_En, Shift_Dir, Parallel_In) begin if rising_edge(Clock) then if Load = '1' then reg <= Parallel_In; elsif Shift_En = '1' then if Shift_Dir = '0' then reg <= reg(N-2 downto 0) & Parallel_In(N-1); else reg <= Parallel_In(0) & reg(N-1 downto 1); end if ; end if ; end if ; end process ; Parallel_Out <= reg; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity JohnsonRingCounter is Generic(N : natural := 8); Port (Clk : in STD_LOGIC; Reset : in STD_LOGIC; Johnson_Count : out STD_LOGIC_VECTOR (N-1 downto 0)); end JohnsonRingCounter; architecture Behavioral of JohnsonRingCounter is signal count : STD_LOGIC_VECTOR(N-1 downto 0) := (others => '0'); begin process (Clk, Reset) begin if Reset = '1' then count <= (others => '0'); elsif rising_edge(Clk) then count <= count(N-2 downto 0) & not count(N-1); end if; end process; Johnson_Count <= count; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity PRNG is Generic (N : natural := 8); Port (Clock : in STD_LOGIC; Seed : in STD_LOGIC_VECTOR (N-1 downto 0); Random_Number : out STD_LOGIC_VECTOR (N-1 downto 0)); end PRNG; architecture Behavioral of PRNG is signal lfsr : STD_LOGIC_VECTOR(N-1 downto 0); signal feedback : STD_LOGIC; begin process (Clock) begin if rising_edge(Clock) then feedback <= lfsr(N-1) xor lfsr(N-2); lfsr <= feedback & lfsr(N-1 downto 1); end if; end process; process (Seed) begin lfsr <= Seed; end process; Random_Number <= lfsr; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity fir_filter is Generic ( N : natural := 8; M : natural := 5 ); Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Data_In : in signed(N-1 downto 0); Coefficients : in signed(M*N-1 downto 0); Filtered_Out : out signed(N-1 downto 0) ); end fir_filter; architecture Behavioral of fir_filter is type coeff_array is array (0 to M-1) of signed(N-1 downto 0); signal coeffs : coeff_array := (others => (others => '0')); signal accumulator : signed(M*N downto 0) := (others => '0'); begin process (Clk, Reset) begin if Reset = '1' then accumulator <= (others => '0'); elsif rising_edge(Clk) then for i in 0 to M-1 loop coeffs(i) <= Coefficients((i+1)*N-1 downto i*N); end loop ; accumulator <= accumulator + Data_In * coeffs(M-1); for i in 0 to M-2 loop accumulator <= accumulator - coeffs(i) * coeffs(M-1-i); end loop ; end if ; end process ; Filtered_Out <= accumulator(N-1 downto 0); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity iir_filter is Generic ( N : natural := 8; M : natural := 3 ); Port ( clk : in std_logic; rst : in std_logic; input_data : in signed(N-1 downto 0); coeffs : in signed(M*N-1 downto 0) ); end iir_filter; architecture Behavioral of iir_filter is type delay_line is array (0 to M-1) of signed(N-1 downto 0); signal delay : delay_line := (others => (others => '0')); signal accumulator : signed(M*N downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then delay <= (others => (others => '0')); accumulator <= (others => '0'); elsif rising_edge(clk) then delay(M-1 downto 1) <= delay(M-2 downto 0); delay(0) <= input_data; accumulator <= (others => '0'); for i in 0 to M-1 loop accumulator := accumulator + coeffs((i+1)*N-1 downto i*N) * delay(i); end loop ; end if ; end process ; filtered_data <= accumulator(N-1 downto 0); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Digital_PID_Controller is Generic ( N : natural := 8 ); Port ( Clk : in STD_LOGIC; Rst : in STD_LOGIC; Set_Point : in STD_LOGIC_VECTOR (N-1 downto 0); Process_Value : in STD_LOGIC_VECTOR (N-1 downto 0); Kp, Ki, Kd : in STD_LOGIC_VECTOR (N-1 downto 0); Control_Output : out STD_LOGIC_VECTOR (N-1 downto 0)); end Digital_PID_Controller; architecture Behavioral of Digital_PID_Controller is signal Error, Proportional, Integral, Derivative, Output : signed(N-1 downto 0); begin process (Clk) begin if rising_edge(Clk) then if Rst = '1' then Error <= (others => '0'); Proportional <= (others => '0'); Integral <= (others => '0'); Derivative <= (others => '0'); Output <= (others => '0'); else Error <= signed(Set_Point) - signed(Process_Value); Proportional <= Proportional + Kp * Error; Integral <= Integral + Ki * Error; Derivative <= Derivative + Kd * (Error - Error'delay(1 ns)); Output <= Proportional + Integral + Derivative; end if ; end if ; end process ; Control_Output <= std_logic_vector(Output); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity DigitalIntegrator is Generic ( N : natural := 8 ); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Input_Data : in STD_LOGIC_VECTOR (N-1 downto 0); Integrated_Data : out STD_LOGIC_VECTOR (N-1 downto 0)); end DigitalIntegrator; architecture Behavioral of DigitalIntegrator is signal Accumulator : signed(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then Accumulator <= (others => '0'); elsif rising_edge(Clock) then Accumulator <= Accumulator + signed(Input_Data); end if ; end process ; Integrated_Data <= std_logic_vector(Accumulator); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Digital_Differentiator is Generic ( N : natural := 8 ); Port ( Clk : in STD_LOGIC; Input_Data : in STD_LOGIC_VECTOR (N-1 downto 0); Differentiated_Data : out STD_LOGIC_VECTOR (N-1 downto 0)); end Digital_Differentiator; architecture Behavioral of Digital_Differentiator is signal previous_input : STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clk) begin if rising_edge(Clk) then Differentiated_Data <= Input_Data - previous_input; previous_input <= Input_Data; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity pwm_generator is Generic (N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Duty_Cycle : in STD_LOGIC_VECTOR (N-1 downto 0); PWM_Out : out STD_LOGIC); end pwm_generator; architecture Behavioral of pwm_generator is signal count : unsigned(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then count <= (others => '0'); PWM_Out <= '0'; elsif rising_edge(Clock) then if count < unsigned(Duty_Cycle) then PWM_Out <= '1'; else PWM_Out <= '0'; end if ; count <= count + 1; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity glitch_filter is Port ( Noisy_In : in STD_LOGIC; Filtered_Out : out STD_LOGIC); end glitch_filter; architecture Behavioral of glitch_filter is signal delay_line : std_logic := '0'; begin process (Noisy_In) begin if rising_edge(Noisy_In) then delay_line <= Noisy_In; end if ; end process ; Filtered_Out <= delay_line; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity SchmittTriggerCircuit is Port ( Analog_In : in STD_LOGIC; Digital_Out : out STD_LOGIC); end SchmittTriggerCircuit; architecture Behavioral of SchmittTriggerCircuit is signal previous_Analog_In : STD_LOGIC := '0'; begin process (Analog_In) begin if rising_edge(Analog_In) then Digital_Out <= '1'; elsif falling_edge(Analog_In) then Digital_Out <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity pulse_generator is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Pulse_Width : in STD_LOGIC_VECTOR (N-1 downto 0); Pulse_Out : out STD_LOGIC); end pulse_generator; architecture Behavioral of pulse_generator is signal counter : unsigned(N-1 downto 0) := (others => '0'); begin process (Clk, Reset) begin if Reset = '1' then counter <= (others => '0'); Pulse_Out <= '0'; elsif rising_edge(Clk) then if counter < unsigned(Pulse_Width) then counter <= counter + 1; Pulse_Out <= '1'; else counter <= (others => '0'); Pulse_Out <= '0'; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity MonostableMultivibrator is Generic(N : natural := 8); Port ( Trigger_In : in STD_LOGIC; Pulse_Out : out STD_LOGIC; Pulse_Duration : inout STD_LOGIC_VECTOR (N-1 downto 0)); end MonostableMultivibrator; architecture Behavioral of MonostableMultivibrator is signal Counter : unsigned(N-1 downto 0) := (others => '0'); begin process (Trigger_In, Counter) begin if rising_edge(Trigger_In) then Counter <= (others => '0'); elsif Counter < unsigned(Pulse_Duration) then Counter <= Counter + 1; else Pulse_Out <= '0'; end if ; end process ; process (Counter) begin if Counter = unsigned(Pulse_Duration) then Pulse_Out <= '1'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity AstableMultivibrator is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Oscillating_Out : out STD_LOGIC); end AstableMultivibrator; architecture Behavioral of AstableMultivibrator is signal Q1, Q2: STD_LOGIC := '0'; begin process (Clk, Reset) begin if Reset = '1' then Q1 <= '0'; Q2 <= '0'; elsif rising_edge(Clk) then Q1 <= not Q1; Q2 <= not Q2; end if ; end process ; Oscillating_Out <= Q1 XOR Q2; end Behavioral;
entity comparator is port(clock: in std_logic; A,B: in std_logic_vector(7 downto 0); IAB: in std_logic; Output: out std_logic); end comparator;
entity comparator is port(clock: in std_logic; A,B: in std_logic_vector(7 downto 0); IAB: in std_logic; Output: out std_logic); end comparator;
architecture Behavioral of comparator is signal AB: std_logic_vector(7 downto 0); signal Result: std_logic; begin AB(0) <= (not A(0)) xnor (not B(0)); end Behavioral;
AB(2) <= (not A(2)) xnor (not B(2)); 
AB(3) <= (not A(3)) xnor (not B(3)); 
AB(4) <= (not A(4)) xnor (not B(4)); 
AB(5) <= (not A(5)) xnor (not B(5)); 
AB(6) <= (not A(6)) xnor (not B(6)); 
AB(7) <= (not A(7)) xnor (not B(7));
process(clock) begin if rising_edge(clock) then Result <= '0' when AB = x"FF" and IAB = '0' else '1'; end if; end process;
clock_process : process begin clock <= '0'; wait for clock_period/2; clock <= '1'; wait for clock_period/2; end process;
process(clk) begin  counter <= counter + x"0000001" when rising_edge(clk) else (others => '0') when counter >= x"003D08F" else counter; end process;
entity fifo_mem is port(data_out : out std_logic_vector(7 downto 0); fifo_full, fifo_empty, fifo_threshold, fifo_overflow, fifo_underflow: out std_logic; clk :in std_logic; rst_n: in std_logic; wr :in  std_logic; rd: in std_logic; data_in: in std_logic_vector(7 downto 0)); end fifo_mem;
component write_pointer port ( wptr : out std_logic_vector(4 downto 0); fifo_we : out std_logic; clk : in std_logic; rst_n: in std_logic; wr : in std_logic; fifo_full: in std_logic ); end component;
component read_pointer port ( rptr : out std_logic_vector(4 downto 0); fifo_rd : out std_logic; clk : in std_logic; rst_n: in std_logic; rd : in  std_logic; fifo_empty: in std_logic ); end component;
entity counter_4bit is port (clk : in std_logic; rst : in std_logic; q : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of counter_4bit is signal count : std_logic_vector(3 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then count <= (others => '0'); elsif rising_edge(clk) then count <= count + 1; end if; end process; q <= count; end architecture;
entity shift_register_8bit is port (clk : in std_logic; rst : in std_logic; serial_in : in std_logic; q : out std_logic_vector(7 downto 0)); end entity; architecture Behavioral of shift_register_8bit is signal shift_reg : std_logic_vector(7 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then shift_reg <= (others => '0'); elsif rising_edge(clk) then shift_reg <= serial_in & shift_reg(7 downto 1); end if; end process; q <= shift_reg; end architecture;
entity mux_4to1 is port (d0, d1, d2, d3 : in std_logic; sel : in std_logic_vector(1 downto 0); y : out std_logic); end entity; architecture Behavioral of mux_4to1 is begin process (d0, d1, d2, d3, sel) begin case sel is when "00" => y <= d0; when "01" => y <= d1; when "02" => y <= d2; when others => y <= d3; end case; end process; end architecture;
entity priority_encoder_4to2 is port (d : in std_logic_vector(3 downto 0); y : out std_logic_vector(1 downto 0); valid : out std_logic); end entity; architecture Behavioral of priority_encoder_4to2 is begin process (d) begin if d(3) = '1' then y <= "11"; valid <= '1'; elsif d(2) = '1' then y <= "10"; valid <= '1'; elsif d(1) = '1' then y <= "01"; valid <= '1'; elsif d(0) = '1' then y <= "00"; valid <= '1'; else y <= "00"; valid <= '0'; end if; end process; end architecture;
entity full_adder is port (a, b, cin : in std_logic; sum, cout : out std_logic); end entity; architecture Behavioral of full_adder is begin sum <= a xor b xor cin; cout <= (a and b) or (cin and (a xor b)); end architecture;
entity register_8bit is port (clk : in std_logic; load : in std_logic; d : in std_logic_vector(7 downto 0); q : out std_logic_vector(7 downto 0)); end entity; architecture Behavioral of register_8bit is signal reg : std_logic_vector(7 downto 0); begin process (clk) begin if rising_edge(clk) then if load = '1' then reg <= d; end if; end if; end process; q <= reg; end architecture;
entity comparator_4bit is port (a, b : in std_logic_vector(3 downto 0); gt : out std_logic); end entity; architecture Behavioral of comparator_4bit is begin process (a, b) begin if a > b then gt <= '1'; else gt <= '0'; end if; end process; end architecture;
entity debouncer is port (clk : in std_logic; btn_in : in std_logic; btn_out : out std_logic); end entity; architecture Behavioral of debouncer is signal shift_reg : std_logic_vector(15 downto 0); begin process (clk) begin if rising_edge(clk) then shift_reg <= shift_reg(14 downto 0) & btn_in; if shift_reg = (others => '1') then btn_out <= '1'; elsif shift_reg = (others => '0') then btn_out <= '0'; end if; end if; end process; end architecture;
entity bcd_to_7segment is port (bcd : in std_logic_vector(3 downto 0); seg : out std_logic_vector(6 downto 0)); end entity; architecture Behavioral of bcd_to_7segment is begin process (bcd) begin case bcd is when "0000" => seg <= "1111110"; when "0001" => seg <= "0110000"; when "0010" => seg <= "1101101"; when "0011" => seg <= "1111001"; when "0100" => seg <= "0110011"; when "0101" => seg <= "1011011"; when "0110" => seg <= "1011111"; when "0111" => seg <= "1110000"; when "1000" => seg <= "1111111"; when "1001" => seg <= "1111011"; when others => seg <= "0000000"; end case; end process; end architecture;
entity uart_tx is port (clk : in std_logic; tx_start : in std_logic; tx_data : in std_logic_vector(7 downto 0); tx : out std_logic; tx_busy : out std_logic); end entity; architecture Behavioral of uart_tx is signal shift_reg : std_logic_vector(9 downto 0); signal bit_count : integer range 0 to 9; signal busy : std_logic := '0'; begin process (clk) begin if rising_edge(clk) then if tx_start = '1' and busy = '0' then shift_reg <= '0' & tx_data & '1'; bit_count <= 0; busy <= '1'; elsif busy = '1' then tx <= shift_reg(0); shift_reg <= '0' & shift_reg(9 downto 1); bit_count <= bit_count + 1; if bit_count = 9 then busy <= '0'; end if; end if; end if; end process; tx_busy <= busy; end architecture;
entity freq_div is port (clk_in : in std_logic; clk_out : out std_logic); end entity; architecture Behavioral of freq_div is signal count : integer range 0 to 3 := 0; signal clk_reg : std_logic := '0'; begin process (clk_in) begin if rising_edge(clk_in) then if count = 3 then count <= 0; clk_reg <= not clk_reg; else count <= count + 1; end if; end if; end process; clk_out <= clk_reg; end architecture;
entity updown_counter is port (clk : in std_logic; rst : in std_logic; up_down : in std_logic; count : out std_logic_vector(2 downto 0)); end entity; architecture Behavioral of updown_counter is signal cnt : std_logic_vector(2 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then cnt <= (others => '0'); elsif rising_edge(clk) then if up_down = '1' then cnt <= cnt + 1; else cnt <= cnt - 1; end if; end if; end process; count <= cnt; end architecture;
entity parity_gen is port (data : in std_logic_vector(3 downto 0); parity : out std_logic); end entity; architecture Behavioral of parity_gen is begin process (data) begin parity <= data(0) xor data(1) xor data(2) xor data(3); end process; end architecture;
entity pwm_gen is port (clk : in std_logic; duty_cycle : in std_logic_vector(7 downto 0); pwm_out : out std_logic); end entity; architecture Behavioral of pwm_gen is signal count : std_logic_vector(7 downto 0) := (others => '0'); begin process (clk) begin if rising_edge(clk) then count <= count + 1; if count < duty_cycle then pwm_out <= '1'; else pwm_out <= '0'; end if; end if; end process; end architecture;
entity signed_multiplier is port (a, b : in std_logic_vector(3 downto 0); product : out std_logic_vector(7 downto 0)); end entity; architecture Behavioral of signed_multiplier is begin process (a, b) begin product <= std_logic_vector(signed(a) * signed(b)); end process; end architecture;
entity gray_counter is port (clk : in std_logic; rst : in std_logic; gray_out : out std_logic_vector(2 downto 0)); end entity; architecture Behavioral of gray_counter is signal count : std_logic_vector(2 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then count <= (others => '0'); elsif rising_edge(clk) then count <= count + 1; end if; end process; gray_out <= count xor (count srl 1); end architecture;
entity johnson_counter is port (clk : in std_logic; rst : in std_logic; q : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of johnson_counter is signal count : std_logic_vector(3 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then count <= (others => '0'); elsif rising_edge(clk) then count <= count(2 downto 0) & not count(3); end if; end process; q <= count; end architecture;
entity digital_clock is port (clk : in std_logic; rst : in std_logic; hours, minutes, seconds : out std_logic_vector(5 downto 0)); end entity; architecture Behavioral of digital_clock is signal sec_count : std_logic_vector(5 downto 0) := (others => '0'); signal min_count : std_logic_vector(5 downto 0) := (others => '0'); signal hr_count : std_logic_vector(5 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then sec_count <= (others => '0'); min_count <= (others => '0'); hr_count <= (others => '0'); elsif rising_edge(clk) then if sec_count = 59 then sec_count <= (others => '0'); if min_count = 59 then min_count <= (others => '0'); if hr_count = 23 then hr_count <= (others => '0'); else hr_count <= hr_count + 1; end if; else min_count <= min_count + 1; end if; else sec_count <= sec_count + 1; end if; end if; end process; seconds <= sec_count; minutes <= min_count; hours <= hr_count; end architecture;
entity edge_detector is port (clk : in std_logic; signal_in : in std_logic; edge_detected : out std_logic); end entity; architecture Behavioral of edge_detector is signal prev_signal : std_logic := '0'; begin process (clk) begin if rising_edge(clk) then if signal_in = '1' and prev_signal = '0' then edge_detected <= '1'; else edge_detected <= '0'; end if; prev_signal <= signal_in; end if; end process; end architecture;
entity fifo is port (clk : in std_logic; rst : in std_logic; write_en : in std_logic; read_en : in std_logic; data_in : in std_logic_vector(7 downto 0); data_out : out std_logic_vector(7 downto 0); empty : out std_logic; full : out std_logic); end entity; architecture Behavioral of fifo is type memory is array (0 to 15) of std_logic_vector(7 downto 0); signal mem : memory := (others => (others => '0')); signal write_ptr, read_ptr : integer range 0 to 15 := 0; signal fifo_count : integer range 0 to 16 := 0; begin process (clk, rst) begin if rst = '1' then write_ptr <= 0; read_ptr <= 0; fifo_count <= 0; elsif rising_edge(clk) then if write_en = '1' and fifo_count < 16 then mem(write_ptr) <= data_in; write_ptr <= (write_ptr + 1) mod 16; fifo_count <= fifo_count + 1; end if; if read_en = '1' and fifo_count > 0 then data_out <= mem(read_ptr); read_ptr <= (read_ptr + 1) mod 16; fifo_count <= fifo_count - 1; end if; end if; end process; empty <= '1' when fifo_count = 0 else '0'; full <= '1' when fifo_count = 16 else '0'; end architecture;
entity pulse_gen is port (clk : in std_logic; rst : in std_logic; pulse_out : out std_logic); end entity; architecture Behavioral of pulse_gen is constant N : integer := 10; signal count : integer range 0 to N-1 := 0; begin process (clk, rst) begin if rst = '1' then count <= 0; pulse_out <= '0'; elsif rising_edge(clk) then if count = N-1 then count <= 0; pulse_out <= '1'; else count <= count + 1; pulse_out <= '0'; end if; end if; end process; end architecture;
entity alu is port (a, b : in std_logic_vector(3 downto 0); sel : in std_logic_vector(1 downto 0); result : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of alu is begin process (a, b, sel) begin case sel is when "00" => result <= a + b; when "01" => result <= a - b; when "10" => result <= a and b; when others => result <= a or b; end case; end process; end architecture;
entity lfsr is port (clk : in std_logic; rst : in std_logic; lfsr_out : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of lfsr is signal lfsr_reg : std_logic_vector(3 downto 0) := "0001"; begin process (clk, rst) begin if rst = '1' then lfsr_reg <= "0001"; elsif rising_edge(clk) then lfsr_reg <= lfsr_reg(2 downto 0) & (lfsr_reg(3) xor lfsr_reg(2)); end if; end process; lfsr_out <= lfsr_reg; end architecture;
entity bin_to_gray is port (bin : in std_logic_vector(3 downto 0); gray : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of bin_to_gray is begin process (bin) begin gray(3) <= bin(3); gray(2) <= bin(3) xor bin(2); gray(1) <= bin(2) xor bin(1); gray(0) <= bin(1) xor bin(0); end process; end architecture;
entity gray_to_bin is port (gray : in std_logic_vector(3 downto 0); bin : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of gray_to_bin is begin process (gray) begin bin(3) <= gray(3); bin(2) <= bin(3) xor gray(2); bin(1) <= bin(2) xor gray(1); bin(0) <= bin(1) xor gray(0); end process; end architecture;
entity dff_sync_reset is port (clk : in std_logic; rst : in std_logic; d : in std_logic; q : out std_logic); end entity; architecture Behavioral of dff_sync_reset is begin process (clk) begin if rising_edge(clk) then if rst = '1' then q <= '0'; else q <= d; end if; end if; end process; end architecture;
entity dual_port_ram is port (clk : in std_logic; we : in std_logic; addr_a, addr_b : in std_logic_vector(3 downto 0); data_in : in std_logic_vector(7 downto 0); data_out_a, data_out_b : out std_logic_vector(7 downto 0)); end entity; architecture Behavioral of dual_port_ram is type ram_type is array (0 to 15) of std_logic_vector(7 downto 0); signal ram : ram_type := (others => (others => '0')); begin process (clk) begin if rising_edge(clk) then if we = '1' then ram(to_integer(unsigned(addr_a))) <= data_in; end if; data_out_a <= ram(to_integer(unsigned(addr_a))); data_out_b <= ram(to_integer(unsigned(addr_b))); end if; end process; end architecture;
entity seven_segment_driver is port (clk : in std_logic; rst : in std_logic; digit : in std_logic_vector(15 downto 0); segments : out std_logic_vector(6 downto 0)); end entity; architecture Behavioral of seven_segment_driver is signal digit_index : integer range 0 to 3 := 0; signal digit_reg : std_logic_vector(3 downto 0); begin process (clk, rst) begin if rst = '1' then digit_index <= 0; digit_reg <= "0000"; elsif rising_edge(clk) then digit_index <= (digit_index + 1) mod 4; digit_reg <= digit(4 * digit_index + 3 downto 4 * digit_index); end if; end process; process (digit_reg) begin case digit_reg is when "0000" => segments <= "1111110"; when "0001" => segments <= "0110000"; when "0010" => segments <= "1101101"; when "0011" => segments <= "1111001"; when "0100" => segments <= "0110011"; when "0101" => segments <= "1011011"; when "0110" => segments <= "1011111"; when "0111" => segments <= "1110000"; when "1000" => segments <= "1111111"; when "1001" => segments <= "1111011"; when others => segments <= "0000000"; end case; end process; end architecture;
entity counter_with_enable is port (clk : in std_logic; rst : in std_logic; en : in std_logic; count : out std_logic_vector(7 downto 0)); end entity; architecture Behavioral of counter_with_enable is signal cnt : std_logic_vector(7 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then cnt <= (others => '0'); elsif rising_edge(clk) then if en = '1' then cnt <= cnt + 1; end if; end if; end process; count <= cnt; end architecture;
entity bin_to_bcd is port (bin : in std_logic_vector(7 downto 0); bcd : out std_logic_vector(11 downto 0)); end entity; architecture Behavioral of bin_to_bcd is begin process (bin) variable bcd_tmp : std_logic_vector(11 downto 0) := (others => '0'); variable bin_tmp : std_logic_vector(7 downto 0) := bin; begin for i in 0 to 7 loop if bcd_tmp(11 downto 8) > "0100" then bcd_tmp(11 downto 8) := bcd_tmp(11 downto 8) + 3; end if; if bcd_tmp(7 downto 4) > "0100" then bcd_tmp(7 downto 4) := bcd_tmp(7 downto 4) + 3; end if; if bcd_tmp(3 downto 0) > "0100" then bcd_tmp(3 downto 0) := bcd_tmp(3 downto 0) + 3; end if; bcd_tmp := bcd_tmp(10 downto 0) & bin_tmp(7); bin_tmp := bin_tmp(6 downto 0) & '0'; end loop; bcd <= bcd_tmp; end process; end architecture;
entity timer is port (clk : in std_logic; rst : in std_logic; start : in std_logic; preset : in std_logic_vector(7 downto 0); time_out : out std_logic); end entity; architecture Behavioral of timer is signal count : std_logic_vector(7 downto 0) := (others => '0'); signal running : std_logic := '0'; begin process (clk, rst) begin if rst = '1' then count <= (others => '0'); running <= '0'; elsif rising_edge(clk) then if start = '1' then count <= preset; running <= '1'; elsif running = '1' then if count = "00000000" then running <= '0'; else count <= count - 1; end if; end if; end if; end process; time_out <= '1' when count = "00000000" and running = '1' else '0'; end architecture;
entity spi_master is port (clk : in std_logic; rst : in std_logic; start : in std_logic; data_in : in std_logic_vector(7 downto 0); mosi : out std_logic; sclk : out std_logic; cs : out std_logic; data_out : out std_logic_vector(7 downto 0); done : out std_logic); end entity; architecture Behavioral of spi_master is signal shift_reg : std_logic_vector(7 downto 0); signal bit_count : integer range 0 to 7 := 0; signal busy : std_logic := '0'; begin process (clk, rst) begin if rst = '1' then shift_reg <= (others => '0'); bit_count <= 0; busy <= '0'; cs <= '1'; sclk <= '0'; elsif rising_edge(clk) then if start = '1' and busy = '0' then shift_reg <= data_in; bit_count <= 0; busy <= '1'; cs <= '0'; elsif busy = '1' then sclk <= not sclk; if sclk = '0' then mosi <= shift_reg(7); shift_reg <= shift_reg(6 downto 0) & '0'; bit_count <= bit_count + 1; if bit_count = 7 then busy <= '0'; cs <= '1'; data_out <= shift_reg; end if; end if; end if; end if; end process; done <= '1' when busy = '0' else '0'; end architecture;
entity i2c_slave is port (clk : in std_logic; rst : in std_logic; scl : in std_logic; sda_in : in std_logic; sda_out : out std_logic; data_out : out std_logic_vector(7 downto 0); data_valid : out std_logic); end entity; architecture Behavioral of i2c_slave is type state_type is (IDLE, ADDRESS, READ, WRITE, ACK); signal state : state_type := IDLE; signal shift_reg : std_logic_vector(7 downto 0); signal bit_count : integer range 0 to 7 := 0; signal ack : std_logic := '0'; begin process (clk, rst) begin if rst = '1' then state <= IDLE; shift_reg <= (others => '0'); bit_count <= 0; ack <= '0'; elsif rising_edge(clk) then case state is when IDLE => if scl = '1' and sda_in = '0' then state <= ADDRESS; end if; when ADDRESS => if bit_count = 7 then state <= ACK; else shift_reg(bit_count) <= sda_in; bit_count <= bit_count + 1; end if; when ACK => ack <= '1'; if scl = '1' and sda_in = '0' then state <= READ; else state <= WRITE; end if; when READ => data_out <= shift_reg; data_valid <= '1'; state <= IDLE; when WRITE => if bit_count = 7 then state <= ACK; else shift_reg(bit_count) <= sda_in; bit_count <= bit_count + 1; end if; when others => state <= IDLE; end case; end if; end process; sda_out <= ack; end architecture;
entity ring_counter is port (clk : in std_logic; rst : in std_logic; q : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of ring_counter is signal count : std_logic_vector(3 downto 0) := "0001"; begin process (clk, rst) begin if rst = '1' then count <= "0001"; elsif rising_edge(clk) then count <= count(2 downto 0) & count(3); end if; end process; q <= count; end architecture;
entity mealy_fsm is port (clk : in std_logic; rst : in std_logic; x : in std_logic; z : out std_logic); end entity; architecture Behavioral of mealy_fsm is type state_type is (S0, S1, S2); signal state, next_state : state_type := S0; begin process (clk, rst) begin if rst = '1' then state <= S0; elsif rising_edge(clk) then state <= next_state; end if; end process; process (state, x) begin case state is when S0 => if x = '1' then next_state <= S1; else next_state <= S0; end if; z <= '0'; when S1 => if x = '0' then next_state <= S2; else next_state <= S1; end if; z <= '0'; when S2 => if x = '1' then next_state <= S0; else next_state <= S2; end if; z <= '1'; when others => next_state <= S0; z <= '0'; end case; end process; end architecture;
entity sequential_multiplier is port (clk : in std_logic; rst : in std_logic; start : in std_logic; a, b : in std_logic_vector(3 downto 0); product : out std_logic_vector(7 downto 0); done : out std_logic); end entity; architecture Behavioral of sequential_multiplier is signal multiplicand, multiplier : std_logic_vector(3 downto 0); signal product_reg : std_logic_vector(7 downto 0) := (others => '0'); signal count : integer range 0 to 3 := 0; signal busy : std_logic := '0'; begin process (clk, rst) begin if rst = '1' then multiplicand <= (others => '0'); multiplier <= (others => '0'); product_reg <= (others => '0'); count <= 0; busy <= '0'; elsif rising_edge(clk) then if start = '1' and busy = '0' then multiplicand <= a; multiplier <= b; product_reg <= (others => '0'); count <= 0; busy <= '1'; elsif busy = '1' then if multiplier(0) = '1' then product_reg(3 downto 0) <= product_reg(3 downto 0) + multiplicand; end if; product_reg(7 downto 4) <= product_reg(6 downto 0) & '0'; multiplier <= '0' & multiplier(3 downto 1); count <= count + 1; if count = 3 then busy <= '0'; end if; end if; end if; end process; product <= product_reg; done <= '1' when busy = '0' else '0'; end architecture;
entity barrel_shifter is port (data_in : in std_logic_vector(3 downto 0); shift : in std_logic_vector(1 downto 0); data_out : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of barrel_shifter is begin process (data_in, shift) begin case shift is when "00" => data_out <= data_in; when "01" => data_out <= data_in(2 downto 0) & '0'; when "10" => data_out <= data_in(1 downto 0) & "00"; when others => data_out <= data_in(0) & "000"; end case; end process; end architecture;
entity uart_tx is port (clk : in std_logic; rst : in std_logic; tx_start : in std_logic; tx_data : in std_logic_vector(7 downto 0); tx_serial : out std_logic; tx_done : out std_logic); end entity; architecture Behavioral of uart_tx is signal shift_reg : std_logic_vector(9 downto 0); signal bit_count : integer range 0 to 9 := 0; signal busy : std_logic := '0'; begin process (clk, rst) begin if rst = '1' then shift_reg <= (others => '0'); bit_count <= 0; busy <= '0'; tx_serial <= '1'; elsif rising_edge(clk) then if tx_start = '1' and busy = '0' then shift_reg <= '0' & tx_data & '1'; bit_count <= 0; busy <= '1'; elsif busy = '1' then tx_serial <= shift_reg(0); shift_reg <= '1' & shift_reg(9 downto 1); bit_count <= bit_count + 1; if bit_count = 9 then busy <= '0'; end if; end if; end if; end process; tx_done <= '1' when busy = '0' else '0'; end architecture;
entity uart_rx is port (clk : in std_logic; rst : in std_logic; rx_serial : in std_logic; rx_data : out std_logic_vector(7 downto 0); rx_done : out std_logic); end entity; architecture Behavioral of uart_rx is signal shift_reg : std_logic_vector(9 downto 0); signal bit_count : integer range 0 to 9 := 0; signal busy : std_logic := '0'; begin process (clk, rst) begin if rst = '1' then shift_reg <= (others => '0'); bit_count <= 0; busy <= '0'; elsif rising_edge(clk) then if busy = '0' and rx_serial = '0' then busy <= '1'; bit_count <= 0; elsif busy = '1' then shift_reg <= rx_serial & shift_reg(9 downto 1); bit_count <= bit_count + 1; if bit_count = 9 then busy <= '0'; rx_data <= shift_reg(8 downto 1); end if; end if; end if; end process; rx_done <= '1' when busy = '0' else '0'; end architecture;
entity parity_gen is port (data_in : in std_logic_vector(7 downto 0); parity_out : out std_logic); end entity; architecture Behavioral of parity_gen is begin process (data_in) begin parity_out <= not (data_in(0) xor data_in(1) xor data_in(2) xor data_in(3) xor data_in(4) xor data_in(5) xor data_in(6) xor data_in(7)); end process; end architecture;
entity parity_check is port (data_in : in std_logic_vector(7 downto 0); parity_in : in std_logic; error : out std_logic); end entity; architecture Behavioral of parity_check is begin process (data_in, parity_in) begin error <= not (data_in(0) xor data_in(1) xor data_in(2) xor data_in(3) xor data_in(4) xor data_in(5) xor data_in(6) xor data_in(7) xor parity_in); end process; end architecture;
entity manchester_encoder is port (clk : in std_logic; rst : in std_logic; data_in : in std_logic_vector(7 downto 0); encoded_out : out std_logic); end entity; architecture Behavioral of manchester_encoder is signal manchester_reg : std_logic_vector(15 downto 0); signal bit_count : integer range 0 to 15 := 0; begin process (clk, rst) begin if rst = '1' then manchester_reg <= (others => '0'); bit_count <= 0; encoded_out <= '0'; elsif rising_edge(clk) then if bit_count = 0 then manchester_reg <= (others => '0'); for i in 0 to 7 loop manchester_reg(2*i+1 downto 2*i) <= "10" when data_in(i) = '1' else "01"; end loop; bit_count <= 15; else encoded_out <= manchester_reg(bit_count); bit_count <= bit_count - 1; end if; end if; end process; end architecture;
entity manchester_decoder is port (clk : in std_logic; rst : in std_logic; encoded_in : in std_logic; data_out : out std_logic_vector(7 downto 0)); end entity; architecture Behavioral of manchester_decoder is signal shift_reg : std_logic_vector(15 downto 0); signal bit_count : integer range 0 to 15 := 0; begin process (clk, rst) begin if rst = '1' then shift_reg <= (others => '0'); bit_count <= 0; data_out <= (others => '0'); elsif rising_edge(clk) then shift_reg <= shift_reg(14 downto 0) & encoded_in; if bit_count = 15 then data_out <= (others => '0'); for i in 0 to 7 loop data_out(i) <= '1' when shift_reg(2*i+1 downto 2*i) = "10" else '0'; end loop; bit_count <= 0; else bit_count <= bit_count + 1; end if; end if; end process; end architecture;
entity gray_code_counter is port (clk : in std_logic; rst : in std_logic; gray_code : out std_logic_vector(2 downto 0)); end entity; architecture Behavioral of gray_code_counter is signal bin_count : std_logic_vector(2 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then bin_count <= (others => '0'); elsif rising_edge(clk) then bin_count <= bin_count + 1; end if; end process; gray_code <= bin_count xor (bin_count(2 downto 1) & '0'); end architecture;
entity bidir_shift_reg is port (clk : in std_logic; rst : in std_logic; dir : in std_logic; data_in : in std_logic; data_out : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of bidir_shift_reg is signal shift_reg : std_logic_vector(3 downto 0); begin process (clk, rst) begin if rst = '1' then shift_reg <= (others => '0'); elsif rising_edge(clk) then if dir = '1' then shift_reg <= shift_reg(2 downto 0) & data_in; else shift_reg <= data_in & shift_reg(3 downto 1); end if; end if; end process; data_out <= shift_reg; end architecture;
entity comparator is port (a, b : in std_logic_vector(3 downto 0); lt, gt, eq : out std_logic); end entity; architecture Behavioral of comparator is begin process (a, b) begin if a < b then lt <= '1'; gt <= '0'; eq <= '0'; elsif a > b then lt <= '0'; gt <= '1'; eq <= '0'; else lt <= '0'; gt <= '0'; eq <= '1'; end if; end process; end architecture;
process(clk,rst)begin if rst='1'then shift_reg<=(others=>'0');parallel_out<=(others=>'0');bit_count<=0;elsif rising_edge(clk)then shift_reg<=shift_reg(6 downto 0)&serial_in;bit_count<=bit_count+1;if bit_count=7 then parallel_out<=shift_reg;bit_count<=0;end if;end if;end process;
process(clk,rst)begin if rst='1'then ring_counter<="0001";elsif rising_edge(clk)then ring_counter<=ring_counter(2 downto 0)&ring_counter(3);end if;end process;
process(clk,rst)begin if rst='1'then johnson_counter<="0000";elsif rising_edge(clk)then johnson_counter<=not johnson_counter(3)&johnson_counter(3 downto 1);end if;end process;
process(binary_in)begin case binary_in is when "0000"=>bcd_out<="0000";when "0001"=>bcd_out<="0001";when "0010"=>bcd_out<="0010";when "0011"=>bcd_out<="0011";when "0100"=>bcd_out<="0100";when "0101"=>bcd_out<="0101";when "0110"=>bcd_out<="0110";when "0111"=>bcd_out<="0111";when "1000"=>bcd_out<="1000";when "1001"=>bcd_out<="1001";when others=>bcd_out<="XXXX";end case;end process;
process(bcd_in)begin case bcd_in is when "0000"=>binary_out<="0000";when "0001"=>binary_out<="0001";when "0010"=>binary_out<="0010";when "0011"=>binary_out<="0011";when "0100"=>binary_out<="0100";when "0101"=>binary_out<="0101";when "0110"=>binary_out<="0110";when "0111"=>binary_out<="0111";when "1000"=>binary_out<="1000";when "1001"=>binary_out<="1001";when others=>binary_out<="XXXX";end case;end process;
process(gate,d)begin if gate='1'then q<=d;end if;end process;
process(clk,rst)begin if rst='1'then q<='0';elsif rising_edge(clk)then if enable='1'then q<=d;end if;end if;end process;
process(clk,rst)begin if rst='1'then q<='0';elsif rising_edge(clk)then if t='1'then q<=not q;end if;end if;end process;
process(clk,rst)begin if rst='1'then q<='0';elsif rising_edge(clk)then if j='1'and k='0'then q<='1';elsif j='0'and k='1'then q<='0';elsif j='1'and k='1'then q<=not q;end if;end if;end process;
process(a,b,carry_in)begin result<=std_logic_vector(unsigned(a)+unsigned(b)+unsigned(carry_in));carry_out<='1'when unsigned(a)+unsigned(b)+unsigned(carry_in)>15 else'0';end process;
process(a,b,borrow_in)begin result<=std_logic_vector(unsigned(a)-unsigned(b)-unsigned(borrow_in));borrow_out<='1'when unsigned(a)<unsigned(b)+unsigned(borrow_in)else'0';end process;
process(a,b)begin result<=std_logic_vector(unsigned(a)*unsigned(b));end process;
process(a,b)begin if b/="0000"then quotient<=std_logic_vector(unsigned(a)/unsigned(b));remainder<=std_logic_vector(unsigned(a)mod unsigned(b));else quotient<=(others=>'X');remainder<=(others=>'X');end if;end process;
process(a,b)begin if a=b then equal<='1';less_than<='0';greater_than<='0';elsif a<b then equal<='0';less_than<='1';greater_than<='0';else equal<='0';less_than<='0';greater_than<='1';end if;end process;
process(a,b,op)begin case op is when"0000"=>result<=a+b;when"0001"=>result<=a-b;when"0010"=>result<=a and b;when"0011"=>result<=a or b;when"0100"=>result<=a xor b;when"0101"=>result<=not a;when others=>result<=(others=>'0');end case;end process;
process(data_in)begin parity_bit<=data_in(0)xor data_in(1)xor data_in(2)xor data_in(3);end process;
process(data_in,parity_bit)begin if(data_in(0)xor data_in(1)xor data_in(2)xor data_in(3))=parity_bit then parity_ok<='1';else parity_ok<='0';end if;end process;
process(binary_in)begin gray_out(3)<=binary_in(3);gray_out(2)<=binary_in(3)xor binary_in(2);gray_out(1)<=binary_in(2)xor binary_in(1);gray_out(0)<=binary_in(1)xor binary_in(0);end process;
process(gray_in)begin binary_out(3)<=gray_in(3);binary_out(2)<=gray_in(3)xor gray_in(2);binary_out(1)<=gray_in(3)xor gray_in(2)xor gray_in(1);binary_out(0)<=gray_in(3)xor gray_in(2)xor gray_in(1)xor gray_in(0);end process;
process(binary_in)begin case binary_in is when"0000"=>one_hot_out<="0001";when"0001"=>one_hot_out<="0010";when"0010"=>one_hot_out<="0100";when"0011"=>one_hot_out<="1000";when others=>one_hot_out<="0000";end case;end process;
process(one_hot_in)begin case one_hot_in is when"0001"=>binary_out<="0000";when"0010"=>binary_out<="0001";when"0100"=>binary_out<="0010";when"1000"=>binary_out<="0011";when others=>binary_out<="XXXX";end case;end process;
process(clk, rst) begin if rising_edge(clk) then if rst = '1' then count <= "0000"; else count <= count + 1; end if; end if; end process;
output <= input1 when sel = '0' else input2;
process(clk, rst) begin if rising_edge(clk) then if rst = '1' then counter <= 0; pulse <= '0'; elsif counter = 999 then counter <= 0; pulse <= '1'; else counter <= counter + 1; pulse <= '0'; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if (btn_in = '1' and last_state = "00") then debounced <= '1'; elsif (btn_in = '0' and last_state = "11") then debounced <= '0'; end if; last_state <= last_state(0) & btn_in; end if; end process;
process(clk) begin if rising_edge(clk) then shift_reg <= shift_reg(6 downto 0) & input; end if; end process;
process(clk) begin if rising_edge(clk) then if tx_start = '1' and tx_busy = '0' then tx_data_reg <= tx_data; bit_counter <= 0; tx_busy <= '1'; elsif tx_busy = '1' then if bit_counter = 10 then tx_busy <= '0'; else tx_out <= tx_data_reg(bit_counter); bit_counter <= bit_counter + 1; end if; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if counter = 24999999 then counter <= 0; clk_1hz <= not clk_1hz; else counter <= counter + 1; end if; end if; end process;
alu_out <= a + b when op = "00" else a - b when op = "01" else a and b when op = "10" else (others => '0');
process(clk) begin if rising_edge(clk) then if we = '1' then ram(to_integer(unsigned(write_addr))) <= data_in; end if; end if; end process; data_out <= ram(to_integer(unsigned(read_addr)));
process(clk) begin if rising_edge(clk) then if counter < duty_cycle then pwm_out <= '1'; else pwm_out <= '0'; end if; counter <= counter + 1; end if; end process;
process(clk, rst) begin if rst = '1' then rd_ptr <= (others => '0'); wr_ptr <= (others => '0'); empty <= '1'; full <= '0'; elsif rising_edge(clk) then if push = '1' and not full then wr_ptr <= wr_ptr + 1; empty <= '0'; elsif pop = '1' and not empty then rd_ptr <= rd_ptr + 1; full <= '0'; end if; if rd_ptr = wr_ptr then empty <= '1'; elsif rd_ptr = wr_ptr + 1 then full <= '1'; end if; end if; end process;
process(clk, rst) begin if rst = '1' then state <= IDLE; sclk <= '0'; mosi <= '0'; cs_n <= '1'; elsif rising_edge(clk) then case state is when IDLE => if start = '1' then state <= TRANSMIT; cs_n <= '0'; elsif TRANSMIT => sclk <= not sclk; if sclk = '0' then mosi <= tx_data(bit_count); else bit_count <= bit_count - 1; if bit_count = 0 then state <= DONE; end if; end if; when DONE => cs_n <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then input_d <= input; if EDGE_TYPE = "RISING" then edge_detected <= input and not input_d; else edge_detected <= not input and input_d; end if; end if; end process;
process(clk) begin if rising_edge(clk) then error <= setpoint - feedback; p_term <= Kp * error; i_term <= i_term + Ki * error; d_term <= Kd * (error - prev_error); output <= p_term + i_term + d_term; prev_error <= error; end if; end process;
process(clk) begin if rising_edge(clk) then if load = '1' then shift_reg <= (others => '0'); elsif shift_en = '1' then shift_reg <= shift_reg(6 downto 0) & serial_in; end if; end if; end process; parallel_out <= shift_reg;
process(clk, rst) begin if rst = '1' then state <= RED; counter <= 0; elsif rising_edge(clk) then case state is when RED => if counter = RED_TIME then state <= GREEN; counter <= 0; else counter <= counter + 1; end if; when GREEN => if counter = GREEN_TIME then state <= YELLOW; counter <= 0; else counter <= counter + 1; end if; when YELLOW => if counter = YELLOW_TIME then state <= RED; counter <= 0; else counter <= counter + 1; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then if counter = DIVISION_FACTOR - 1 then counter <= 0; clk_out <= not clk_out; else counter <= counter + 1; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if start = '1' then x <= 1.0; y <= 0.0; z <= angle; for i in 0 to 15 loop if z >= 0 then x_next <= x - y * 2**(-i); y_next <= y + x * 2**(-i); z_next <= z - arctan_table(i); else x_next <= x + y * 2**(-i); y_next <= y - x * 2**(-i); z_next <= z + arctan_table(i); end if; x <= x_next; y <= y_next; z <= z_next; end loop; sine <= y; cosine <= x; done <= '1'; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then lfsr <= seed; else lfsr <= lfsr(14 downto 0) & (lfsr(15) xor lfsr(14) xor lfsr(12) xor lfsr(3)); end if; end if; end process; random_num <= lfsr;
process(a, b) begin mantissa_sum <= ('0' & a(22 downto 0)) + ('0' & b(22 downto 0)); if mantissa_sum(23) = '1' then result_mantissa <= mantissa_sum(23 downto 1); result_exponent <= a(30 downto 23) + 1; else result_mantissa <= mantissa_sum(22 downto 0); result_exponent <= a(30 downto 23); end if; result <= a(31) & result_exponent & result_mantissa; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if rx = '0' then state <= START; counter <= 0; when START => if counter = HALF_BIT_PERIOD then state <= DATA; bit_count <= 0; counter <= 0; else counter <= counter + 1; end if; when DATA => if counter = BIT_PERIOD then rx_data(bit_count) <= rx; bit_count <= bit_count + 1; counter <= 0; if bit_count = 7 then state <= STOP; end if; else counter <= counter + 1; end if; when STOP => if counter = BIT_PERIOD then state <= IDLE; rx_done <= '1'; else counter <= counter + 1; end if; end case; end if; end process;
process(clk, rst) begin if rst = '1' then state <= IDLE; sda <= '1'; scl <= '1'; elsif rising_edge(clk) then case state is when IDLE => if start = '1' then state <= START; when START => sda <= '0'; state <= CLOCK_LOW; when CLOCK_LOW => scl <= '0'; if bit_count = 8 then state <= ACK; else state <= SHIFT_OUT; end if; when SHIFT_OUT => sda <= tx_data(7 - bit_count); state <= CLOCK_HIGH; when CLOCK_HIGH => scl <= '1'; state <= CLOCK_LOW; bit_count <= bit_count + 1; when ACK => state <= STOP; when STOP => sda <= '0'; scl <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then phase_acc <= phase_acc + phase_inc; sin_out <= sin_lut(to_integer(phase_acc(31 downto 24))); end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then crc <= (others => '1'); elsif calc = '1' then crc <= (crc(6 downto 0) & data_in) xor (POLY and (0 - crc(7))); end if; end if; end process;
process(clk) begin if rising_edge(clk) then if we = '1' then mem(to_integer(unsigned(addr))) <= data_in; data_out <= (others => 'Z'); elsif re = '1' then data_out <= mem(to_integer(unsigned(addr))); else data_out <= (others => 'Z'); end if; end if; end process;
process(clk) begin if rising_edge(clk) then sum <= sum - buffer(oldest) + input; buffer(oldest) <= input; oldest <= (oldest + 1) mod BUFFER_SIZE; output <= sum / BUFFER_SIZE; end if; end process;
process(clk) begin if rising_edge(clk) then if counter < duty_cycle then pwm_out <= '1'; else pwm_out <= '0'; end if; counter <= counter + 1; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then lfsr <= seed; else lfsr <= (lfsr(0) xor lfsr(2) xor lfsr(3) xor lfsr(5)) & lfsr(15 downto 1); end if; end if; end process; prbs_out <= lfsr(0);
process(clk) begin if rising_edge(clk) then case state is when S0 => out1 <= '1'; out2 <= '0'; out3 <= '0'; if counter = TIME1 then state <= S1; counter <= 0; else counter <= counter + 1; end if; when S1 => out1 <= '0'; out2 <= '1'; out3 <= '0'; if counter = TIME2 then state <= S2; counter <= 0; else counter <= counter + 1; end if; when S2 => out1 <= '0'; out2 <= '0'; out3 <= '1'; if counter = TIME3 then state <= S0; counter <= 0; else counter <= counter + 1; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then if wr_en = '1' and not full then memory(to_integer(wr_ptr)) <= data_in; wr_ptr <= wr_ptr + 1; elsif rd_en = '1' and not empty then data_out <= memory(to_integer(rd_ptr)); rd_ptr <= rd_ptr + 1; end if; empty <= wr_ptr = rd_ptr; full <= wr_ptr + 1 = rd_ptr; end if; end process;
process(clk) begin if rising_edge(clk) then a_prev <= a; b_prev <= b; if a /= a_prev then if b /= a then count <= count + 1; else count <= count - 1; end if; end if; end if; end process;
process(sclk, ss_n) begin if ss_n = '1' then bit_count <= 0; shift_reg <= (others => '0'); elsif rising_edge(sclk) then shift_reg <= shift_reg(6 downto 0) & mosi; bit_count <= bit_count + 1; if bit_count = 7 then data_received <= shift_reg; data_valid <= '1'; else data_valid <= '0'; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if measure = '1' then if input = '1' and input_prev = '0' then pulse_count <= pulse_count + 1; end if; input_prev <= input; if ref_count = REF_PERIOD - 1 then frequency <= pulse_count; pulse_count <= 0; ref_count <= 0; else ref_count <= ref_count + 1; end if; end if; end if; end process;
process(clk) begin if rising_edge(clk) then integrator <= integrator + analog_in - dac_out; if integrator >= 0 then comparator_out <= '1'; dac_out <= VRef; else comparator_out <= '0'; dac_out <= 0; end if; if decimation_count = DECIMATION_FACTOR - 1 then adc_out <= bit_sum; bit_sum <= 0; decimation_count <= 0; else bit_sum <= bit_sum + comparator_out; decimation_count <= decimation_count + 1; end if; end if; end process;
process(input) begin output <= "000"; if input(7) = '1' then output <= "111"; elsif input(6) = '1' then output <= "110"; elsif input(5) = '1' then output <= "101"; elsif input(4) = '1' then output <= "100"; elsif input(3) = '1' then output <= "011"; elsif input(2) = '1' then output <= "010"; elsif input(1) = '1' then output <= "001"; end if; end process;
process(clk) begin if rising_edge(clk) then if baud_counter = BAUD_LIMIT then baud_tick <= '1'; baud_counter <= 0; else baud_tick <= '0'; baud_counter <= baud_counter + 1; end if; end if; end process;
process(wr_clk) begin if rising_edge(wr_clk) then if wr_en = '1' and not full then memory(to_integer(wr_ptr)) <= data_in; wr_ptr <= wr_ptr + 1; end if; end if; end process; process(rd_clk) begin if rising_edge(rd_clk) then if rd_en = '1' and not empty then data_out <= memory(to_integer(rd_ptr)); rd_ptr <= rd_ptr + 1; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if counter < duty_cycle then pwm_out <= '1'; else pwm_out <= '0'; end if; if counter = period - 1 then counter <= 0; else counter <= counter + 1; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then crc <= (others => '0'); elsif calc = '1' then crc <= crc xor data_in; for i in 0 to 7 loop if crc(7) = '1' then crc <= (crc(6 downto 0) & '0') xor x"07"; else crc <= crc(6 downto 0) & '0'; end if; end loop; end if; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= SETUP; counter <= 0; when SETUP => cs_n <= '0'; state <= SHIFT; when SHIFT => if counter < 8 then sclk <= not sclk; if sclk = '0' then mosi <= tx_data(7 - counter); else counter <= counter + 1; end if; else state <= DONE; end if; when DONE => cs_n <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then if start = '1' then x <= x_in; y <= y_in; z <= angle; for i in 0 to 15 loop if z < 0 then x_next <= x + (y / 2**i); y_next <= y - (x / 2**i); z_next <= z + atan_table(i); else x_next <= x - (y / 2**i); y_next <= y + (x / 2**i); z_next <= z - atan_table(i); end if; x <= x_next; y <= y_next; z <= z_next; end loop; x_out <= x; y_out <= y; done <= '1'; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if counter = DEBOUNCE_TIME then stable_out <= btn_in; counter <= 0; elsif btn_in /= last_state then counter <= counter + 1; else counter <= 0; end if; last_state <= btn_in; end if; end process;
process(clk) begin if rising_edge(clk) then sum <= sum - buffer(oldest) + input; buffer(oldest) <= input; oldest <= (oldest + 1) mod BUFFER_SIZE; output <= sum / BUFFER_SIZE; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then lfsr <= seed; else lfsr <= (lfsr(15) xor lfsr(14) xor lfsr(12) xor lfsr(3)) & lfsr(15 downto 1); end if; end if; end process; prbs_out <= lfsr(0);
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= START; sda_out <= '0'; when START => scl_out <= '0'; state <= DATA; bit_count <= 7; when DATA => if bit_count >= 0 then sda_out <= tx_data(bit_count); bit_count <= bit_count - 1; state <= CLOCK_HIGH; else state <= ACK; end if; when CLOCK_HIGH => scl_out <= '1'; state <= CLOCK_LOW; when CLOCK_LOW => scl_out <= '0'; state <= DATA; when ACK => sda_out <= 'Z'; state <= STOP; when STOP => scl_out <= '1'; sda_out <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= CONVERT; counter <= 0; result <= (others => '0'); when CONVERT => if counter < ADC_BITS then comp_in <= result(ADC_BITS-1 downto 0) & '1'; if adc_out > comp_in then result(ADC_BITS-1-counter) <= '1'; else result(ADC_BITS-1-counter) <= '0'; end if; counter <= counter + 1; else state <= DONE; end if; when DONE => data_valid <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then data_p <= ddr_in; end if; end process; process(clk) begin if falling_edge(clk) then data_n <= ddr_in; end if; end process; process(clk) begin if rising_edge(clk) then parallel_out <= data_p & data_n; end if; end process;
process(clk) begin if rising_edge(clk) then phase_acc <= phase_acc + phase_inc; sine_out <= sine_lut(to_integer(phase_acc(31 downto 24))); cosine_out <= cosine_lut(to_integer(phase_acc(31 downto 24))); end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then lfsr <= seed; else feedback <= lfsr(15) xor lfsr(14) xor lfsr(12) xor lfsr(3); lfsr <= feedback & lfsr(15 downto 1); end if; end if; end process;
process(clk) begin if rising_edge(clk) then input_d <= input; rising_edge_detected <= input and not input_d; falling_edge_detected <= not input and input_d; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then binary_count <= (others => '0'); else binary_count <= binary_count + 1; end if; gray_count <= binary_count xor ('0' & binary_count(WIDTH-1 downto 1)); end if; end process;
process(clk) begin if rising_edge(clk) then if counter < duty_cycle then pwm_high <= '1'; pwm_low <= '0'; elsif counter < PERIOD - DEAD_TIME then pwm_high <= '0'; pwm_low <= '0'; else pwm_high <= '0'; pwm_low <= '1'; end if; counter <= counter + 1; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if tx_start = '1' then state <= START_BIT; bit_count <= 0; when START_BIT => tx <= '0'; if bit_timer = BIT_PERIOD - 1 then state <= DATA_BITS; bit_timer <= 0; else bit_timer <= bit_timer + 1; end if; when DATA_BITS => tx <= tx_data(bit_count); if bit_timer = BIT_PERIOD - 1 then if bit_count = 7 then state <= STOP_BIT; else bit_count <= bit_count + 1; end if; bit_timer <= 0; else bit_timer <= bit_timer + 1; end if; when STOP_BIT => tx <= '1'; if bit_timer = BIT_PERIOD - 1 then state <= IDLE; bit_timer <= 0; else bit_timer <= bit_timer + 1; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then if counter = DIVISION_FACTOR / 2 - 1 then counter <= 0; clk_out <= not clk_out; else counter <= counter + 1; end if; end if; end process;
process(sclk, cs_n) begin if cs_n = '1' then bit_count <= 0; shift_reg <= (others => '0'); elsif rising_edge(sclk) then shift_reg <= shift_reg(6 downto 0) & mosi; bit_count <= bit_count + 1; if bit_count = 7 then data_received <= shift_reg; data_valid <= '1'; else data_valid <= '0'; end if; end if; end process; miso <= shift_reg(7);
process(clk) begin if rising_edge(clk) then ddr_out <= data_p; end if; end process; process(clk) begin if falling_edge(clk) then ddr_out <= data_n; end if; end process;
process(clk) begin if rising_edge(clk) then if start = '1' then x <= 1.0; y <= 0.0; z <= angle; for i in 0 to 15 loop if z >= 0 then x_next <= x - y * 2**(-i); y_next <= y + x * 2**(-i); z_next <= z - atan_table(i); else x_next <= x + y * 2**(-i); y_next <= y - x * 2**(-i); z_next <= z + atan_table(i); end if; x <= x_next; y <= y_next; z <= z_next; end loop; sine <= y; cosine <= x; done <= '1'; end if; end if; end process;
process(clk) begin if rising_edge(clk) then a_prev <= a; b_prev <= b; if a = '1' and a_prev = '0' then if b = '1' then count <= count + 1; else count <= count - 1; end if; end if; end if; end process;
process(clk) begin if rising_edge(clk) then sum <= sum - buffer(oldest) + input; buffer(oldest) <= input; oldest <= (oldest + 1) mod WINDOW_SIZE; output <= sum / WINDOW_SIZE; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then lfsr <= seed; else feedback <= lfsr(15) xor lfsr(14) xor lfsr(12) xor lfsr(3); lfsr <= feedback & lfsr(15 downto 1); end if; end if; end process; prbs_out <= lfsr(0);
process(scl, rst_n) begin if rst_n = '0' then state <= IDLE; sda_out <= '1'; elsif rising_edge(scl) then case state is when IDLE => if sda_in = '0' then state <= ADDRESS; bit_count <= 7; end if; when ADDRESS => address(bit_count) <= sda_in; if bit_count = 0 then state <= RW_BIT; else bit_count <= bit_count - 1; end if; when RW_BIT => rw <= sda_in; state <= ACK; when ACK => sda_out <= '0'; if rw = '1' then state <= TRANSMIT; bit_count <= 7; else state <= RECEIVE; bit_count <= 7; end if; when RECEIVE => data_in(bit_count) <= sda_in; if bit_count = 0 then state <= ACK; else bit_count <= bit_count - 1; end if; when TRANSMIT => sda_out <= data_out(bit_count); if bit_count = 0 then state <= ACK_WAIT; else bit_count <= bit_count - 1; end if; when ACK_WAIT => if sda_in = '0' then state <= TRANSMIT; bit_count <= 7; else state <= IDLE; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then for i in 0 to ORDER-1 loop integrator(i) <= (others => '0'); comb(i) <= (others => '0'); end loop; else integrator(0) <= integrator(0) + input; for i in 1 to ORDER-1 loop integrator(i) <= integrator(i) + integrator(i-1); end loop; if decimation_counter = 0 then comb(0) <= integrator(ORDER-1); for i in 1 to ORDER-1 loop comb(i) <= comb(i-1) - comb_delay(i-1); comb_delay(i-1) <= comb(i-1); end loop; output <= comb(ORDER-1);
process(clk) begin if rising_edge(clk) then phase_acc <= phase_acc + phase_inc; cos_val <= cos_lut(to_integer(phase_acc(31 downto 24))); sin_val <= sin_lut(to_integer(phase_acc(31 downto 24))); i_mixed <= input_i * cos_val - input_q * sin_val; q_mixed <= input_i * sin_val + input_q * cos_val; i_filtered <= i_filtered + i_mixed - i_filtered(CIC_ORDER-1); q_filtered <= q_filtered + q_mixed - q_filtered(CIC_ORDER-1); if decim_counter = DECIM_RATE - 1 then i_out <= i_filtered(CIC_ORDER-1); q_out <= q_filtered(CIC_ORDER-1); decim_counter <= 0; else decim_counter <= decim_counter + 1; end if; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if coin_inserted = '1' then state <= COUNT_COINS; total <= 0; elsif return_button = '1' then state <= RETURN_COINS; end if; when COUNT_COINS => if coin_inserted = '1' then total <= total + coin_value; elsif total >= item_price then state <= DISPENSE; elsif return_button = '1' then state <= RETURN_COINS; end if; when DISPENSE => dispense_item <= '1'; change <= total - item_price; state <= RETURN_CHANGE; when RETURN_CHANGE => if change = 0 then state <= IDLE; else change <= change - coin_value; end if; when RETURN_COINS => if total = 0 then state <= IDLE; else total <= total - coin_value; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then error <= setpoint - feedback; p_term <= Kp * error; i_term <= i_term + Ki * error; if i_term > I_MAX then i_term <= I_MAX; elsif i_term < I_MIN then i_term <= I_MIN; end if; d_term <= Kd * (error - prev_error); output <= p_term + i_term + d_term; if output > OUT_MAX then output <= OUT_MAX; elsif output < OUT_MIN then output <= OUT_MIN; end if; prev_error <= error; end if; end process;
process(clk) begin if rising_edge(clk) then phase_acc <= phase_acc + phase_inc; case waveform_select is when "00" => output <= sine_lut(to_integer(phase_acc(31 downto 24))); when "01" => output <= std_logic_vector(phase_acc(31 downto 16)); when "10" => output <= (31 => phase_acc(31), others => '0'); when others => if phase_acc(31) = '1' then output <= (others => '1'); else output <= (others => '0'); end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then integrator <= integrator + (input - dac_out); if integrator >= 0 then comparator_out <= '1'; dac_out <= "11111111"; else comparator_out <= '0'; dac_out <= "00000000"; end if; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= SETUP; counter <= 0; ss_n <= (others => '1'); ss_n(to_integer(unsigned(slave_select))) <= '0'; when SETUP => state <= SHIFT; when SHIFT => if counter < 8 then sclk <= not sclk; if sclk = '0' then mosi <= tx_data(7 - counter); else counter <= counter + 1; miso_data(7 - counter) <= miso; end if; else state <= DONE; end if; when DONE => ss_n <= (others => '1'); rx_data <= miso_data; data_valid <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then for i in TAPS-1 downto 1 loop delay_line(i) <= delay_line(i-1); end loop; delay_line(0) <= input; acc <= (others => '0'); for i in 0 to TAPS-1 loop acc <= acc + delay_line(i) * coeffs(i); end loop; output <= acc(ACC_WIDTH-1 downto ACC_WIDTH-OUTPUT_WIDTH); end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if rx = '0' then state <= START_BIT; bit_timer <= 0; when START_BIT => if bit_timer = HALF_BIT_PERIOD then if rx = '0' then state <= DATA_BITS; bit_count <= 0; bit_timer <= 0; else state <= IDLE; end if; else bit_timer <= bit_timer + 1; end if; when DATA_BITS => if bit_timer = BIT_PERIOD then rx_data(bit_count) <= rx; bit_count <= bit_count + 1; bit_timer <= 0; if bit_count = 7 then state <= STOP_BIT; end if; else bit_timer <= bit_timer + 1; end if; when STOP_BIT => if bit_timer = BIT_PERIOD then if rx = '1' then data_valid <= '1'; end if; state <= IDLE; else bit_timer <= bit_timer + 1; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then a_prev <= a; b_prev <= b; if (a = '1' and a_prev = '0' and b = '1') or (a = '0' and a_prev = '1' and b = '0') then counter <= counter + 1; elsif (a = '1' and a_prev = '0' and b = '0') or (a = '0' and a_prev = '1' and b = '1') then counter <= counter - 1; end if; end if; end process;
process(clk) begin if rising_edge(clk) then counter <= counter + 1; for i in 0 to NUM_CHANNELS-1 loop if counter < duty_cycle(i) then pwm_out(i) <= '1'; else pwm_out(i) <= '0'; end if; end loop; end if; end process;
process(clk) begin if rising_edge(clk) then if start = '1' then x <= abs(x_in); y <= abs(y_in); z <= 0; for i in 0 to 15 loop if y >= 0 then x_next <= x + (y / 2**i); y_next <= y - (x / 2**i); z_next <= z + atan_table(i); else x_next <= x - (y / 2**i); y_next <= y + (x / 2**i); z_next <= z - atan_table(i); end if; x <= x_next; y <= y_next; z <= z_next; end loop; magnitude <= x; if x_in < 0 and y_in >= 0 then angle <= PI - z; elsif x_in < 0 and y_in < 0 then angle <= z - PI; elsif x_in >= 0 and y_in < 0 then angle <= -z; else angle <= z; end if; done <= '1'; end if; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if read_req = '1' then state <= READ_CMD; elsif write_req = '1' then state <= WRITE_CMD; end if; when READ_CMD => cmd <= READ; addr <= read_addr; state <= READ_WAIT; when READ_WAIT => if wait_counter = CAS_LATENCY then state <= READ_DATA; wait_counter <= 0; else wait_counter <= wait_counter + 1; end if; when READ_DATA => read_data <= sdram_data; read_valid <= '1'; state <= IDLE; when WRITE_CMD => cmd <= WRITE; addr <= write_addr; state <= WRITE_DATA; when WRITE_DATA => sdram_data <= write_data; write_done <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then dither <= (dither * 1103515245 + 12345) and x"7FFFFFFF"; phase_acc <= phase_acc + phase_inc + dither(30 downto 28); sine_out <= sine_lut(to_integer(phase_acc(31 downto 24))); cosine_out <= cosine_lut(to_integer(phase_acc(31 downto 24))); end if; end process;
process(clk) begin if rising_edge(clk) then dqs_out <= not dqs_out; data_out_p <= data_to_send(31 downto 16); end if; end process; process(clk) begin if falling_edge(clk) then data_out_n <= data_to_send(15 downto 0); end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then crc <= (others => '1'); elsif calc = '1' then for i in 0 to 7 loop feedback <= crc(15) xor data_in(i); crc(15 downto 1) <= crc(14 downto 0); crc(0) <= feedback; crc(5) <= crc(5) xor feedback; crc(12) <= crc(12) xor feedback; end loop; end if; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when RED => red <= '1'; yellow <= '0'; green <= '0'; if timer = RED_TIME then state <= RED_YELLOW; timer <= 0; else timer <= timer + 1; end if; when RED_YELLOW => red <= '1'; yellow <= '1'; green <= '0'; if timer = RED_YELLOW_TIME then state <= GREEN; timer <= 0; else timer <= timer + 1; end if; when GREEN => red <= '0'; yellow <= '0'; green <= '1'; if timer = GREEN_TIME then state <= YELLOW; timer <= 0; else timer <= timer + 1; end if; when YELLOW => red <= '0'; yellow <= '1'; green <= '0'; if timer = YELLOW_TIME then state <= RED; timer <= 0; else timer <= timer + 1; end if; end case; end if; end process;
process(clk) begin if rising_edge(clk) then x0 <= input; y0 <= ((a0 * x0) + (a1 * x1) + (a2 * x2) - (b1 * y1) - (b2 * y2)) / b0; x2 <= x1; x1 <= x0; y2 <= y1; y1 <= y0; output <= y0; end if; end process;
process(clk) begin if rising_edge(clk) then if counter < duty_cycle then pwm_high <= '1'; pwm_low <= '0'; elsif counter < PERIOD - dead_time then pwm_high <= '0'; pwm_low <= '0'; else pwm_high <= '0'; pwm_low <= '1'; end if; if counter = PERIOD - 1 then counter <= 0; else counter <= counter + 1; end if; end if; end process;
process(clk) begin if rising_edge(clk) then if rst = '1' then lfsr <= seed; else feedback <= '0'; for i in 0 to 15 loop if polynomial(i) = '1' then feedback <= feedback xor lfsr(i); end if; end loop; lfsr <= feedback & lfsr(15 downto 1); end if; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= CONVERT; counter <= 0; result <= (others => '0'); when CONVERT => if counter < ADC_BITS then dac_value <= result or ('1' & (ADC_BITS-2-counter downto 0 => '0')); if comp_out = '1' then result(ADC_BITS-1-counter) <= '1'; end if; counter <= counter + 1; else state <= DONE; end if; when DONE => data_valid <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then sum <= sum - buffer(head) + input; buffer(head) <= input; if head = BUFFER_SIZE - 1 then head <= 0; else head <= head + 1; end if; output <= sum / BUFFER_SIZE; end if; end process;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= REQUEST; addr <= start_addr; count <= transfer_count; when REQUEST => bus_req <= '1'; if bus_grant = '1' then state <= TRANSFER; end if; when TRANSFER => if rw = '0' then data_out <= mem_data; mem_addr <= addr; mem_we <= '1'; else data_in <= mem_data; end if; addr <= addr + 1; count <= count - 1; if count = 0 then state <= DONE; end if; when DONE => bus_req <= '0'; transfer_done <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then phase_error <= input_phase - nco_phase; filtered_error <= filtered_error + (phase_error - filtered_error) / FILTER_COEFF; nco_control <= nco_control + filtered_error * GAIN; nco_phase <= nco_phase + nco_control; output <= sine_lut(to_integer(nco_phase(31 downto 24))); end if; end process;
process(a, b) begin y <= a and b; end process;
process(clk) begin if rising_edge(clk) then q <= d; end if; end process;
process(sel, a, b) begin if sel = '0' then y <= a; else y <= b; end if; end process;
process(clk, rst) begin if rst = '1' then count <= "0000"; elsif rising_edge(clk) then count <= count + 1; end if; end process;
process(clk) begin if rising_edge(clk) then shift_reg <= shift_reg(6 downto 0) & input; end if; end process;
process(clk) begin if rising_edge(clk) then q <= not q; end if; end process;
process(input) begin case input is when "00" => output <= "0001"; when "01" => output <= "0010"; when "10" => output <= "0100"; when others => output <= "1000"; end case; end process;
process(s, r) begin if s = '1' then q <= '1'; elsif r = '1' then q <= '0'; end if; end process;
process(clk) begin if rising_edge(clk) then input_d <= input; rising_edge_detect <= input and not input_d; end if; end process;
process(clk) begin if rising_edge(clk) then clk_out <= not clk_out; end if; end process;
process(input) begin if input(3) = '1' then output <= "11"; elsif input(2) = '1' then output <= "10"; elsif input(1) = '1' then output <= "01"; elsif input(0) = '1' then output <= "00"; else output <= "00"; end if; end process;
process(input) begin case input is when "00" => output <= "0001"; when "01" => output <= "0010"; when "10" => output <= "0100"; when "11" => output <= "1000"; when others => output <= "0000"; end case; end process;
process(clk, rst) begin if rst = '1' then count <= "0000"; elsif rising_edge(clk) then count <= count(2 downto 0) & not count(3); end if; end process;
process(clk) begin if rising_edge(clk) then input_reg <= input_reg(1 downto 0) & input; if input_reg = "111" then debounced <= '1'; elsif input_reg = "000" then debounced <= '0'; end if; end if; end process;
process(input) begin parity <= input(0) xor input(1) xor input(2) xor input(3); end process;
process(enable) begin if enable = '1' then osc(0) <= not osc(2); osc(1) <= osc(0); osc(2) <= osc(1); end if; end process;
process(a, b, c) begin y <= (a and b) or (a and c) or (b and c); end process;
process(clk, rst) begin if rst = '1' then binary_count <= "0000"; elsif rising_edge(clk) then binary_count <= binary_count + 1; end if; gray_count <= binary_count xor ('0' & binary_count(3 downto 1)); end process;
process(clk, enable) begin gated_clk <= clk and enable; end process;
process(clk) begin if rising_edge(clk) then if count = PULSE_WIDTH - 1 then pulse <= '0'; count <= 0; else pulse <= '1'; count <= count + 1; end if; end if; end process;
process(clk, d) begin if clk = '1' then q <= d; end if; end process;
process(a, b) begin if a > b then greater <= '1'; equal <= '0'; less <= '0'; elsif a < b then greater <= '0'; equal <= '0'; less <= '1'; else greater <= '0'; equal <= '1'; less <= '0'; end if; end process;
process(a, b, cin) begin sum(0) <= a(0) xor b(0) xor cin; c(0) <= (a(0) and b(0)) or (a(0) and cin) or (b(0) and cin); for i in 1 to 3 loop sum(i) <= a(i) xor b(i) xor c(i-1); c(i) <= (a(i) and b(i)) or (a(i) and c(i-1)) or (b(i) and c(i-1)); end loop; cout <= c(3); end process;
process(input, shift) begin case shift is when "00" => output <= input; when "01" => output <= input(2 downto 0) & input(3); when "10" => output <= input(1 downto 0) & input(3 downto 2); when others => output <= input(0) & input(3 downto 1); end case; end process;
process(binary) begin case binary is when "0000" => bcd <= "0000"; when "0001" => bcd <= "0001"; when "0010" => bcd <= "0010"; when "0011" => bcd <= "0011"; when "0100" => bcd <= "0100"; when "0101" => bcd <= "0101"; when "0110" => bcd <= "0110"; when "0111" => bcd <= "0111"; when "1000" => bcd <= "1000"; when "1001" => bcd <= "1001"; when others => bcd <= "0000"; end case; end process;
process(a, b) begin if a > b then greater <= '1'; equal <= '0'; less <= '0'; elsif a < b then greater <= '0'; equal <= '0'; less <= '1'; else greater <= '0'; equal <= '1'; less <= '0'; end if; end process;
process(input) begin if input(3) = '1' then output <= "11"; elsif input(2) = '1' then output <= "10"; elsif input(1) = '1' then output <= "01"; elsif input(0) = '1' then output <= "00"; else output <= "00"; end if; end process;
process(binary) begin gray(3) <= binary(3); gray(2) <= binary(3) xor binary(2); gray(1) <= binary(2) xor binary(1); gray(0) <= binary(1) xor binary(0); end process;
process(a, b, cin) begin p <= a or b; g <= a and b; c(0) <= cin; for i in 1 to 3 loop c(i) <= g(i-1) or (p(i-1) and c(i-1)); end loop; cout <= c(3); end process;
process(input) begin parity <= input(0) xor input(1) xor input(2) xor input(3); end process;
process(sel,a,b)begin if sel='0'then y<=a;else y<=b;end if;end process;
process(sel,a,b,c,d)begin case sel is when"00"=>y<=a;when"01"=>y<=b;when"10"=>y<=c;when"11"=>y<=d;when others=>y<=(others=>'0');end case;end process;
process(sel,a,b,c,d,e,f,g,h)begin case sel is when"000"=>y<=a;when"001"=>y<=b;when"010"=>y<=c;when"011"=>y<=d;when"100"=>y<=e;when"101"=>y<=f;when"110"=>y<=g;when"111"=>y<=h;when others=>y<=(others=>'0');end case;end process;
process(a)begin case a is when"00"=>y<="0001";when"01"=>y<="0010";when"10"=>y<="0100";when"11"=>y<="1000";when others=>y<="0000";end case;end process;
process(a)begin case a is when"000"=>y<="00000001";when"001"=>y<="00000010";when"010"=>y<="00000100";when"011"=>y<="00001000";when"100"=>y<="00010000";when"101"=>y<="00100000";when"110"=>y<="01000000";when"111"=>y<="10000000";when others=>y<="00000000";end case;end process;
process(a)begin if a(3)='1'then y<="11";elsif a(2)='1'then y<="10";elsif a(1)='1'then y<="01";elsif a(0)='1'then y<="00";else y<="XX";end if;end process;
process(bcd)begin if bcd="1001"then bcd_out<="0000";else bcd_out<=std_logic_vector(unsigned(bcd)+1);end if;end process;
process(bcd)begin if bcd="0000"then bcd_out<="1001";else bcd_out<=std_logic_vector(unsigned(bcd)-1);end if;end process;
process(a,b)begin sum<=a xor b;carry<=a and b;end process;
process(a,b,cin)begin sum<=a xor b xor cin;carry<=a and b or b and cin or a and cin;end process;
process(a,b,cin)begin sum<=std_logic_vector(unsigned(a)+unsigned(b)+unsigned(cin));carry_out<=carry_out;end process;
process(a,b,borrow_in)begin result<=std_logic_vector(unsigned(a)-unsigned(b)-unsigned(borrow_in));borrow_out<=borrow_out;end process;
process(a,b)begin if a=b then equal<='1';else equal<='0';end if;if a>b then greater<='1';else greater<='0';end if;if a<b then less<='1';else less<='0';end if;end process;
process(clk,rst)begin if rst='1'then count<="00";elsif rising_edge(clk)then count<=count+1;end if;end process;
process(clk,rst)begin if rst='1'then count<="000";elsif rising_edge(clk)then count<=count+1;end if;end process;
process(clk,rst)begin if rst='1'then count<="0000";elsif rising_edge(clk)then count<=count+1;end if;end process;
signal prev_signal:std_logic:='0';process(clk)begin if rising_edge(clk)then rising_edge_detected<=signal and not prev_signal;prev_signal<=signal;end if;end process;
signal prev_signal:std_logic:='0';process(clk)begin if rising_edge(clk)then falling_edge_detected<=not signal and prev_signal;prev_signal<=signal;end if;end process;
process(clk,rst)begin if rst='1'then pulse<='0';elsif rising_edge(clk)then pulse<='1';elsif falling_edge(clk)then pulse<='0';end if;end process;
process(clk,rst)begin if rst='1'then clk_out<='0';elsif rising_edge(clk)then clk_out<=not clk_out;end if;end process;
signal ring:std_logic_vector(2 downto 0);process(clk,rst)begin if rst='1'then ring<="001";elsif rising_edge(clk)then ring(0)<=ring(2);ring(1)<=ring(0);ring(2)<=ring(1);end if;end process;
process(s,r)begin if s='1'and r='0'then q<='1';elsif s='0'and r='1'then q<='0';end if;end process;
process(gate,s,r)begin if gate='1'then if s='1'and r='0'then q<='1';elsif s='0'and r='1'then q<='0';end if;end if;end process;
process(j,k)begin if j='1'and k='0'then q<='1';elsif j='0'and k='1'then q<='0';elsif j='1'and k='1'then q<=not q;end if;end process;
process(gate,j,k)begin if gate='1'then if j='1'and k='0'then q<='1';elsif j='0'and k='1'then q<='0';elsif j='1'and k='1'then q<=not q;end if;end if;end process;
process(clk,rst)begin if rst='1'then reg<=0;elsif rising_edge(clk)then if enable='1'then reg<=data_in;end if;end if;end process;
process(clk,rst)begin if rst='1'then shift_reg<=(others=>'0');elsif rising_edge(clk)then shift_reg<=shift_reg(6 downto 0)&serial_in;end if;end process;
process(clk,rst,shift_right)begin if rst='1'then shift_reg<=(others=>'0');elsif rising_edge(clk)then if shift_right='1'then shift_reg<=shift_reg(6 downto 0)&serial_in;else shift_reg<=serial_in&shift_reg(7 downto 1);end if;end if;end process;
process(clk,rst)begin if rst='1'then serial_out<='0';shift_reg<=(others=>'0');elsif rising_edge(clk)then serial_out<=shift_reg(7);shift_reg<=shift_reg(6 downto 0)&'0';end if;end process;
process(clk,rst)begin if rst='1'then parallel_out<=(others=>'0');shift_reg<=(others=>'0');elsif rising_edge(clk)then shift_reg<=serial_in&shift_reg(7 downto 1);if bit_count=7 then parallel_out<=shift_reg;end if;end if;end process;
signal sync_reg:std_logic_vector(1 downto 0);process(dest_clk)begin if rising_edge(dest_clk)then sync_reg<=sync_reg(0)&async_data;sync_data<=sync_reg(1);end if;end process;
process(clk)begin if rising_edge(clk)then if we1='1'then mem(to_integer(unsigned(addr1)))<=data_in1;end if;if we2='1'then mem(to_integer(unsigned(addr2)))<=data_in2;end if;data_out1<=mem(to_integer(unsigned(addr1)));data_out2<=mem(to_integer(unsigned(addr2)));end if;end process;
type rom_type is array(0 to 15) of std_logic_vector(7 downto 0);constant rom:rom_type:=(x"00",x"01",x"02",x"03",x"04",x"05",x"06",x"07",x"08",x"09",x"0A",x"0B",x"0C",x"0D",x"0E",x"0F");process(addr)begin data_out<=rom(to_integer(unsigned(addr)));end process;
process(clk,rst)begin if rst='1'then rd_ptr<=0;wr_ptr<=0;empty<='1';full<='0';elsif rising_edge(clk)then if write_en='1'and not full then fifo(wr_ptr)<=data_in;wr_ptr<=wr_ptr+1;if wr_ptr=rd_ptr then full<='1';end if;empty<='0';end if;if read_en='1'and not empty then data_out<=fifo(rd_ptr);rd_ptr<=rd_ptr+1;if rd_ptr=wr_ptr then empty<='1';end if;full<='0';end if;end if;end process;
process(clk,rst)begin if rst='1'then tx<='1';tx_shift_reg<=(others=>'1');tx_busy<='0';elsif rising_edge(clk)then if start='1'and not tx_busy then tx_shift_reg<=start_bit&data_in&stop_bit;tx_busy<='1';end if;if tx_busy='1'then tx<=tx_shift_reg(0);tx_shift_reg<=tx_shift_reg(7 downto 1)&'1';if tx_shift_reg="11111111"then tx_busy<='0';end if;end if;end if;end process;
process(clk,rst)begin if rst='1'then rx_shift_reg<=(others=>'1');rx_data<=(others=>'0');rx_ready<='0';elsif rising_edge(clk)then if start_bit_detected then rx_shift_reg<=serial_in&rx_shift_reg(7 downto 1);if bit_count=8 then rx_data<=rx_shift_reg(6 downto 1);rx_ready<='1';end if;end if;end if;end process;
process(clk,rst)begin if rst='1'then sclk<='0';mosi<='0';cs<='1';shift_reg<=(others=>'0');elsif rising_edge(clk)then cs<='0';sclk<=not sclk;if sclk='0'then shift_reg<=shift_reg(6 downto 0)&miso;mosi<=shift_reg(7);if bit_count=7 then cs<='1';end if;end if;end if;end process;
process(sclk,rst)begin if rst='1'then miso<='0';shift_reg<=(others=>'0');elsif rising_edge(sclk)then shift_reg<=shift_reg(6 downto 0)&mosi;miso<=shift_reg(7);end if;end process;
process(clk,rst)begin if rst='1'then scl<='1';sda<='1';shift_reg<=(others=>'0');bit_count<=0;elsif rising_edge(clk)then if start='1'then sda<='0';elsif stop='1'then sda<='1';elsif scl='1'then shift_reg<=shift_reg(6 downto 0)&sda_out;sda<=shift_reg(7);bit_count<=bit_count+1;end if;end if;end process;
process(scl,rst)begin if rst='1'then sda_in<='1';shift_reg<=(others=>'0');bit_count<=0;elsif rising_edge(scl)then shift_reg<=shift_reg(6 downto 0)&sda_in;if bit_count=7 then data_out<=shift_reg;end if;bit_count<=bit_count+1;end if;end process;
process(clk,rst)begin if rst='1'then timer<=0;elsif rising_edge(clk)then if start='1'then timer<=timer+1;end if;if stop='1'then timer<=0;end if;end if;end process;
process(clk,rst)begin if rst='1'then pwm_out<='0';counter<=0;elsif rising_edge(clk)then if counter<duty_cycle then pwm_out<='1';else pwm_out<='0';end if;counter<=counter+1;end if;end process;
process(clk,rst)begin if rst='1'then debounced_signal<='0';counter<=0;elsif rising_edge(clk)then if noisy_signal=debounced_signal then counter<=0;else counter<=counter+1;if counter=debounce_threshold then debounced_signal<=noisy_signal;counter<=0;end if;end if;end if;end process;
process(clk,rst)begin if rst='1'then count<=0;freq<=0;elsif rising_edge(clk)then if gate='1'then count<=count+1;else freq<=count;count<=0;end if;end if;end process;
process(clk,rst)begin if rst='1'then clk_out<='0';counter<=0;elsif rising_edge(clk)then counter<=counter+1;if counter=3 then clk_out<=not clk_out;counter<=0;end if;end if;end process;
process(clk,rst)begin if rst='1'then tx<='1';rx_data<=(others=>'0');elsif rising_edge(clk)then if tx_start='1'then tx<=tx_data;end if;if rx='1'then rx_data<=rx_data(6 downto 0)&rx;end if;end if;end process;
process(clk,rst)begin if rst='1'then clk_enable<='0';counter<=0;elsif rising_edge(clk)then if counter=desired_count then clk_enable<='1';counter<=0;else clk_enable<='0';counter<=counter+1;end if;end if;end process;
process(clk,rst)begin if rst='1'then manchester_out<='0';elsif rising_edge(clk)then manchester_out<=data_in xor not clk;end if;end process;
process(clk,rst)begin if rst='1'then data_out<='0';elsif rising_edge(clk)then if manchester_in=clk then data_out<='1';else data_out<='0';end if;end if;end process;
process(data_in)begin parity<=data_in(0)xor data_in(1)xor data_in(2)xor data_in(3)xor data_in(4)xor data_in(5)xor data_in(6)xor data_in(7);end process;
signal data_stream : std_logic_vector(255 downto 0); signal chunk : std_logic_vector(31 downto 0); chunk <= data_stream(127 downto 96);
type memory_array is array (0 to 31) of std_logic_vector(63 downto 0); signal big_mem : memory_array; signal read_data : std_logic_vector(63 downto 0); read_data <= big_mem(14);
signal wide_addr : std_logic_vector(47 downto 0); signal segment : std_logic_vector(5 downto 0); segment <= wide_addr(47 downto 42);
type int_array is array (0 to 63) of integer range 0 to 1023; signal large_buffer : int_array; signal write_val : integer; large_buffer(49) <= 1023;
signal extended_word : std_logic_vector(79 downto 0); signal mid_section : std_logic_vector(15 downto 0); mid_section <= extended_word(47 downto 32);
type memory_array is array (0 to 15) of std_logic_vector(15 downto 0); signal square_mem : memory_array; signal diagonal_data : std_logic_vector(15 downto 0); diagonal_data <= square_mem(7);
signal data_packet : std_logic_vector(35 downto 0); signal nibble : std_logic_vector(3 downto 0); nibble <= data_packet(19 downto 16);
type int_array is array (0 to 127) of integer range 0 to 4095; signal massive_buffer : int_array; signal read_val : integer; read_val <= massive_buffer(99);
signal long_data : std_logic_vector(95 downto 0); signal quarter : std_logic_vector(23 downto 0); quarter <= long_data(71 downto 48);
type memory_array is array (0 to 63) of std_logic_vector(7 downto 0); signal byte_mem : memory_array; signal byte_out : std_logic_vector(7 downto 0); byte_out <= byte_mem(32);
signal extended_bus : std_logic_vector(71 downto 0); signal byte_plus : std_logic_vector(8 downto 0); byte_plus <= extended_bus(44 downto 36);
type int_array is array (0 to 255) of integer range 0 to 8191; signal huge_buffer : int_array; signal write_data : integer; huge_buffer(199) <= 8191;
signal quad_word : std_logic_vector(127 downto 0); signal word_slice : std_logic_vector(31 downto 0); word_slice <= quad_word(95 downto 64);
type memory_array is array (0 to 31) of std_logic_vector(31 downto 0); signal matrix_mem : memory_array; signal row_data : std_logic_vector(31 downto 0); row_data <= matrix_mem(24);
signal data_stream : std_logic_vector(59 downto 0); signal fifth : std_logic_vector(11 downto 0); fifth <= data_stream(47 downto 36);
type int_array is array (0 to 511) of integer range 0 to 16383; signal mega_buffer : int_array; signal read_data : integer; read_data <= mega_buffer(299);
signal super_word : std_logic_vector(143 downto 0); signal eighth : std_logic_vector(17 downto 0); eighth <= super_word(35 downto 18);
type memory_array is array (0 to 127) of std_logic_vector(15 downto 0); signal wide_mem : memory_array; signal column_data : std_logic_vector(15 downto 0); column_data <= wide_mem(74);
signal long_packet : std_logic_vector(91 downto 0); signal quarter : std_logic_vector(22 downto 0); quarter <= long_packet(68 downto 46);
type int_array is array (0 to 1023) of integer range 0 to 32767; signal giga_buffer : int_array; signal write_val : integer; giga_buffer(499) <= 32767;
signal mega_word : std_logic_vector(159 downto 0); signal quarter : std_logic_vector(39 downto 0); quarter <= mega_word(119 downto 80);
type memory_array is array (0 to 63) of std_logic_vector(63 downto 0); signal square_big_mem : memory_array; signal diagonal : std_logic_vector(63 downto 0); diagonal <= square_big_mem(39);
signal data_block : std_logic_vector(107 downto 0); signal quarter : std_logic_vector(26 downto 0); quarter <= data_block(80 downto 54);
type int_array is array (0 to 2047) of integer range 0 to 65535; signal tera_buffer : int_array; signal read_val : integer; read_val <= tera_buffer(1499);
signal huge_word : std_logic_vector(191 downto 0); signal byte_trio : std_logic_vector(23 downto 0); byte_trio <= huge_word(167 downto 144);
type memory_array is array (0 to 255) of std_logic_vector(31 downto 0); signal tall_mem : memory_array; signal row_data : std_logic_vector(31 downto 0); row_data <= tall_mem(149);
signal data_chunk : std_logic_vector(119 downto 0); signal slice : std_logic_vector(14 downto 0); slice <= data_chunk(89 downto 75);
type int_array is array (0 to 4095) of integer range 0 to 131071; signal peta_buffer : int_array; signal write_data : integer; peta_buffer(2999) <= 131071;
signal ultra_word : std_logic_vector(223 downto 0); signal quarter : std_logic_vector(55 downto 0); quarter <= ultra_word(167 downto 112);
type memory_array is array (0 to 127) of std_logic_vector(127 downto 0); signal giant_mem : memory_array; signal full_row : std_logic_vector(127 downto 0); full_row <= giant_mem(99);
signal data_stream : std_logic_vector(131 downto 0); signal segment : std_logic_vector(10 downto 0); segment <= data_stream(98 downto 88);
type int_array is array (0 to 8191) of integer range 0 to 262143; signal exa_buffer : int_array; signal read_data : integer; read_data <= exa_buffer(4999);
signal mega_packet : std_logic_vector(255 downto 0); signal quarter : std_logic_vector(63 downto 0); quarter <= mega_packet(191 downto 128);
type memory_array is array (0 to 511) of std_logic_vector(15 downto 0); signal deep_mem : memory_array; signal column_slice : std_logic_vector(15 downto 0); column_slice <= deep_mem(299);
signal data_block : std_logic_vector(167 downto 0); signal eighth : std_logic_vector(20 downto 0); eighth <= data_block(125 downto 105);
type int_array is array (0 to 16383) of integer range 0 to 524287; signal yotta_buffer : int_array; signal write_val : integer; yotta_buffer(9999) <= 524287;
signal ultra_packet : std_logic_vector(287 downto 0); signal byte_quad : std_logic_vector(35 downto 0); byte_quad <= ultra_packet(215 downto 180);
type memory_array is array (0 to 255) of std_logic_vector(255 downto 0); signal huge_matrix : memory_array; signal diagonal : std_logic_vector(255 downto 0); diagonal <= huge_matrix(199);
signal data_stream : std_logic_vector(179 downto 0); signal quarter : std_logic_vector(44 downto 0); quarter <= data_stream(134 downto 90);
type int_array is array (0 to 32767) of integer range 0 to 1048575; signal zetta_buffer : int_array; signal read_val : integer; read_val <= zetta_buffer(19999);
assert data = 42 report "Data is not 42 after 10 ns" severity error;
assert counter < 100 report "Counter exceeded 99" severity warning;
assert ready = '1' report "Ready signal not high" severity failure;
assert (result >= 0 and result <= 255) report "Result out of range" severity error;
assert state = IDLE or state = BUSY or state = DONE report "Invalid state" severity error;
assert done = '1' report "Operation not completed within 5 cycles" severity error when rising_edge(clk) and start = '1' and now >= start_time + 5 * clock_period;
assert data_out = "10101010" report "Unexpected data pattern" severity warning;
assert not (fifo_empty = '1' and fifo_full = '1') report "FIFO empty and full at the same time" severity failure;
assert address mod 4 = 0 report "Address is not word-aligned" severity error;
assert error_count = 0 report "Test failed with " & integer'image(error_count) & " errors" severity error;
assert input_valid'stable(clock_period) report "Input valid signal unstable" severity error;
assert output'delayed(3 ns) /= output report "Output did not change within 3 ns" severity error when input'event;
assert data_array(i) <= data_array(i+1) report "Array not sorted at index " & integer'image(i) severity error;
assert not (interrupt = '1' and reset = '1') report "Interrupt asserted during reset" severity warning;
assert counter = prev_counter + 1 report "Counter did not increment correctly" severity error when rising_edge(clk);
assert crc = expected_crc report "CRC mismatch after transmission" severity error;
assert not (data_valid = '1' and (data < 0 or data > 1023)) report "Invalid data marked as valid" severity error;
assert ack = '1' report "No acknowledgment received within timeout" severity error when rising_edge(clk) and req = '1' and now >= req_time + 10 * clock_period;
assert (state_vector = "0001" or state_vector = "0010" or state_vector = "0100" or state_vector = "1000") report "Invalid state vector" severity error;
assert data_out'stable(busy'length) report "Data changed while busy" severity error when falling_edge(busy);
assert fifo_count <= FIFO_MAX_COUNT report "FIFO overflow detected" severity failure;
assert parity = xor data_word report "Parity bit incorrect" severity error;
assert ready = '1' report "Device not ready within 100 ns" severity error when now >= start_time + 100 ns;
assert output'event report "Output not updated on falling clock edge" severity error when falling_edge(clk) and enable = '1';
assert data_out = expected_sequence(index) report "Data mismatch at index " & integer'image(index) severity error;
assert error_flag_duration <= 3 report "Error flag high for too long" severity warning when rising_edge(clk) and error_flag = '1';
assert (address >= MEM_BASE and address <= MEM_BASE + MEM_SIZE - 1) report "Address out of valid memory range" severity error;
assert not (data_valid = '1' and (parity_ok = '0' or crc_ok = '0')) report "Data marked valid with parity or CRC error" severity error;
assert count_ones(interrupt_vector) <= 1 report "Multiple interrupts active simultaneously" severity warning;
assert (prev_state = IDLE and state = ACTIVE) or (prev_state = ACTIVE and state = DONE) or (prev_state = DONE and state = IDLE) report "Invalid state transition" severity error when state'event;
assert data_out'stable(5 ns) report "Data not stable after strobe" severity error when strobe'event and strobe = '1';
assert reset'delayed(10 ns) = '0' report "Reset pulse width too short" severity error when falling_edge(reset);
assert fifo_almost_full = '1' report "FIFO almost full flag not set" severity warning when fifo_count >= FIFO_ALMOST_FULL_THRESHOLD;
assert output /= prev_output report "Output not toggling in toggle mode" severity error when rising_edge(clk) and toggle_mode = '1';
assert data_out = 0 report "Data not zero during reset" severity error when reset = '1';
assert acknowledge = '1' report "Acknowledge not received within timeout" severity error when now >= request_time + TIMEOUT;
assert is_valid_error_code(error_code) report "Invalid error code: " & integer'image(error_code) severity error;
assert not (data_valid = '1' and clock_enable = '0') report "Data marked valid when clock is disabled" severity error;
assert output'event report "Output changed at unexpected time" severity error when rising_edge(clk) and (now / clock_period) mod 8 /= 0;
assert signature = EXPECTED_SIGNATURE report "Signature mismatch after processing" severity failure;
with sel select output <= "00" when "00", "01" when "01", "10" when "10", "11" when others;
with state select next_state <= IDLE when RESET, ACTIVE when IDLE, DONE when ACTIVE, IDLE when others;
with bcd_in select seg_out <= "1111110" when "0000", "0110000" when "0001", "1101101" when "0010", "1111001" when others;
with addr select data_out <= data_0 when "00", data_1 when "01", data_2 when "10", data_3 when others;
with operation select result <= a + b when "00", a - b when "01", a * b when "10", (others => '0') when others;
with control(1 downto 0) select output <= "01XX" when "00", "10XX" when "01", "11XX" when "10", "00XX" when others;
with input select encoded <= "000" when "00000001", "001" when "0000001X", "010" when "000001XX", "011" when others;
with mode select data_out <= data_in(7 downto 0) when "00", data_in(15 downto 0) when "01", data_in when others;
with status select error_code <= x"00" when NO_ERROR, x"01" when TIMEOUT_ERROR, x"02" when PARITY_ERROR, x"FF" when others;
with alu_op select alu_out <= a + b when "00", a - b when "01", a and b when "10", a or b when others;
with selector select constant_out <= 42 when "000", 101 when "001", 255 when "010", 0 when others;
with current_state select output <= IDLE_OUTPUT when IDLE, ACTIVE_OUTPUT when ACTIVE, DONE_OUTPUT when DONE, ERROR_OUTPUT when others;
with shift_amount select shifted_data <= data_in when "000", data_in(6 downto 0) & '0' when "001", data_in(5 downto 0) & "00" when "010", (others => '0') when others;
with mode select output <= input_a when NORMAL, input_b when ALTERNATE, input_c when SPECIAL, (others => '0') when others;
with opcode select instruction_type <= ALU_OP when "000", LOAD_OP when "001", STORE_OP when "010", BRANCH_OP when others;
with clk_div_sel select clk_out <= clk_in when "00", clk_div2 when "01", clk_div4 when "10", clk_div8 when others;
with nibble select pattern <= "1010" & nibble when x"0", "0101" & nibble when x"1", nibble & "1010" when x"2", nibble & "0101" when others;
with bank_select select mem_output <= bank0_data when "00", bank1_data when "01", bank2_data when "10", bank3_data when others;
with interrupt_status select interrupt_vector <= x"01" when "0000000X", x"02" when "000000X0", x"04" when "00000X00", x"08" when others;
with speed_mode select delayed_signal <= signal_in after 10 ns when SLOW, signal_in after 5 ns when MEDIUM, signal_in after 2 ns when FAST, signal_in when others;
with color_code select rgb_out <= "11100000" when RED, "00011100" when GREEN, "00000011" when BLUE, "00000000" when others;
with data_width select valid_data <= data_in(7 downto 0) when BYTE, data_in(15 downto 0) when WORD, data_in when DWORD, (others => '0') when others;
with freq_mode select clk_div <= divide_by_2 when "00", divide_by_4 when "01", divide_by_8 when "10", divide_by_16 when others;
with protocol_select select converted_data <= uart_to_spi(data_in) when UART_TO_SPI, spi_to_i2c(data_in) when SPI_TO_I2C, i2c_to_uart(data_in) when I2C_TO_UART, data_in when others;
with function_select select result <= square(input) when "00", cube(input) when "01", double(input) when "10", halve(input) when others;
with bus_config select data_bus <= data_in(7 downto 0) when NARROW, data_in(15 downto 0) when MEDIUM, data_in(31 downto 0) when WIDE, data_in when others;
with encrypt_mode select encrypted_data <= aes_encrypt(data_in) when AES, des_encrypt(data_in) when DES, xor_encrypt(data_in) when XOR, data_in when others;
with invert_select select inverted_signal <= not signal_in when '1', signal_in when others;
with error_condition select error_code <= x"01" when TIMEOUT, x"02" when PARITY_ERROR, x"04" when OVERFLOW, x"08" when UNDERFLOW, x"00" when others;
with address(15 downto 14) select chip_select <= "0001" when "00", "0010" when "01", "0100" when "10", "1000" when others;
with pack_mode select packed_data <= data_in & x"00" when ZERO_PAD, x"FF" & data_in when FF_PAD, data_in & data_in when DUPLICATE, data_in when others;
with test_mode select test_output <= normal_output when NORMAL, test_pattern when TEST, all_zeros when RESET, all_ones when others;
y( 10 ); c0: if (PCISYSCLK = 0) or (PCIEN = 0) generate clkint <= clkin; end generate c0;; wait for clk_period / 2;
i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0'; constant THRESHOLD : integer := 50;; enc: Encoder port map(X => switch, Y => ytemp);
case mode is when AUTO => ; when MANUAL => ; when SEMI_AUTO => ; when OFF => ; when others => ; end case; with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others;
reg_count_nxt <= 0; initaddr := std_logic_vector((unsigned(initaddr) + 1));
entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register; with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;
stringa3 <= ( others => '0' ); signal i_start_counter : integer range 0 to 400;
sbox_inst : sbox port map (); signal i_dly_counter : integer range 0 to 400;; if (rising_edge(CLK)) then tmp(0) <= '0'; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if;
data_out <= rom(to_integer(unsigned(addr))); sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
UC: unita_controllo port map (tempq0, clock, reset, start, temp_count, temp_loadM, temp_count_in, temp_loadAQ, temp_shift, temp_selM, temp_selAQ, temp_selF, temp_sub, temp_stop_cu); signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');
sda_o => t_sda; d : in std_logic;; signal temp_count_in, t_load_add: std_logic;
wait until s0_arready = '1'; pdl_empty <= unsigned(pdl_addr_reg) = 0;; signal t_tick_o : std_logic;
component counter_mod8 port (clock : in STD_LOGIC; reset : in STD_LOGIC; enable : in STD_LOGIC; counter : out STD_LOGIC_VECTOR(2 downto 0)); end component; signal tmp: std_logic_vector(3 downto 0);; wait for 10 ns;
rst_n : in std_logic; signal clkA     : std_logic;
component display_seven_segments generic (CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500) port (CLK : IN std_logic; RST : IN std_logic; VALUE : IN std_logic_vector(31 downto 0); ENABLE : IN std_logic_vector(7 downto 0); DOTS : IN std_logic_vector(7 downto 0); ANODES : OUT std_logic_vector(7 downto 0); CATHODES : OUT std_logic_vector(7 downto 0)); end component; noise(15) <= raw_lfsr(1);; c0: if (PCISYSCLK = 0) or (PCIEN = 0) generate clkint <= clkin; end generate c0;
stato_mem: process(clkA) begin if rising_edge(clkA) then if( RST = '1') then stato_corrente <= IDLE; else stato_corrente <= stato_prossimo; end if; end if; end process; signal i_cmd_state : cmd_state;
signal t_clk : std_logic; signal reg_count_reg : integer range 0 to clock_multiplier - 1;; signal i_sck_cpy : std_logic;
data_0_o <= i_data_0_out when rst_n_i = '1' else (others => '0'); type data_t is array(0 to C_NUM_SENSORS - 1) of std_logic_vector (C_COUNTER_WIDTH - 1 downto 0);
entity shift_reg is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register; if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
signal t_dac_val_0 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0); i_cs <= sign_data(i_counter_3);
if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if; signal i_ldac_cpy : std_logic;; if bar(21 downto 14) = x"2B" then ; end if;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0); i_cs_cpy <= i_cs;
if( rising_edge( CLK ) ) then end if; variable temp : unsigned(7 downto 0);; i_data_5_out <= i_data_5_out(i_data_5_out'length - 2 downto 0) & i_data_0;
sda_o <= i_sda when rst_n_i = '1' else '0'; signal_8 <= signal_7(0);; component counter is generic (constant cnt_max : integer := 50000000); port ( iClk: in std_logic; iReset: in std_logic; is_forward: in std_logic; is_enabled: in std_logic; output_data: out std_logic_vector(7 downto 0)); end component;
component counter is generic (constant cnt_max : integer := 50000000); port ( iClk: in std_logic; iReset: in std_logic; is_forward: in std_logic; is_enabled: in std_logic; output_data: out std_logic_vector(7 downto 0)); end component; round_counter: in std_logic_vector(4 downto 0);; signal u0 : STD_LOGIC := '0';
case stato_corrente is when INVIA => en <='0'; req <= '1'; if( ack = '1') then stato_prossimo <= ASPETTA; else stato_prossimo <= INVIA ; end if ; end case; round_key_in: in std_logic_vector(63 downto 0);
input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64); case mode is when AUTO => ; when MANUAL => ; when SEMI_AUTO => ; when OFF => ; when others => ; end case ;; signal i_sda : std_logic;
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component; signal d_reg : std_logic;; constant a : std_logic_vector(6 downto 0) := "0001000";
if sela = '1' then q <= a; elsif selb = '1' then q <= b; else q <= c; end if; xenable <= enable when testen=0 or testin(TESTIN_WIDTH-2)='0' else (others => '0');
mem: process (CLK) begin if( rising_edge( CLK ) ) then if( RST = '1') then stato_corrente <= S0; else stato_corrente <= stato_prossimo; end if; end if; end process; component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component;
component display_seven_segments is generic ( clock_frequency_in : integer := 50000000; clock_frequency_out : integer := 5000000); port ( clock : in STD_LOGIC; reset : in STD_LOGIC; value32_in : in STD_LOGIC_VECTOR (31 downto 0); enable : in STD_LOGIC_VECTOR (7 downto 0); dots : in STD_LOGIC_VECTOR (7 downto 0); anodes : out  STD_LOGIC_VECTOR (7 downto 0); cathodes : out STD_LOGIC_VECTOR (7 downto 0)); end component; signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
signal i_cs_re_tk : std_logic; anodes : out  STD_LOGIC_VECTOR (7 downto 0);
signal u1 : STD_LOGIC := '0'; type stato is (S0, S1, S2);; out_signal <= data1 nor data2;
signal i_cs_fe_tk : std_logic; if jkl(15 downto 8) = x"88" then ; end if;
i_data_1_out <= i_data_1_out(i_data_1_out'length - 4 downto 0) & i_sck_cpy; component ROM port (RST: in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end component;
y <= "----"; i_data_4 <= (others => '0');; sda_o <= i_sda when rst_n_i = '1' else '0';
uut : component deglitcher port map (); constant five : std_logic_vector(6 downto 0) := "0010010";
constant clk_period : time := 10 ns; if ( current_state = secondo ) then x <= ( others => '0' ); end if;; clkin1_bufg : BUFG port map (O => clk_100MHz_clk_video, I => clk_100MHz);
a := a + 1; signal rst_n : std_logic := '1';; variable temperature : integer range -20 to 50 := 25;
if (count_reg < n - 1) then; signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0);
component display_seven_segments generic (CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500) port (CLK : IN std_logic; RST : IN std_logic; VALUE : IN std_logic_vector(31 downto 0); ENABLE : IN std_logic_vector(7 downto 0); DOTS : IN std_logic_vector(7 downto 0); ANODES : OUT std_logic_vector(7 downto 0); CATHODES : OUT std_logic_vector(7 downto 0)); end component; wait for 50*clk_period;; entity Riconoscitore_Mealy is port( i: in std_logic; rst, clk: in std_logic; y: out std_logic ); end Riconoscitore_Mealy;
signal count_tmp: STD_LOGIC_VECTOR (2 downto 0); signal t_clk : std_logic;; component input_handler is generic (COUNT_MAX: integer := 500000); port (row_sel: in std_logic_vector(4 downto 0); clk: in std_logic; reset: in std_logic; key_out: out std_logic_vector(7 downto 0); col_sel: out std_logic_vector(3 downto 0); keypress_out: out std_logic); end component;
constant SAMPLE_RATE : integer := 10000; constant eight : std_logic_vector(6 downto 0) := "0000000";
test0 : grtestmod port map (rst, clk, error, address(21 downto 2), smsc_data, smsc_ncs, oen, writen, open); constant TIMEOUT_VAL : integer := 1000;; if gls_reset = '1' then write_ack <= '0'; elsif rising_edge(gls_clk) then if ((wbs_strobe and wbs_write and wbs_cycle) = '1') then write_ack <= '1'; else write_ack <= '0'; end if; end if;
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal; ldac_i : in std_logic;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 2 downto 0) & i_ldac_cpy; if DSETS > 1 then if conv_integer(r.rndcnt) = (DSETS - 1) then v.rndcnt := (others => '0'); else v.rndcnt := r.rndcnt + 1; end if; end if;
use ieee.std_logic_1164.all; constant clk_period : time := 5 ns;; wait for clk_period / 2;
signal_16 <= signal_15(1); done_i : in std_logic;; UC: unita_controllo port map (tempq0, clock, reset, start, temp_count, temp_loadM, temp_count_in, temp_loadAQ, temp_shift, temp_selM, temp_selAQ, temp_selF, temp_sub, temp_stop_cu);
wait for 10 ns; cs_o : out std_logic;
component PicoCPU is port( rst: in std_logic; clk: in std_logic; FlagOut: out std_logic_vector ( 3 downto 0); IO: inout std_logic_vector (CPU_Bitwidth-1 downto 0); output: out std_logic_vector ( CPU_Bitwidth-1 downto 0)); end component; dbg_ila_probe0(31) <= cmd_fifo_empty;; clock_multiplier : integer := 5000000
if ((dci.eenaddr or dci.enaddr) = '1') or (r.dstate /= idle) or ((dsu = 1) and (dci.dsuen = '1')) or (r.flush = '1') or (is_fpga(memtech) = 1) then enable := (others => '1'); else enable := (others => '0'); end if; if(voltage < ref_voltage) then end if;; variable v : reg_type;
component modn is generic( n:integer := 4 ); port( clk: in std_logic; inc: in std_logic; enable: in std_logic; reset: in std_logic; overflow: out std_logic; output: out std_logic_vector(f_log2(n)-1 downto 0)); end component; signal count_tmp: STD_LOGIC_VECTOR (2 downto 0);
signal t_dac_val_2 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0); signal start    : std_logic;
tick_o_nxt <= '0'; ldac_o <= i_ldac when rst_n_i = '1' else '1';; output <= operand1 and operand2;
constant max_count : integer := btn_noise_time/CLK_period; UC: unita_controllo port map (tempq0, clock, reset, start, temp_count, temp_loadM, temp_count_in, temp_loadAQ, temp_shift, temp_selM, temp_selAQ, temp_selF, temp_sub, temp_stop_cu);; constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1;
noise(15) <= raw_lfsr(1); if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if;; i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0';
use ieee.math_real.all; component decoder_2_4 port( a : in STD_LOGIC_VECTOR(1 downto 0); y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;; reg_key_in: in std_logic;
variable temperature : integer range -20 to 50 := 25; CPU_Bitwidth := CPU_Bitwidth-78;
count_nxt <= count_reg + 1; if baz(20 downto 13) = x"3C" then ; end if;
i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0'; variable limit : integer range 0 to 255 := 255;
data_5_o => t_dac_val_5; stimuli : process begin rst <= '1'; wait for 100ns; rst <='0'; input <= '1'; wait for 100ns; input <= '0'; wait for 100ns; input <= '1'; wait; end process;
component altera_pll generic(clk_mul: integer := 1; clk_div: integer := 1; clk_freq: integer := 25000; clk2xen: integer := 0; sdramen: integer := 0); port(inclk0: in std_ulogic; e0: out std_ulogic; c0: out std_ulogic; c0_2x: out std_ulogic; locked: out std_ulogic); end component; done_o => t_done
c <= std_logic_vector(unsigned(c) + 1); component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;; signal data_out_temp1: std_logic_vector(63 downto 0);
component sbox is port(); end component; clk_en_i : in std_logic;
sck_gen : process (clk_i); tick_o_nxt <= '0';; component PicoCPU is port( rst: in std_logic; clk: in std_logic; FlagOut: out std_logic_vector ( 3 downto 0); IO: inout std_logic_vector (CPU_Bitwidth-1 downto 0); output: out std_logic_vector ( CPU_Bitwidth-1 downto 0)); end component;
if bar(21 downto 14) = x"2B" then ; end if; component add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
component unita_operativa is port(X, Y: in std_logic_vector(7 downto 0); clock, reset: in std_logic; loadAQ, shift, loadM, sub, selM, selAQ, selF, count_in: in std_logic; count: out std_logic_vector(2 downto 0); P: out std_logic_vector(15 downto 0)); end component; signal_20 <= signal_19(0);; done_o => t_done
if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if; entity clock_filter is generic(CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500); Port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC); end clock_filter;; component display_seven_segments is generic ( clock_frequency_in : integer := 50000000; clock_frequency_out : integer := 5000000); port ( clock : in STD_LOGIC; reset : in STD_LOGIC; value32_in : in STD_LOGIC_VECTOR (31 downto 0); enable : in STD_LOGIC_VECTOR (7 downto 0); dots : in STD_LOGIC_VECTOR (7 downto 0); anodes : out  STD_LOGIC_VECTOR (7 downto 0); cathodes : out STD_LOGIC_VECTOR (7 downto 0)); end component;
constant REVISION : integer := 0; input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64);
clk_process : process begin TbClockA <= '0'; wait for TbPeriodA/2; TbClockA <= '1'; wait for TbPeriodA/2; end process; count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;; component shift_register port (CLK : in std_logic; RST : in std_logic; SI : in std_logic; SO : out std_logic); end component;
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1; ldac_o => t_ldac
if start_i = '1' then ; end if; anodes : out  STD_LOGIC_VECTOR (7 downto 0);; pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);
signal BTN_state : stato := NOT_PRESSED; component TimeExpander generic (clock_multiplier : integer := 10000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end component TimeExpander;
stim_proc: process begin wait for 100 ns; i<='0'; wait for 10 ns; i<='0'; wait for 10 ns; i<='1'; input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64);
UC: unita_controllo port map (tempq0, clock, reset, start, temp_count, temp_loadM, temp_count_in, temp_loadAQ, temp_shift, temp_selM, temp_selAQ, temp_selF, temp_sub, temp_stop_cu); signal_5 <= signal_6(0);
wait for 120*clk_period; when done_st =>; signal i_ldac_cpy : std_logic;
signal clk_t : std_logic := '0'; constant clk_period : time := 5 ns;
if rising_edge(clock_in) then if( rst_n = '1') then value := -100; enable_sig <= '1'; value := value - 10; end if; end if; with s select y <= 	a0 when '0', a1 when '1', '-' when others;
if rising_edge(clk) then if( clear_sig = '1') then limit := 255; start_signal <= '1'; limit := limit + 20; end if; end if; case stato_corrente is when IDLE => if( start = '1' ) then stato_prossimo <= INVIA; else stato_prossimo <= IDLE; end if; end case;
clk_t <= not clk_t; sample_rate <= sample_rate - 20;
component ALU is generic (BitWidth: integer); port ( A: in std_logic_vector (BitWidth-1 downto 0); B: in std_logic_vector (BitWidth-1 downto 0); Command: in std_logic_vector (3 downto 0); Cflag_in: in std_logic; Cflag_out: out std_logic; Result: out std_logic_vector (BitWidth-1 downto 0)); end component; component key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0)); end component;
variable counter : integer range 0 to count_max_value := 0; signal BTN_state : stato := NOT_PRESSED;
stim_proc: process begin wait for 100 ns; input <= "1010"; control <= "00"; wait for 10 ns; assert output = '0' report "errore" severity failure; wait; end process; wait for 10 ns;; signal input : STD_LOGIC_VECTOR (0 to 1) := (others => 'U');
signal output : std_logic; component add_round_key is port(); end component;; component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;
if rising_edge(clk_in) then if( clear_sig = '1') then idx := 5; stop_sig <= '0'; idx := idx + 3; end if; end if; mux0: mux_2_1 port map(a0 => b0, a1 => b1, s => s0, y => u0);
constant five : std_logic_vector(6 downto 0) := "0010010"; library std;; i_sck_cpy <= i_scl;
sck_gen : process (clk_i); anodi <= (others=>'0');; type ctrarr is array (1 to NUM_C) of std_logic_vector(C_W-1 downto 0);
if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if; count_nxt <= 0;; clk_period: integer := 10;
component key_update is port () end component; constant max_count : integer := btn_noise_time/CLK_period;
reg_key_in: out std_logic_vector(79 downto 0); type ciao is (x, y, z);; entity present_top is port ( clock: in std_logic; rst: in std_logic; value_in: in std_logic_vector(15 downto 0); btn_plainText_in: in std_logic; btn_switch_display: in std_logic; catodi : out std_logic_vector (7 downto 0); anodi : out std_logic_vector (7 downto 0) ); end present_top;
strobe_i => t_stb; component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component;; entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
clk <= not clk after ct * 1 ns; i_data_4 <= (others => '0');
signal TbClockA : std_logic := '0'; signal temp_selF: std_logic;; component ROM port (RST: in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end component;
CPU_Bitwidth := CPU_Bitwidth+45; cat: cathodes_manager port map(value => ytemp, dot => dot, cathodes_dot => catodi);; signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0);
round_counter: out std_logic_vector(4 downto 0); architecture dataflow of half_adder is begin s <= x XOR y; c <= x AND y; end dataflow;; constant SCALE_FACTOR : integer := 10;
constant DATA_LEN : integer := 24; divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map () ;
if i_start_counter = STB_DLY - 1 then t_stb <= '1'; end if; constant f : std_logic_vector(6 downto 0) := "0001110";
signal i_slc_counter : integer range 0 to 100; variable speed : integer range 50 to 200 := 100;
rst_n_i : in std_logic; data_in : in STD_LOGIC_VECTOR (31 downto 0);
if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if; i_scl <= val_vector(i_counter_4);; rst_n_i : in std_logic;
variable v : mul_regtype; component abox port (); end component
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ); when other_st =>; i_data_4 <= (others => '0');
entity ROM_selector_onboard is port (clock_in : in STD_LOGIC; reset_in : in STD_LOGIC; addr_strobe_in : in STD_LOGIC; anodes_out : out STD_LOGIC_VECTOR(7 downto 0); cathodes_out : out STD_LOGIC_VECTOR(7 downto 0)); end ROM_selector_onboard; signal temp_stop_cu: std_logic;; signal TbClockA : std_logic := '0';
if (count_reg < n - 1) then; signal t_dac_val_5 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
type stato is (IDLE, INVIA, ASPETTA, FINITO); constant FACTOR : integer := 100;; signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');
signal ytemp : std_logic_vector (3 downto 0); constant clk_period : time := 10 ns;; with s select y <= 	a0 when '0', a1 when '1', '-' when others;
signal control : STD_LOGIC := 'U'; reg_key_in: in std_logic_vector(79 downto 0);; component present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0) ); end component;
i_slc_counter <= DAC_CLK_DIV - 1; if(count = max_count -1) then end if;; with f select z <= 	b0 when '0', a1 when '1', '-' when others;
i_scl_cnt <= 0; stringa2 <= ( others => '0' );
signal key_temp1_frac: std_logic_vector(3 downto 0); component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component;
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1; component modn is generic( n:integer := 4 ); port( clk: in std_logic; inc: in std_logic; enable: in std_logic; reset: in std_logic; overflow: out std_logic; output: out std_logic_vector(f_log2(n)-1 downto 0)); end component;
if DSETS > 1 then if conv_integer(r.rndcnt) = (DSETS - 1) then v.rndcnt := (others => '0'); else v.rndcnt := r.rndcnt + 1; end if; end if; memi.bwidth <= gpioo.val(1 downto 0);; result_sig <= input_x xor input_y;
signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0); shift_reg <= shift_reg(shift_reg'length - 3   downto 0) & sdi;; case state is when INIT => ; when PROCESSING => ; when WAITING => ; when FINISHED => ; when others => ; end case ;
signal_12 <= signal_11(4); entity cypher_layer is port(); end cypher_layer; sample_rate <= sample_rate - 20;
reg_count_reg <= reg_count_nxt; input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64);
signal temp_count: std_logic_vector(2 downto 0); kupd: key_update port map(reg_key_in,round_counter,reg_key_out);; signal i_clk_state : clk_state;
constant MAX_LIMIT : integer := 500; variable size : integer range 10 to 10000 := 1000;; stimuli : process begin rst <= '1'; wait for 100ns; rst <='0'; input <= '1'; wait for 100ns; input <= '0'; wait for 100ns; input <= '1'; wait; end process;
signal i_data_5 : std_logic_vector(DOUT_LEN - 1 downto 0); data_2_o => t_dac_val_2; scl_i : in std_logic;
weA <= '0', '1' after 50 ns, '0' after 650 ns; TYPE xhdl_46 IS ARRAY (0 TO 7) OF std_logic_vector(7 DOWNTO 0);
sbox_inst : sbox port map (); data_4_o : out std_logic_vector(15 downto 0);; if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0;
variable limit : integer range 0 to 255 := 255; i_data_3_out <= i_data_3_out(i_data_3_out'length - 4 downto 0) & i_ldac_cpy;; signal t_rst_n : std_logic;
TbClockB <= not TbClockB after TbPeriodB/2 when TbSimEnded /= '1' else '0'; signal tempq0, temp_selM, temp_selAQ, temp_clock, temp_sub,temp_loadAQ: std_logic;
value32_in : in  STD_LOGIC_VECTOR (31 downto 0); variable v : mul_regtype;; addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns;
signal i_ldac_fe_tk : std_logic; component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); end component;
mux_4_1 : process(y, key_in, exp_sn_out, reg_Q) begin case y is when "00" => reg_D <= key_in; when "01" => reg_D <= exp_sn_out; when others => reg_D <= reg_Q; end case; end process mux_4_1; variable speed : integer range 50 to 200 := 100;
entity Riconoscitore_Mealy is port( i: in std_logic; rst, clk: in std_logic; y: out std_logic ); end Riconoscitore_Mealy; i_data_5_out <= i_data_5_out(i_data_5_out'length - 2 downto 0) & i_data_0;; entity deglitcher is port (clk : in std_logic; rst_n : in std_logic; d : in std_logic; q : out std_logic); end entity deglitcher;
type x is array(0 to 15) of std_logic_vector(19 downto 0); noise(15) <= raw_lfsr(1);; signal current_state: state := secondo;
uut : shift_register port map (CLK => clk_tb, RST => rst, SI => input, SO => output); signal i_ldac_cpy : std_logic;; data <= buskeep(data) after 5 ns;
signal t_tick_o : std_logic; S <= (OP_A xor OP_B) xor CIN;
signal i_bit_counter : integer range 0 to 24; when idle_st =>; if mno(14 downto 7) = x"99" then ;end if;
if (rst='1') then stringa1 <= ( others => '0' ); end if; clk_period: integer := 10;; result <= input_a nand input_b;
i_cs <= sign_data(i_counter_3); variable index : integer range -10 to 10 := -5;; mem: ROM port map (rst => reset_n, addr => address_in, data => value_temp);
signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0); i_ldac <= '1';; outrotl(7 downto 1) <= portArotl(6 downto 0);
case status_code is when OK => ; when WARNING => ; when ERROR_CODE => ; when CRITICAL => ; when others => ; end case; UO: unita_operativa port map (X, Y, clock, reset, temp_loadAQ, temp_shift, temp_loadM, temp_sub, temp_selM, temp_selAQ, temp_selF, temp_count_in, temp_count, temp_p);
wait until s0_arready = '1'; enable : in std_logic;; architecture behavioral of counter is begin end behavioral ;
if rising_edge(CLK) then if RST = '1' then BTN_state <= NOT_PRESSED; CLEARED_BTN <= '0'; end if; end if; entity shift_reg is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;; wait for 120*clk_period;
assert output = '0' report "errore" severity failure; clk : in std_logic;; signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0);
data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); data_in : in STD_LOGIC_VECTOR (31 downto 0);; case stato_corrente is when INVIA => en <='0'; req <= '1'; if( ack = '1') then stato_prossimo <= ASPETTA; else stato_prossimo <= INVIA ; end if ; end case ;
stimulus : input <= X"00000000", X"00000008" after 10 ns, X"00000010" after 20 ns, X"00000018" after 30 ns, X"FFFFFFF8" after 40 ns, X"FFFFFFF0" after 50 ns, X"FFFFFF00" after 60 ns; signal start    : std_logic;
divisore_frequenza: clock_divider port map(clock, rst, clk_div); entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
signal enable : std_logic := '1'; variable counter : integer range 0 to count_max_value := 0;; mem: process (CLK) begin if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if; end process;
component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC ); end component; signal count_nxt : integer range 0 to n - 1;
count_nxt <= 0; type rom_type is array (0 to 7) of std_logic_vector(31 downto 0);; signal_12 <= signal_11(4);
clk_en_i => t_clk_en; signal output : STD_LOGIC := '0';; user_key: in std_logic_vector(79 downto 0);
component Riconoscitore_Mealy port( i : IN std_logic; CLK, RST : IN std_logic; Y : OUT std_logic); end component; when idle_st =>; data_3_o <= i_data_3_out when rst_n_i = '1' else (others => '0');
signal stringa2: std_logic_vector(15 downto 0) := (others=>'0'); if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if;; scl_o <= i_scl when rst_n_i = '1' else '0';
CLEARED_BTN <= '1'; constant DIV : integer := 200;
signal cont: std_logic_vector(4 downto 0):= "00000"; i_data_2 <= (others => '0');; wait for 95 ns;
wait for 20 us; data_3_o <= i_data_3_out when rst_n_i = '1' else (others => '0');
FA_0: myFA port map(OP_A => OP_A_RCA(0), OP_B => OP_B_RCA(0), CIN => CIN_RCA, S => s_int(0), COUT => cout_int(0)); entity present_top is port ( clock: in std_logic; rst: in std_logic; value_in: in std_logic_vector(15 downto 0); btn_plainText_in: in std_logic; btn_switch_display: in std_logic; catodi : out std_logic_vector (7 downto 0); anodi : out std_logic_vector (7 downto 0) ); end present_top;; architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi;
component carry_ripple_adder generic (WIDTH: integer); port (a: in std_logic_vector (WIDTH-1 downto 0); b: in std_logic_vector (WIDTH-1 downto 0); ci: in std_logic; s: out std_logic_vector (WIDTH-1 downto 0); co: out std_logic); end component; i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0';; signal i_sck_fe_tk : std_logic;
library work; data_0_o : out std_logic_vector(15 downto 0);
constant n : integer := 1000; entity encoder is port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end encoder;; signal t_clk_en : std_logic;
clk_process : process begin clk_tb <= '0'; wait for clk_period/2; clk_tb <= '1'; wait for clk_period/2; end process; clk : in std_logic;; kupd: key_update port map(reg_key_in,round_counter,reg_key_out);
with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others; data_5_o : out std_logic_vector(15 downto 0);; CASE s IS WHEN '0' => RETURN ('0'); WHEN '1' => RETURN ('1'); WHEN OTHERS => RETURN ('0'); END CASE;
reg_data_out(reg_data_out'length - 1 downto PIX_DEPTH) <= reg_data_out(reg_data_out'length - PIX_DEPTH - 1 downto 0); en: in std_logic;; sample_rate <= sample_rate - 20;
signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0); case state is when INIT => ; when PROCESSING => ; when WAITING => ; when FINISHED => ; when others => ; end case ;; entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;
gen_rx_ddr_lvds : for i in 0 to 4 generate inst_IDDR : IDDR generic map (DDR_CLK_EDGE => "SAME_EDGE_PIPELINED", SRTYPE => "ASYNC") port map (Q1 => rx_data_3x_i(i), Q2 => rx_data_3x_q(i), C => clk_rx_3x, CE => '1', D => rx_data_3x_ddr(i), R => rx_reset, S => '0'); inst_IBUFDS : IBUFDS generic map (DIFF_TERM => TRUE, IOSTANDARD => "DEFAULT") port map (I => RX_DATA_P(i), IB => RX_DATA_N(i), O => rx_data_3x_ddr(i)); end generate; counter: counter_mod8 port map(clock=> clock_in, reset => reset_n, enable => read_strobe, counter => address_in);
assert output = '0' report "errore" severity failure; S_RCA <= s_int;
stringa3 <= ( others => '0' ); constant c : std_logic_vector(6 downto 0) := "1000110";
with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others;     	; signal t_stb : std_logic;; signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
addr := to_integer(unsigned(ADR_I(10 downto 0))); i_scl <= '0';
cathodes_dot <= (not dot)&cathodes; configuration_vector <= "10000" when (autonegotiation = 1) else "00000";
stato_mem: process(clkA) begin if rising_edge(clkA) then if( RST = '1') then stato_corrente <= IDLE; else stato_corrente <= stato_prossimo; end if; end if; end process; case stato_corrente is when S0 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S1; end if; end case ;; address(0) <= '0';
i_clk_state <= clk_idle_st; out_data <= dividend or divisor;; entity present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0)); end present_cypher;
with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others; library gaisler;; ldac_i : in std_logic;
i_scl <= '0'; variable speed : integer range 50 to 200 := 100;; data_5_o => t_dac_val_5
signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0); key_registers(0) <= user_key;
signal cout_int: std_logic_vector(N-1 downto 0); diA <= "0000", "0001" after 150 ns, "0010" after 250 ns, "0011" after 350 ns, "0100" after 450 ns, "0101" after 550 ns;
if ( rst = '1' ) then; type rob is (x, c, v, b, n);
reg_key_out: out std_logic_vector(79 downto 0); p_arst: arst <= '1', '0' after 5 *C_CLK_PERIOD;; entity mux2_1_tb is port () end mux2_1_tb;
i_scl <= '0'; entity clock_filter is generic(CLKIN_freq : integer := 100000000; CLKOUT_freq : integer := 500); Port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC); end clock_filter;; entity rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end rom;
if ghi(16 downto 9) = x"77" then ; end if; case w is when 'U' => w := 'X'; when 'X' => null; when '0' => w := w2; when '+' | '-' => if w2 /= '0' then w := 'X'; end if; end case;
round_counter: in std_logic_vector(4 downto 0); ldac_o <= i_ldac when rst_n_i = '1' else '1';
signal cathodes : std_logic_vector(6 downto 0); tick_o_nxt <= '0';; initaddr := std_logic_vector((unsigned(initaddr) + 1));
signal_20 <= signal_19(0); signal t_stb : std_logic;; constant e : std_logic_vector(6 downto 0) := "0000110";
stato_uscita_mem: process(clk) begin if rising_edge(clk) then if(rst = '1') then stato_corrente <= S0; Y <= '0'; end if; end process; signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0);; signal data_out_temp1: std_logic_vector(63 downto 0);
wait for 100 ns; plaintext <= x"0000000000000000"; user_key <= x"00000000000000000000"; component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;; constant c : std_logic_vector(6 downto 0) := "1000110";
signal i_cs_fe_tk : std_logic; with f select z <= 	b0 when '0', a1 when '1', '-' when others;
signal u1 : STD_LOGIC := '0'; output_val <= val1 and val2;; if bar(21 downto 14) = x"2B" then ; end if;
i_data_2 <= i_data_2(i_data_2'length - 2 downto 0) & i_cs_fe_tk; pdl_empty <= unsigned(pdl_addr_reg) = 0;; round_counter: in std_logic_vector(4 downto 0);
rst_n : in std_logic; SampledBits <= SampledBits(SampledBits'length - 2 downto 0) & RxD_i;; when other_st =>
signal control : STD_LOGIC_VECTOR (1 downto 0) := (others => '0'); reg_key_in: in std_logic_vector(79 downto 0);
wait until s0_awready = '1' and s0_wready = '1'; if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if;; signal ROM : rom_type := (X"AAAAAAAA", X"BBBBBBBB", X"CCCCCCCC", X"DDDDDDDD", X"12345678", X"87654321", X"00112233", X"44556677");
signal TbClockA : std_logic := '0'; signal tick_o_reg : std_logic;
f_V_fu_377_p2 <= std_logic_vector(unsigned(r_V_10_cast1_i_cast_fu_353_p1) - unsigned(tmp_55_cast_i_cast_fu_373_p1)); uut: present_cypher port map(plaintext, cyphertext, user_key);
error_count <= error_count - 6; entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
signal stringa4: std_logic_vector(15 downto 0) := (others=>'0'); entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;
result_sig <= input_x xor input_y; signal i_sck_cpy : std_logic;; pl: perm_layer port map (data_out_temp2,data_out);
i_cs_fe_tk <= '1' when i_cs_cpy = '1' and i_cs = '0' else '0'; case (a) is when "00" => ; when "01" => ; when "10" => ; when "11" => ; when others => ; end case;
mux0: mux_2_1 port map(a0 => b0, a1 => b1, s => s0, y => u0); if rising_edge(CLK) then if RST = '1' then BTN_state <= NOT_PRESSED; CLEARED_BTN <= '0'; end if; end if;
constant a : std_logic_vector(6 downto 0) := "0001000"; if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;
sda_o <= i_sda when rst_n_i = '1' else '0'; signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);; component counter is generic (constant cnt_max : integer := 50000000); port ( iClk: in std_logic; iReset: in std_logic; is_forward: in std_logic; is_enabled: in std_logic; output_data: out std_logic_vector(7 downto 0)); end component;
constant six : std_logic_vector(6 downto 0) := "0000010"; signal value_to_display: std_logic_vector(31 downto 0);; data_5_o => t_dac_val_5
stringa1 <= ( others => '0' ); TYPE hex_digit IS ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f');; addr_dout_reg <= cmd(0) & addr_dout_reg(addr_dout_reg'length - 3 downto 1);
entity rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end rom; entity sistemaTOT is port ( clkA : in STD_LOGIC; clkB : in STD_LOGIC; rst : in STD_LOGIC; start : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR (31 downto 0)); end sistemaTOT;
addr := to_integer(unsigned(ADR_I(10 downto 0))); component ALU is generic (BitWidth: integer); port ( A: in std_logic_vector (BitWidth-1 downto 0); B: in std_logic_vector (BitWidth-1 downto 0); Command: in std_logic_vector (3 downto 0); Cflag_in: in std_logic; Cflag_out: out std_logic; Result: out std_logic_vector (BitWidth-1 downto 0)); end component;; output_signal <= input1 nor input2;
signal i_clk_cnt : integer range 0 to 2; ldac_o <= i_ldac when rst_n_i = '1' else '1';; type state is (idle, primo, secondo, terzo);
reg_key_out <= key_temp1 and round_counter; value_to_display <= cyphertext64(63 downto 32) when mode = false else cyphertext64(31 downto 0) when mode=true;
input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64); signal i_cmd_state : cmd_state;; constant five : std_logic_vector(6 downto 0) := "0010010";
constant DATA_LEN : integer := 24; S_RCA <= s_int;
entity TimeExpander is generic (clock_multiplier : integer := 5000000); port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; tick_o : out std_logic); end TimeExpander; constant DATA_LEN : integer := 24;; signal i_ldac : std_logic;
i_cs_fe_tk <= '1' when i_cs_cpy = '1' and i_cs = '0' else '0'; signal i_stb_re_tk : std_logic;
constant TbPeriodB : time := 40 ns; reg_key_out(19 downto 15) <= key_temp1(19 downto 15) xor round_counter;; clock_frequency_in : integer := 50000000;
type rob is (x, c, v, b, n); uut: present_cypher port map(plaintext, cyphertext, user_key);; RA0: full_adder port map(X(0), Y(0), c_in, temp(0), Z(0));
cs_o => t_cs; divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map () ;
signal mode : boolean := false; architecture rtl of clkmux_xilinx is component BUFGMUX port (O : out std_logic; I0, I1, S : in std_logic); end component; begin buf : bufgmux port map(S => sel, I0 => i0, I1 => i1, O => o); end architecture;; if rising_edge(clk) then if( reset_sig = '1') then value := 0; enable_sig <= '1'; value := value + 2; end if; end if;
if rising_edge(clock_in) then if( reset = '1') then counter := 0; clockfx <= '0'; counter := counter + 1; end if; end if; mux2: mux_2_1 port map(a0 => u0, a1 => u1, s => s1, y => y0);
clk_i : in std_logic; round_keys(i) <= key_registers(i)(79 downto 16);
component display_seven_segments is generic ( clock_frequency_in : integer := 50000000; clock_frequency_out : integer := 5000000); port ( clock : in STD_LOGIC; reset : in STD_LOGIC; value32_in : in STD_LOGIC_VECTOR (31 downto 0); enable : in STD_LOGIC_VECTOR (7 downto 0); dots : in STD_LOGIC_VECTOR (7 downto 0); anodes : out  STD_LOGIC_VECTOR (7 downto 0); cathodes : out STD_LOGIC_VECTOR (7 downto 0)); end component; signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);; signal t_dac_val_1 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal; signal i_sck_re_tk : std_logic;; signal i_stb_fe_tk : std_logic;
sda_i => t_sda; clk <= not clk after ct * 1 ns;
case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case; constant THRESHOLD : integer := 50;; i_cs_cpy <= '0';
sisA: sistemaA port map(start,clkA,rst,ack_tmp,data_tmp,req_tmp); case stato_corrente is when INVIA => en <='0'; req <= '1'; if( ack = '1') then stato_prossimo <= ASPETTA; else stato_prossimo <= INVIA ; end if ; end case ;; with sel select dataout <= "0001" when "00", "0010" when "01", "0100" when "10", "1000" when "11", (others => 'X') when others;
y <= "----"; component Encoder port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
output <= operand1 and operand2; signal i_cmd_state : cmd_state;; done_o <= i_done when rst_n_i = '1' else '0';
component present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0) ); end component; clock: in std_logic;; prova <= stringa1 & stringa2 & stringa3 & stringa4;
signal_4 <= signal_3(0); output <= operand1 and operand2;
case stato_corrente is when S2 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S0; end if; end case; i_cs <= '1';
i_cs <= '1'; output_data <= val_a or val_b;; clock_frequency_out : integer := 500
kupd: key_update port map(reg_key_in,round_counter,reg_key_out); signal t_rst_n : std_logic;
count <= c; if enable = '1' then if reg_count_reg = clock_multiplier - 1 then tick_o_nxt <= '1'; reg_count_nxt <= 0;; if rising_edge(clk_i) then if rst_n_i = '0' then i_cs_cpy <= '0'; else i_cs_cpy <= i_cs; end if; end if;
signal i_data_2 : std_logic_vector(DOUT_LEN - 1 downto 0); entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;; update_process: process(clk) begin ; end process update_process;
architecture behavioral of counter is begin end behavioral; i_cs_cpy <= i_cs;
uut: present_cypher port map(plaintext, cyphertext, user_key); signal round_key_temp: std_logic_vector(63 downto 0);; constant zero : std_logic_vector(6 downto 0) := "1000000";
component abox port (); end component; component altera_pll generic(clk_mul: integer := 1; clk_div: integer := 1; clk_freq: integer := 25000; clk2xen: integer := 0; sdramen: integer := 0); port(inclk0: in std_ulogic; e0: out std_ulogic; c0: out std_ulogic; c0_2x: out std_ulogic; locked: out std_ulogic); end component;
signal rst      : std_logic; if ((d xor d_reg) = '1') then ; end if;
rst_n : in std_logic; data_out: out std_logic_vector(63 downto 0);; signal t_ldac : std_logic;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi; use grlib.devices.all;
use techmap.gencomp.all; clock_frequency_out : integer := 5000000;; entity adder is port(a: in std_logic_vector(7 downto 0); b: in std_logic_vector(7 downto 0); cin: in std_logic; cout: out std_logic; sum: out std_logic_vector(7 downto 0)); end adder;
signal i_sck_re_tk : std_logic; data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0);
architecture bevy of inputmanager is begin end architecture; addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns;; weA <= '0', '1' after 50 ns, '0' after 650 ns;
signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0); constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1;; sbox_i: for i in 0 to 15 generate end generate sbox_i
x(4); constant n : integer := 1000;; wait until rising_edge(clk);
start_i : in std_logic; component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); end component;
signal RST : std_logic := '0'; entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;; signal t_stb : std_logic;
signal t_dac_val_1 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0); stato_uscita: process(stato_corrente,start,ack)
data_in: in std_logic_vector(63 downto 0); memi.bwidth <= gpioo.val(1 downto 0);; when done_st =>
signal i_slc_counter : integer range 0 to 100; if (vcount<=494 and vcount>=493) then VSync <= '0'; else VSync <= '1'; end if;; component add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
i_clk_state <= mamba(i_counter_2); constant clk_period : time := 5 ns;; signal input : STD_LOGIC_VECTOR (0 to 3) := (others => '0');
if rising_edge(clk) then if clr = '0' then q <= '0'; else q <= d; end if; signal i_ldac_cpy : std_logic;; signal i_cs_re_tk : std_logic;
signal data_out_temp1: std_logic_vector(63 downto 0); variable temperature : integer range -20 to 50 := 25;; signal i_ldac_cnt : integer range 0 to 4;
scl_i : in std_logic; signal i_ldac_cnt : integer range 0 to 4;; if i_slc_counter = 0 then ; end if;
signal_8 <= signal_7(0); signal d_nxt : std_logic;; wait for 120*clk_period;
signal key_temp1_frac: std_logic_vector(3 downto 0); i_data_0 <= i_data_0(i_data_0'length - 4 downto 0) & i_bit_counter;
signal i_cs_cpy : std_logic; reg_count_nxt <= 0;
memi.bwidth <= gpioo.val(1 downto 0); component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;; addr := to_integer(unsigned(ADR_I(10 downto 0)));
done_o : out std_logic; signal data_tmp: STD_LOGIC_VECTOR (31 downto 0);
i.cmd_byte_addr <= r.haddr(29 downto 2) & "00"; signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);; i_data_3 <= (others => '0');
signal dot : std_logic; signal t_scl : std_logic;
with s select y <= 	a0 when '0', a1 when '1', '-' when others; entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;
constant five : std_logic_vector(6 downto 0) := "0010010"; signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
data_1_o <= i_data_1_out when rst_n_i = '1' else (others => '0'); x <= y & z; signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
entity ripple_carry is port( X, Y: in std_logic_vector(7 downto 0); c_in: in std_logic; c_out: out std_logic; Z: out std_logic_vector(7 downto 0)); end ripple_carry; with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;; library ieee;
clk2xgen: if (clk2xen /= 0) generate clkena(1 downto 0) <= "11"; end generate; signal round_key_temp: std_logic_vector(63 downto 0);; component sbox is port(); end component;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0); if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if;
constant clk_period : time := 10 ns; use ieee.numeric_std.all;
component system_util_vector_logic_0_0 is port ( Op1 : in STD_LOGIC_VECTOR ( 0 to 0 ); Op2 : in STD_LOGIC_VECTOR ( 0 to 0 ); Res : out STD_LOGIC_VECTOR ( 0 to 0 )); end component; update_process: process(clk) begin if(rising_edge(clk)) then if(rst_n = '0') then count_reg <= 0; data_out_reg <= '0'; else count_reg <= count_nxt; data_out_reg <= data_out_nxt; end if; end if; end process update_process;
constant b : std_logic_vector(6 downto 0) := "0000011"; signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0);
key_temp1 <= reg_key_in( 18 downto 0 ) & reg_key_in( 79 downto 19 ); count_nxt <= 0;
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder; entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;
if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if; case mcmmo.data(PT_ET_U downto PT_ET_D) is when ET_INV => inv := '1'; when ET_PTD => ptd := '1'; goon := '1'; when ET_PTE => pte := '1'; found := '1'; when ET_RVD => rvd := '1'; null; when others => null; end case;; if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
blocks(0) <= plaintext; key_update is port () end key_update;; reg_key_in: in std_logic;
sda_i => t_sda; signal i_cmd_state : cmd_state;; component add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
signal i_bit_counter : integer range 0 to 24; pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);; if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;
X"BBBBBBBB"; case state_code is when STARTUP => ; when RUNNING => ; when HALTED => ; when SHUTDOWN => ; when others => ; end case ;; type stato is (IDLE, INVIA, ASPETTA, FINITO);
BSCAN_SPARTAN3_inst : BSCAN_SPARTAN3 port map ( CAPTURE => CAPTURE, DRCK1 => DRCK1, DRCK2 => open, RESET => open, SEL1 => SEL1, SEL2 => open, SHIFT => SHIFT, TDI => TDI, UPDATE => UPDATE, TDO1 => TDO1, TDO2 => open ); if rising_edge(clock_in) then if( clear_signal = '1') then count := 0; enable <= '1'; count := count - 1; end if; end if;
signal i_stb_re_tk : std_logic; clk : in std_logic;; result_sig <= input_x xor input_y;
type x is array(0 to 15) of std_logic_vector(19 downto 0); count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
i_data_0 <= i_data_0(i_data_0'length - 2 downto 0) & i_bit_counter; component abox port (data_in:  in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0) ); end component;; constant TbPeriodB : time := 40 ns;
if baz(20 downto 13) = x"3C" then ; end if; entity sistemaA is port ( start : in STD_LOGIC; clkA : in STD_LOGIC; rst : in STD_LOGIC; ack : in STD_LOGIC; dato : out STD_LOGIC_VECTOR (31 downto 0); req : out STD_LOGIC); end sistemaA;
signal_20 <= signal_19(0); signal_16 <= signal_15(1);
counter: counter_mod8 port map(clock=> clock_in, reset => reset_n, enable => read_strobe, counter => address_in); if ( current_state = secondo ) then x <= ( others => '0' ); end if;
if rst_n_i = '0' then ; end if; CASE s IS WHEN '0' => RETURN ('0'); WHEN '1' => RETURN ('1'); WHEN OTHERS => RETURN ('0'); END CASE;; variable count: integer := 0;
library ieee; signal current_state: state := secondo;
signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0); if (udbus/=X"0D" and udbus/=X"0A") then write(L,std_to_char(udbus)); end if;; signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal u1 : STD_LOGIC := '0'; constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1;; cypher: present_cypher port map (plaintext64, cyphertext64, x"00000000000000000000");
i_cs_fe_tk <= '1' when i_cs_cpy = '1' and i_cs = '0' else '0'; if mno(14 downto 7) = x"99" then ;end if;; entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;
sda_o : out std_logic; assert output = '0' report "errore" severity failure;
process(control, data_in_array) begin case (control) is when "00" => data_out <= data_in_array(0); when "01" => data_out <= data_in_array(1); when "10" => data_out <= data_in_array(2); when "11" => data_out <= data_in_array(3); when others => data_out <= "0000"; end case; end process; signal rst      : std_logic;
if gls_reset = '1' then write_ack <= '0'; elsif rising_edge(gls_clk) then if ((wbs_strobe and wbs_write and wbs_cycle) = '1') then write_ack <= '1'; else write_ack <= '0'; end if; end if; signal data_out_temp1: std_logic_vector(63 downto 0);
TYPE stdlogic_boolean_table is array(std_ulogic, std_ulogic) of boolean; data_5_o => t_dac_val_5; type data_t is array(0 to C_NUM_SENSORS - 1) of std_logic_vector (C_COUNTER_WIDTH - 1 downto 0);
configuration_vector <= "10000" when (autonegotiation = 1) else "00000"; signal tick_o_reg : std_logic;; i_scl <= '0';
component ButtonDebouncer generic (CLK_period: integer := 10; btn_noise_time: integer := 10000000) port (RST : in STD_LOGIC; CLK : in STD_LOGIC; BTN : in STD_LOGIC; CLEARED_BTN : out STD_LOGIC); end component; i_scl_cnt <= i_scl_cnt + 1;; gain_value <= gain_value - 12;
if rising_edge(clock_in) then end if; wait until s0_arready = '1';
i_data_0 <= i_data_0(i_data_0'length - 3 downto 0) & i_bit_counter; architecture behavioral of counter is begin end behavioral ;; case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case;
component Encoder port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end component; divisore_frequenza: clock_divider port map(clock, rst, clk_div);; constant TbPeriodB : time := 40 ns;
constant BUFFER_SIZE : integer := 256; assert sim_done_i = '0' report "Simulation Complete for:" & AXI_CHANNEL severity note;
variable value : integer range -1000 to 1000 := 0; reg_key_in: in std_logic_vector(79 downto 0);; stato_uscita: process(stato_corrente,start,ack)
entity deglitcher is port (clk : in std_logic; rst_n : in std_logic; d : in std_logic; q : out std_logic); end entity deglitcher; i_data_2 <= i_data_2(i_data_2'length - 2 downto 0) & i_cs_fe_tk;; reg_key_in: in std_logic_vector(79 downto 0);
mem: ROM port map (rst => reset_n, addr => address_in, data => value_temp); component UC_A is port ( clkA : in STD_LOGIC; rst : in STD_LOGIC; start: in STD_LOGIC; ack : in STD_LOGIC; count : in STD_LOGIC_VECTOR(2 downto 0); en : out STD_LOGIC; req : out STD_LOGIC); end component;
stimulus: process begin wait for 100 ns; wait for 10 ns; a<="00"; wait for 10 ns; wait; end process; address(0) <= '0';; signal rst_n : std_logic := '1';
use ieee.std_logic_1164.all; if start_i = '1' then ; end if ;; COUT_RCA <= cout_int(N-1);
entity present_top is port ( clock: in std_logic; rst: in std_logic; value_in: in std_logic_vector(15 downto 0); btn_plainText_in: in std_logic; btn_switch_display: in std_logic; catodi : out std_logic_vector (7 downto 0); anodi : out std_logic_vector (7 downto 0) ); end present_top; component modn is generic( n:integer := 4 ); port( clk: in std_logic; inc: in std_logic; enable: in std_logic; reset: in std_logic; overflow: out std_logic; output: out std_logic_vector(f_log2(n)-1 downto 0)); end component;
component counter is generic (constant cnt_max : integer := 50000000); port ( iClk: in std_logic; iReset: in std_logic; is_forward: in std_logic; is_enabled: in std_logic; output_data: out std_logic_vector(7 downto 0)); end component; signal temp_shift, temp_fshift: std_logic;
constant clk_period : time := 5 ns; component unita_operativa is port(X, Y: in std_logic_vector(7 downto 0); clock, reset: in std_logic; loadAQ, shift, loadM, sub, selM, selAQ, selF, count_in: in std_logic; count: out std_logic_vector(2 downto 0); P: out std_logic_vector(15 downto 0)); end component;
type core_type is array(1023 downto 0) of std_logic_vector(15 downto 0); use ieee.math_real.all;; case stato_corrente is when ASPETTA => req <='0'; if (ack = '0') then stato_prossimo <= FINITO; else stato_prossimo <= ASPETTA; end if;
counter <= c; component abox port (data_in:  in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0) ); end component;; if rst_n_i = '0' then ; end if;
TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic; if ( rst = '1' ) then
prom0: for i in 0 to (romwidth/8)-1 generate sr0: sram generic map (index => i+4, abits => romdepth, fname => promfile) port map (address(romdepth downto 1), data(31-i*8 downto 24-i*8), romsn(0), writen, oen); end generate; with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;
signal clk_tb : std_logic; i_sr_data <= i_sr_data(i_sr_data'length - 4 downto 0) & i_data_1_out;; entity sistemaTOT is port ( clkA : in STD_LOGIC; clkB : in STD_LOGIC; rst : in STD_LOGIC; start : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR (31 downto 0)); end sistemaTOT;
address(0) <= '0'; y <= "1000" when a="00" else "0100" when a="01" else "0010" when a="10" else "0001" when a="11" else "----";
clk_i : in std_logic; divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map(clock, rst, clk_div);
component perm_layer is port() end component; signal i_ldac_cnt : integer range 0 to 4;; process(control, data_in_array) begin case (control) is when "00" => data_out <= data_in_array(0); when "01" => data_out <= data_in_array(1); when "10" => data_out <= data_in_array(2); when "11" => data_out <= data_in_array(3); when others => data_out <= "0000"; end case; end process;
i_sda <= '0'; signal_17 <= signal_18(3);; component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component;
signal i_sck_fe_tk : std_logic; test0 : grtestmod port map (rst, clk, error, address(21 downto 2), smsc_data, smsc_ncs, oen, writen, open);; signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
signal t_ldac : std_logic; cypher: present_cypher port map (plaintext64, cyphertext64, x"00000000000000000000");; constant SCALE_FACTOR : integer := 10;
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ); signal data_out_reg, data_out_nxt : std_logic;
seven_segment_array: display_seven_segments generic map(CLKIN_freq => 100000000, CLKOUT_freq => 500) port map(CLK => clock_in, RST => reset_n, value => value_temp, enable => "11111111", dots => "00000000", anodes => anodes_out, cathodes => cathodes_out); i_sda <= data_i(i_bit_counter);
signal TbClockA : std_logic := '0'; signal c: std_logic_vector(2 downto 0);
use work.tb_AESA_if_pkg.all; i_ldac <= '1';; if rising_edge(clock_in) then if( rst_n = '1') then value := -100; enable_sig <= '1'; value := value - 10; end if; end if;
variable zero, rsigned, rmac : std_logic; entity ROM is port(RST : in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end ROM;; pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);
rst_n : in std_logic; i_data_0_out <= i_data_0_out(i_data_0_out'length - 2 downto 0) & i_data_2_out;
entity sistemaA is port ( start : in STD_LOGIC; clkA : in STD_LOGIC; rst : in STD_LOGIC; ack : in STD_LOGIC; dato : out STD_LOGIC_VECTOR (31 downto 0); req : out STD_LOGIC); end sistemaA; output_data <= val_a or val_b;; clk : in std_logic;
i_sda <= data_i(i_bit_counter); signal t_clk : std_logic;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi; if rising_edge(clk) then if( reset_sig = '1') then value := 0; enable_sig <= '1'; value := value + 2; end if; end if;; signal round_keys: dataArrayType;
entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register; wait for 100 ns;
clk200p <= not clk200p after 2.5 ns; entity key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0) ); end key_update;; entity cypher_layer is port(); end cypher_layer
entity shift_register is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register; RA7: full_adder port map(X(7), Y(7), temp(6), c_out, Z(7));; clk2xgen: if (clk2xen /= 0) generate clkena(1 downto 0) <= "11"; end generate;
when start_st =>; use work.tb_AESA_if_pkg.all;
clk_t <= not clk_t; s <= x xor y
key_registers(0) <= user_key; mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
entity deglitcher_testbench is end entity deglitcher_testbench; i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0';
i_clk_state <= clk_idle_st; signal key_temp1_frac: std_logic_vector(3 downto 0);; signal i_stb_re_tk : std_logic;
if rising_edge(clk_i) then ;  end if; when other_st =>; cathodes_dot <= (not dot)&cathodes;
clock_frequency_out : integer := 5000000; component PicoCPU is port( rst: in std_logic; clk: in std_logic; FlagOut: out std_logic_vector ( 3 downto 0); IO: inout std_logic_vector (CPU_Bitwidth-1 downto 0); output: out std_logic_vector ( CPU_Bitwidth-1 downto 0)); end component;; architecture behavioral of add_round_key is end behavioral
y( 10 ); use ieee.math_real.all;
reg_key_in: out std_logic_vector(79 downto 0); if rising_edge(clock_in) then if( rst_n = '1') then value := -100; enable_sig <= '1'; value := value - 10; end if; end if;; when other_st =>
entity sistemaTOT is port ( clkA : in STD_LOGIC; clkB : in STD_LOGIC; rst : in STD_LOGIC; start : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR (31 downto 0)); end sistemaTOT; if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if;; case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case;
with AC_I.use_logic select alu_logic_shift <= alu_logic when "01", not alu_logic when "11", alu_shift when others; signal cathodes : std_logic_vector(6 downto 0);; constant TbPeriodB : time := 40 ns;
if rising_edge(clock_in) then if( rst_n = '1') then value := -100; enable_sig <= '1'; value := value - 10; end if; end if; clk_i => t_clk; type stato is (S0, S1, S2);
TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic; wait for 100 ns; rst <= '0';
with s select y <= 	a0 when '0', a1 when '1', '-' when others; assert (to_x01(f_led(6)) = '1') report "*** IU in error mode, simulation halted ***" severity error;
counter <= c; case (a) is when "00" => ; when "01" => ; when "10" => ; when "11" => ; when others => ; end case;; if(rising_edge(clk)) then if(rst ='1') then c <= (others=>'0'); elsif(en ='1') then c <= x; end if; end if;
constant zero : std_logic_vector(6 downto 0) := "1000000"; entity sistemaTOT is port ( clkA : in STD_LOGIC; clkB : in STD_LOGIC; rst : in STD_LOGIC; start : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR (31 downto 0)); end sistemaTOT;; type mem_type is array (0 to 7) of std_logic_vector(31 downto 0);
component key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0)); end component; x <= y & z
component key_update is port () end component; i_data_4 <= i_data_4(i_data_4'length - 2 downto 0) & i_sr_data;
ldac_i => t_ldac; signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder; signal start    : std_logic;
done_o : out std_logic; if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if;; signal current_state: state := secondo;
signal i_sck_re_tk : std_logic; entity shift_reg is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register;; mux0: mux_2_1 port map(a0 => b0, a1 => b1, s => s0, y => u0);
component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component; stringa1 <= ( others => '0' );
constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1; sda_o <= i_sda when rst_n_i = '1' else '0';
constant one : std_logic_vector(6 downto 0) := "1111001"; if ( current_state = secondo ) then x <= ( others => '0' ); end if;; stringa3 <= ( others => '0' );
signal mem : mem_type; component abox port (); end component
tmp(1) <= tmp(0); y( 10 )
start_proc : process (t_clk) begin ; end process start_proc; constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1;
assert output = '0' report "errore0" severity failure; use ieee.std_logic_1164.all;; component abox port (); end component
signal i_data_3 : std_logic_vector(DOUT_LEN - 1 downto 0); i.cmd_byte_addr <= r.haddr(29 downto 2) & "00";
font_byte <= ram_font(to_integer(unsigned(font_address))); wait until rising_edge(clk);
key_temp1 <= reg_key_in( 18 downto 0 ) & reg_key_in( 79 downto 19 ); data_in : in STD_LOGIC_VECTOR (31 downto 0);
pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out); entity DAC_AD5724_mst is generic (DAC_D_IN_LEN_g : integer := 24); port (clk_i : in std_logic; rst_n_i : in std_logic; clk_en_i : in std_logic; start_i : in std_logic; strobe_i : in std_logic; done_o : out std_logic; data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o : out std_logic; sda_o : out std_logic; ldac_o : out std_logic; cs_o : out std_logic); end DAC_AD5724_mst;
if sela = '1' then q <= a; elsif selb = '1' then q <= b; else q <= c; end if; if i_sr_data(23 downto 16) = x"08" or i_sr_data(23 downto 16) = x"09"or i_sr_data(23 downto 16) = x"0A" or i_sr_data(23 downto 16) = x"0B" or i_sr_data(23 downto 16) = x"0C" then ; end if ;; CPU_Bitwidth := CPU_Bitwidth+45;
TYPE hex_number IS array (POSITIVE range <>) OF hex_digit; if i_start_counter = STB_DLY - 1 then t_stb <= '1'; end if;
reg_key_out(19 downto 15) <= key_temp1(19 downto 15) xor round_counter; when ready_st =>
memi.edac <= gpioo.val(2); constant t_clock_multiplier : integer := 50;; i_sda <= data_i(i_bit_counter);
entity add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end add_round_key; signal key_temp1_frac: std_logic_vector(3 downto 0);; architecture behavioral of deglitcher_testbench is begin end architecture behavioral;
signal t_done : std_logic; component shift_register port (CLK : in std_logic; RST : in std_logic; SI : in std_logic; SO : out std_logic); end component;; i_scl_cnt <= 0;
tempq0 <= temp_p(0); wait for 50*clk_period;
CLEARED_BTN <= '1'; i_scl <= '0';; signal i_cmd_state : cmd_state;
signal enable : std_logic := '1'; with f select z <= 	b0 when '0', a1 when '1', '-' when others;; component counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end component;
variable count : integer range 1 to 100 := 50; q : out std_logic
type stato is (S0, S1, S2, S3, S4); entity DAC_AD5724_mst is generic (DAC_D_IN_LEN_g : integer := 24); port (clk_i : in std_logic; rst_n_i : in std_logic; clk_en_i : in std_logic; start_i : in std_logic; strobe_i : in std_logic; done_o : out std_logic; data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o : out std_logic; sda_o : out std_logic; ldac_o : out std_logic; cs_o : out std_logic); end DAC_AD5724_mst;
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1; TYPE hex_number IS array (POSITIVE range <>) OF hex_digit;
signal i_cs_re_tk : std_logic; component Riconoscitore_Mealy port( i : IN std_logic; CLK, RST : IN std_logic; Y : OUT std_logic); end component;
case stato_corrente is when S2 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S0; end if; end case; value32_in : in  STD_LOGIC_VECTOR (31 downto 0);; reg_key_in: out std_logic_vector(79 downto 0);
entity inputmanager is port () end inputmanager; signal clk_t : std_logic := '0';
constant CLK_DIV : integer := 100; prova <= stringa1 & stringa2 & stringa3 & stringa4;
x: for i in 0 to CFG_NCPU-1 generate irqi(i).irl <= "0000"; end generate; data_out : out std_logic;
constant four : std_logic_vector(6 downto 0) := "0011001"; if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns; reg_key_in: out std_logic_vector(79 downto 0);; ark: add_round_key port map ();
i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0'; signal stringa3: std_logic_vector(15 downto 0) := (others=>'0');
case mode_code is when SAFE_MODE => ; when NORMAL_MODE => ; when SLEEP_MODE => ; when EMERGENCY_MODE => ; when others => ; end case; signal q_nxt : std_logic;; entity rom is port ( addr : in STD_LOGIC_VECTOR (2 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end rom;
signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0); tmp(1) <= tmp(0);
case flag_code is when FLAG_1 => ; when FLAG_2 => ; when FLAG_3 => ; when FLAG_4 => ; when others => ; end case; sbox_i : for i in 0 to 15 generate sboxi: sbox port map ( data_out_temp1 (4*i+3 downto 4*i), data_out_temp2(4*i+3 downto 4*i) ); end generate sbox_i;
signal i_clk_state : clk_state; signal q_reg : std_logic;; component FullAdder1Bit is Port (A: in STD_LOGIC; B: in STD_LOGIC; CIN: in STD_LOGIC; SUM: out STD_LOGIC; COUT: out STD_LOGIC); end component;
gmiii.tx_dv <= cnt_en when gmiio.tx_en = '1' else '1'; signal input : STD_LOGIC_VECTOR (0 to 3) := (others => '0');
signal_16 <= signal_15(1); assert output = '0' report "errore0" severity failure;
component counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end component; signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0);; signal i_cmd_state : cmd_state;
TYPE hex_number IS array (POSITIVE range <>) OF hex_digit; i_data_5_out <= i_data_5_out(i_data_5_out'length - 4 downto 0) & i_data_0;; clk_i => t_clk
wait for 100 ns; rst <= '0'; signal count_tmp: STD_LOGIC_VECTOR (2 downto 0);; y <= "----";
i_sr_data <= i_sr_data(i_sr_data'length - 4 downto 0) & i_data_1_out; signal i_clk_state : clk_state;
kupd: key_update port map(reg_key_in,round_counter,reg_key_out); with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;
entity ROM_selector_onboard is port (clock_in : in STD_LOGIC; reset_in : in STD_LOGIC; addr_strobe_in : in STD_LOGIC; anodes_out : out STD_LOGIC_VECTOR(7 downto 0); cathodes_out : out STD_LOGIC_VECTOR(7 downto 0)); end ROM_selector_onboard; signal i_data_1_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0); clk_en_i => t_clk_en
data_in: in std_logic_vector(63 downto 0); signal d_nxt : std_logic;
wait for 100 ns; clock_frequency_out : integer := 5000000;
architecture rtl of clkmux_xilinx is component BUFGMUX port (O : out std_logic; I0, I1, S : in std_logic); end component; begin buf : bufgmux port map(S => sel, I0 => i0, I1 => i1, O => o); end architecture; case mode_code is when SAFE_MODE => ; when NORMAL_MODE => ; when SLEEP_MODE => ; when EMERGENCY_MODE => ; when others => ; end case ;
start_i : in std_logic; entity pwm_generator is port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; data_out : out std_logic); end pwm_generator;; current_state <= idle;
signal clk_tb : std_logic; cs_i : in std_logic;; if(rising_edge(clock)) then
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder; wait for 100 ns;
round_keys(i) <= key_registers(i)(79 downto 16); i_data_1 <= i_data_1(i_data_1'length - 4 downto 0) & i_data_3_out;; constant a : std_logic_vector(6 downto 0) := "0001000";
constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1; signal ROM : rom_type := (X"AAAAAAAA", X"BBBBBBBB", X"CCCCCCCC", X"DDDDDDDD", X"12345678", X"87654321", X"00112233", X"44556677");
i_slc_counter <= DAC_CLK_DIV - 1; sck_edge : process (clk_i) begin ; end process ;
stato_mem: process(clkA) begin if rising_edge(clkA) then if( RST = '1') then stato_corrente <= IDLE; else stato_corrente <= stato_prossimo; end if; end if; end process; user_key: in std_logic_vector(79 downto 0);
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component; round_key_in: out std_logic_vector(63 downto 0);
if rising_edge(clk_in) then if( reset_n = '1') then temp := 25; start_sig <= '1'; temp := temp - 1; end if; end if; signal i_sck_cpy : std_logic;
signal i_ldac_cpy : std_logic; i_sck_cpy <= prova(i_counter_7);; variable speed : integer range 50 to 200 := 100;
if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if; with ciao select y <= a0 when '0', a1 when '1', '-' when others;
tick_o : out std_logic; if enable = '1' then if reg_count_reg = clock_multiplier - 1 then tick_o_nxt <= '1'; reg_count_nxt <= 0;; when other_st =>
signal t_stb : std_logic; key_temp1 <= reg_key_in( 18 downto 0 ) & reg_key_in( 79 downto 19 );
signal stringa3: std_logic_vector(15 downto 0) := (others=>'0'); mem: process (CLK) begin if(rising_edge(CLK)) then if( RST = '1') then stato_corrente <= S0; Y <= '0'; else stato_corrente <= stato_prossimo; Y <= Ytemp; end if; end if; end process;
signal c : std_logic_vector (2 downto 0) := (others => '0'); signal count_nxt : integer range 0 to n - 1;
signal c: std_logic_vector(2 downto 0); variable count : integer range 1 to 100 := 50;; i_slc_counter <= DAC_CLK_DIV - 1;
signal i_sda : std_logic; case i_clk_state is when clk_idle_st => ; when clk_gen_st => ; end case ;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi; signal reg_count_nxt : integer range 0 to clock_multiplier - 1;; count_nxt <= count_reg + 1;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 2 downto 0) & i_data_0; S_RCA <= s_int;; sample_rate <= sample_rate - 20;
wait until rising_edge(clk); component counter_mod8 port (clock : in STD_LOGIC; reset : in STD_LOGIC; enable : in STD_LOGIC; counter : out STD_LOGIC_VECTOR(2 downto 0)); end component;
component present_cypher is port (plaintext: in std_logic_vector(63 downto 0); cyphertext: out std_logic_vector(63 downto 0); user_key: in std_logic_vector(79 downto 0) ); end component; sda_o : out std_logic;; case current_state is when primo => if ( en = '1' ) then stringa2 <= stringa_in; current_state <= secondo ; end if ; end case ;
if rising_edge(clk_in) then if( clear_sig = '1') then idx := 5; stop_sig <= '0'; idx := idx + 3; end if; end if; signal t_btn_plaintext , t_switchdisplay , t_btn_key : std_logic;
if rising_edge(CLK) then if RST = '1' then BTN_state <= NOT_PRESSED; CLEARED_BTN <= '0'; end if; end if; signal temp_shift, temp_fshift: std_logic;
i_scl <= '0'; divisore_frequenza: clock_divider port map(clock, rst, clk_div);; TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic;
variable index : integer range -10 to 10 := -5; cs_o => t_cs
if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0; signal rst_n : std_logic := '1';; signal rst_n : std_logic := '1';
component system_util_vector_logic_0_0 is port ( Op1 : in STD_LOGIC_VECTOR ( 0 to 0 ); Op2 : in STD_LOGIC_VECTOR ( 0 to 0 ); Res : out STD_LOGIC_VECTOR ( 0 to 0 )); end component; signal i_dly_counter : integer range 0 to 400;
signal t_stb_counter : integer range 0 to 108; count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;; assert strobe = '1' report "prova" severity failure;
variable index : integer range -10 to 10 := -5; shift_reg <= shift_reg(shift_reg'length - 2 downto 0) & sdi;
signal y: STD_LOGIC_VECTOR(3 downto 0); signal control : STD_LOGIC_VECTOR (1 downto 0) := (others => '0');; sys_rst_in <= '0', '1' after 200 ns;
signal stringa3: std_logic_vector(15 downto 0) := (others=>'0'); entity MEM is port ( clk : in STD_LOGIC; addr: in STD_LOGIC_VECTOR(2 downto 0); write : in STD_LOGIC; data_in : in STD_LOGIC_VECTOR (31 downto 0); data_out : out STD_LOGIC_VECTOR (31 downto 0)); end MEM;
signal temp_selF: std_logic; case flag_code is when FLAG_1 => ; when FLAG_2 => ; when FLAG_3 => ; when FLAG_4 => ; when others => ; end case ;
scl_i => t_scl; entity Encoder_onBoard is port ( switch : in STD_LOGIC_VECTOR(9 downto 0); led : out STD_LOGIC_VECTOR(3 downto 0); catodi : out STD_LOGIC_VECTOR(7 downto 0); anodi : out STD_LOGIC_VECTOR(7 downto 0)); end Encoder_onBoard;
clock_frequency_out : integer := 5000000; case value is when "0000" => cathodes <= zero; when "0001" => cathodes <= one; when "0010" => cathodes <= two; when "0011" => cathodes <= three; when "0100" => cathodes <= four; when "0101" => cathodes <= five; when "0110" => cathodes <= six; when "0111" => cathodes <= seven; when "1000" => cathodes <= eight; when "1001" => cathodes <= nine; when "1010" => cathodes <= a; when "1011" => cathodes <= b; when "1100" => cathodes <= c; when "1101" => cathodes <= d; when "1110" => cathodes <= e; when "1111" => cathodes <= f; when others => cathodes <= (others => '0'); end case;
constant d : std_logic_vector(6 downto 0) := "0100001"; bdr: for i in 0 to 3 generate data_pad: iopadv generic map (level => padlevel, tech => padtech, width => 8) port map (sram_dq(31-i*8 downto 24-i*8), memo.data(31-i*8 downto 24-i*8), memo.bdrive(i), memi.data(31-i*8 downto 24-i*8)); end generate;; component perm_layer is port() end component;
tmp(1) <= tmp(0); case state_code is when STARTUP => ; when RUNNING => ; when HALTED => ; when SHUTDOWN => ; when others => ; end case ;
component ButtonDebouncer generic (CLK_period: integer := 10; btn_noise_time: integer := 10000000) port (RST : in STD_LOGIC; CLK : in STD_LOGIC; BTN : in STD_LOGIC; CLEARED_BTN : out STD_LOGIC); end component; signal data_out : std_logic_vector (31 downto 0);
kupd: key_update port map(reg_key_in,round_counter,reg_key_out); signal t_dac_val_4 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal key_temp1_frac: std_logic_vector(3 downto 0); with c.b_request_complete select c.a_request.size <= c.sys_master_dp_out.size when '1', r.b_request.size when '0', (others => 'X') when others;; reset : in  STD_LOGIC;
reg_key_in: out std_logic_vector(79 downto 0); signal cout_int: std_logic_vector(N-1 downto 0);
component deglitcher is port (clk : in std_logic; rst_n : in std_logic; d : in std_logic; q : out std_logic); end component; signal a: STD_LOGIC_VECTOR(1 downto 0);
sisA: sistemaA port map(start,clkA,rst,ack_tmp,data_tmp,req_tmp); entity pwm_generator is port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; data_out : out std_logic); end pwm_generator;
signal i_sck_re_tk : std_logic; signal TbClockA : std_logic := '0';; i_sda <= data_i(i_bit_counter);
signal ytemp : std_logic_vector (3 downto 0); if abc(18 downto 11) = x"5E" then ; end if;; anodes : out  STD_LOGIC_VECTOR (7 downto 0);
ldac_o <= i_ldac when rst_n_i = '1' else '1'; constant six : std_logic_vector(6 downto 0) := "0000010";; signal CLK : std_logic := '0';
component modn is generic( n:integer := 4 ); port( clk: in std_logic; inc: in std_logic; enable: in std_logic; reset: in std_logic; overflow: out std_logic; output: out std_logic_vector(f_log2(n)-1 downto 0)); end component; component key_update is port () end component;
if sela = '1' then q <= a; elsif selb = '1' then q <= b; else q <= c; end if; component sistemaTOT port (clkA : in std_logic; clkB : in std_logic; rst : in std_logic; start : in std_logic; data_out : out std_logic_vector (31 downto 0)); end component;
tick_o_nxt <= '0'; signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0);; signal i_dly_counter : integer range 0 to 400;
signal i_stb_fe_tk : std_logic; mux_4_1 is an entity with b0 as input std_logic signal, b1 as input std_logic signal, b2 as input std_logic signal, b3 as input std_logic signal, s0 as input std_logic signal, s1 as input std_logic signal, y0 as output std_logic signal
signal enable : std_logic := '1'; variable limit : integer range 0 to 255 := 255;
constant two : std_logic_vector(6 downto 0) := "0100100"; signal d_nxt : std_logic;
i_data_2 <= (others => '0'); data <= buskeep(data) after 5 ns;; i_sck_fe_tk <= '1' when i_sck_cpy = '1' and i_scl = '0' else '0';
BSCAN_SPARTAN3_inst : BSCAN_SPARTAN3 port map ( CAPTURE => CAPTURE, DRCK1 => DRCK1, DRCK2 => open, RESET => open, SEL1 => SEL1, SEL2 => open, SHIFT => SHIFT, TDI => TDI, UPDATE => UPDATE, TDO1 => TDO1, TDO2 => open ); entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;; clkB <= TbClockB;
gxa: IF (unsigned = 0) GENERATE cc(mantissa+10 DOWNTO mantissa+5) <= aa(32) & aa(32) & aa(32) & aa(32) & aa(32); END GENERATE; variable v : mul_regtype;
signal input : STD_LOGIC_VECTOR (0 to 1) := (others => 'U'); sbox_inst : sbox port map ();; signal count_reg : integer range 0 to n - 1;
signal i_cs_re_tk : std_logic; cypher: present_cypher port map (plaintext64, cyphertext64, x"00000000000000000000");
clk_i => t_clk; assert ip_pkt_count = x"00" report "ip_pkt_count not initialised correctly on reset";
signal data_tmp: STD_LOGIC_VECTOR (31 downto 0); sig_demux_sel_unsgnd  <=  UNSIGNED(sig_demux_sel_slice);; if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if;
constant SCALE_FACTOR : integer := 10; data_5_o => t_dac_val_5; signal i_data_4 : std_logic_vector(DOUT_LEN - 1 downto 0);
entity encoder is port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end encoder; signal tick_o_reg : std_logic;
signal my_sig: x; blocks(0) <= plaintext;
initaddr := std_logic_vector((unsigned(initaddr) + 1)); entity up_down_counter is generic ( WIDTH: positive := 8); port ( clk_en_p: in std_logic; up_down_p: in std_logic; value_p: out std_logic_vector(WIDTH - 1 downto 0); reset: in std_logic; clk: in std_logic); end up_down_counter;; cypher: present_cypher port map (plaintext64, cyphertext64, x"00000000000000000000");
i_data_1 <= i_data_1(i_data_1'length - 4 downto 0) & i_data_3_out; constant TbPeriodB : time := 40 ns;
signal a: STD_LOGIC_VECTOR(1 downto 0); s_result <= data_in1 nand data_in2;
if rising_edge(CLK) then if RST = '1' then BTN_state <= NOT_PRESSED; CLEARED_BTN <= '0'; end if; end if; stim_proc: process begin wait for 100 ns; i<='0'; wait for 10 ns; i<='0'; wait for 10 ns; i<='1';
signal i_data_2_out : std_logic_vector(DOUT_LEN - 1 downto 0); signal t_clk_en : std_logic;; entity key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0) ); end key_update;
i_cs_cpy <= '0'; signal cathodes : std_logic_vector(6 downto 0);
case mode is when AUTO => ; when MANUAL => ; when SEMI_AUTO => ; when OFF => ; when others => ; end case; entity inputmanager is port () end inputmanager;; component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component;
uut: decoder_2_4 port map ( a => a, y => y ); constant RES : reg_type := ('0', '0', '0', '0');
signal t_stb_counter : integer range 0 to 108; data_out: out std_logic_vector(63 downto 0);; if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns; signal_9 <= signal_10(3);
use work.tb_AESA_if_pkg.all; CLEARED_BTN <= '1';; type stato is (S0, S1, S2, S3, S4);
case operation is when ADD => ; when SUBTRACT => ; when MULTIPLY => ; when DIVIDE => ; when others => ; end case; CLEARED_BTN <= '1';
ark: add_round_key port map (); uut: present_cypher port map(plaintext, cyphertext, user_key);; component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); end component;
out_signal <= data1 nor data2; i_data_4 <= (others => '0');; sck_edge : process (clk_i) begin ; end process ;
COUT_RCA <= cout_int(N-1); constant d : std_logic_vector(6 downto 0) := "0100001";; TbClockB <= not TbClockB after TbPeriodB/2 when TbSimEnded /= '1' else '0';
uut: present_cypher port map(plaintext, cyphertext, user_key); X"BBBBBBBB"; signal data_out_temp3: std_logic_vector(63 downto 0);
nam1: for i in (CFG_NCPU+CFG_AHB_UART+CFG_GRPCI2_TARGET+CFG_GRPCI2_DMA+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE) to NAHBMST-1 generate ahbmo(i) <= ahbm_none; end generate; constant d : std_logic_vector(6 downto 0) := "0100001";; i_data_0 <= i_data_0(i_data_0'length - 3 downto 0) & i_bit_counter;
stim_proc: process begin wait for 100 ns; i<='0'; wait for 10 ns; i<='0'; wait for 10 ns; i<='1'; entity adder is port(A: in std_logic; B: in std_logic; carryIn: in std_logic; carryOut: out std_logic; fnord: out std_logic; baz: out std_logic_vector(7 downto 0); sum: out std_logic); end adder;
constant clk_period : time := 20 ns; signal_20 <= signal_19(0);; clkB <= TbClockB;
reg_data_out(reg_data_out'length - 1 downto PIX_DEPTH) <= reg_data_out(reg_data_out'length - PIX_DEPTH - 1 downto 0); entity DAC_AD5724_mst is generic(DAC_D_IN_LEN_g : integer := 24); port(clk_i:in std_logic; rst_n_i:in std_logic; clk_en_i:in std_logic; start_i:in std_logic; strobe_i:in std_logic; done_o:out std_logic; data_i:in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0); scl_o:out std_logic; sda_o:out std_logic; ldac_o:out std_logic; cs_o:out std_logic); end DAC_AD5724_mst;
i_cs <= '1'; case BTN_state is when NOT_PRESSED => ; when CHK_PRESSED => ; when PRESSED => ; when CHK_NOT_PRESSED => ; when others => ; end case ;
update_state : process (clk) is begin if rising_edge(clk) then if (rst_n = '0') then q_reg <= '0'; d_reg <= '0'; else count_reg <= count_nxt; q_reg <= q_nxt; d_reg <= d_nxt; end if; end if; end process update_state; stato_uscita_mem: process(clk) begin if rising_edge(clk) then if(rst = '1') then stato_corrente <= S0; Y <= '0'; end if; end process;
signal_17 <= signal_18(3); signal stringa2: std_logic_vector(15 downto 0) := (others=>'0');
signal value_to_display: std_logic_vector(31 downto 0); divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map () ;
signal en_tmp, req_tmp, ack_tmp, write_tmp: STD_LOGIC; signal i_ldac_cnt : integer range 0 to 4;
use ieee.math_real.all; entity tb_dac is end tb_dac;
signal d_nxt : std_logic; round_counter: out std_logic_vector(4 downto 0);
if(rst_n = '0') then ; end if; debouncer_plaintext_btn: button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_plainText_in, t_btn_plainText);; signal t_sda : std_logic;
output <= operand1 and operand2; data <= buskeep(data) after 5 ns;; constant max_count : integer := btn_noise_time/CLK_period;
utt : entity work.mux_2_1(dataflow_v2) port map( a0 => input(0), a1 => input(1), s => control, y => output ); case mcmmo.data(PT_ET_U downto PT_ET_D) is when ET_INV => inv := '1'; when ET_PTD => ptd := '1'; goon := '1'; when ET_PTE => pte := '1'; found := '1'; when ET_RVD => rvd := '1'; null; when others => null; end case;; count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns; if rising_edge(clk_i) then ; end if ;
signal tick_o_nxt : std_logic; count := 0;
BSCAN_SPARTAN3_inst : BSCAN_SPARTAN3 port map ( CAPTURE => CAPTURE, DRCK1 => DRCK1, DRCK2 => open, RESET => open, SEL1 => SEL1, SEL2 => open, SHIFT => SHIFT, TDI => TDI, UPDATE => UPDATE, TDO1 => TDO1, TDO2 => open ); entity pwm_generator is port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; data_out : out std_logic); end pwm_generator;
case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case; signal reg_count_nxt : integer range 0 to clock_multiplier - 1;
signal TbClockA : std_logic := '0'; use work.tb_AESA_if_pkg.all;; data_i : in std_logic_vector(DAC_D_IN_LEN_g - 1 downto 0);
use ieee.math_real.all; entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder; wait for 95 ns;
wait for 30 ns; plaintext <= x"5579c1387b228445"; user_key <= x"00000000000000000000"; x: for i in 0 to CFG_NCPU-1 generate irqi(i).irl <= "0000"; end generate;; i_data_2 <= (others => '0');
rotl: process(codoprotl, portArotl) begin if(codoprotl = "1101") then outrotl(0) <= portArotl(7); outrotl(7 downto 1) <= portArotl(6 downto 0); outFlagrotl <= '1'; else outrotl <= (others => 'Z'); outFlagrotl <= 'Z'; end if; end process rotl; entity encoder is port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end encoder;
signal rst : std_logic; if rising_edge(clk_in) then if( clear_sig = '1') then idx := 5; stop_sig <= '0'; idx := idx + 3; end if; end if;; signal_12 <= signal_11(4);
data_1_o <= i_data_1_out when rst_n_i = '1' else (others => '0'); clock_out <= clockfx;; if rising_edge(clk) then if clr = '0' then q <= '0'; else q <= d; end if;
signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0); clk_process : process begin CLK <= '0'; wait for CLK_period/2; CLK <= '1'; wait for CLK_period/2; end process;; signal CLK : std_logic := '0';
entity mux_2_1 is port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC ); end mux_2_1; anodes : out  STD_LOGIC_VECTOR (7 downto 0);
i_cs <= '1'; i_stb_cpy <= trial(i_counter_1);; sck_gen : process (clk_i)
signal t_btn_plaintext , t_switchdisplay , t_btn_key : std_logic; signal_17 <= signal_18(3);; y <= ((a0 and (NOT s)) OR (a1 and s));
signal i_ldac_fe_tk : std_logic; signal stringa4: std_logic_vector(15 downto 0) := (others=>'0');; signal data_out_temp1: std_logic_vector(63 downto 0);
signal round_key_temp: std_logic_vector(63 downto 0); wait until s0_arready = '1';
sync_proc : process (clk, rst_n) begin end process sync_proc; type state is (idle, primo, secondo, terzo);
if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if; if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if;; pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);
signal data_out_temp1: std_logic_vector(63 downto 0); case current_state is when primo => if ( en = '1' ) then stringa2 <= stringa_in; current_state <= secondo ; end if ; end case ;
data_2_o => t_dac_val_2; if bar(21 downto 14) = x"2B" then ; end if;; with GPIO_enable select GPIO_inout <= 	GPIO_write when '1', 'Z' when others;assert output = '0' report "errore0" severity failure;
if i_sr_data(23 downto 16) = x"08" or i_sr_data(23 downto 16) = x"09"or i_sr_data(23 downto 16) = x"0A" or i_sr_data(23 downto 16) = x"0B" or i_sr_data(23 downto 16) = x"0C" then ; end if; signal current_state: state := primo;; out_data <= dividend or divisor;
reg_key_out( 79 downto 76 ) <= key_temp1_frac; if (vcount<=494 and vcount>=493) then VSync <= '0'; else VSync <= '1'; end if;; case value is when "0000" => cathodes <= zero; when "0001" => cathodes <= one; when "0010" => cathodes <= two; when "0011" => cathodes <= three; when "0100" => cathodes <= four; when "0101" => cathodes <= five; when "0110" => cathodes <= six; when "0111" => cathodes <= seven; when "1000" => cathodes <= eight; when "1001" => cathodes <= nine; when "1010" => cathodes <= a; when "1011" => cathodes <= b; when "1100" => cathodes <= c; when "1101" => cathodes <= d; when "1110" => cathodes <= e; when "1111" => cathodes <= f; when others => cathodes <= (others => '0'); end case;
signal run : boolean := TRUE; constant MAX_LIMIT : integer := 500;
signal temp_reset_in: std_logic; bool_eqn is the architecture of reg_ctrl is begin rd_ctrl : reg_rd <= reg_addr_decoded and rd and io_en; rw_ctrl : reg_wr <= reg_addr_decoded and wr and io_en and not cpu_clk; end architecture bool_eqn;; component key_update is port () end component;
if rising_edge(clock_in) then if( reset = '1') then counter := 0; clockfx <= '0'; counter := counter + 1; end if; end if; sys_rst_in <= '0', '1' after 200 ns;; pwm_generator_inst : pwm_generator port map(clk => clk, rst_n => rst_n, enable => enable, data_out => data_out);
signal u1 : STD_LOGIC := '0'; signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ) ;
signal blocks: dataArrayType; signal u1 : STD_LOGIC := '0';