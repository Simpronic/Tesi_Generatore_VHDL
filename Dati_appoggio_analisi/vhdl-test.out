use ieee.math_real.all;
use techmap.allclkgen.all;
use ieee.std_logic_1164.all;
library work;
sbox_i : for i in 0 to 15 generate sboxi: sbox port map ( data_out_temp1 (4*i+3 downto 4*i), data_out_temp2(4*i+3 downto 4*i) ); end generate sbox_i;
component GPIO is generic (BitWidth: integer); port ( IO_sel: in std_logic; IO: inout std_logic_vector (BitWidth-1 downto 0); WrtData: in std_logic_vector (BitWidth-1 downto 0); RdData: out std_logic_vector (BitWidth-1 downto 0)); end component;
component clock_divider is generic ( clock_frequency_in : integer := 100000000; clock_frequency_out : integer := 500 ); port ( clock_in : in STD_LOGIC; reset : in STD_LOGIC; clock_out : out STD_LOGIC ); end component;
component GPIO is generic (BitWidth: integer); port ( IO_sel: in std_logic; IO: inout std_logic_vector (BitWidth-1 downto 0); WrtData: in std_logic_vector (BitWidth-1 downto 0); RdData: out std_logic_vector (BitWidth-1 downto 0)); end component;
entity RCA_Nbit is generic (N: natural range 0 to 32 := 8); port(OP_A_RCA, OP_B_RCA: in std_logic_vector(N-1 downto 0); CIN_RCA: in std_logic; S_RCA: out std_logic_vector(N-1 downto 0); COUT_RCA, OV: out std_logic); end RCA_Nbit;
data_2_o => t_dac_val_2
clk : in std_logic; 
clock: in std_logic;
cs_o => t_cs
cs_i => t_cs
anodes : out  STD_LOGIC_VECTOR (7 downto 0);
data_out: out std_logic_vector(63 downto 0)
rst_n : in std_logic;
data_3_o : out std_logic_vector(15 downto 0);
clk_i : in std_logic;
ldac_o : out std_logic;
reset : in  STD_LOGIC;
data_3_o : out std_logic_vector(15 downto 0);
clk_en_i => t_clk_en
data_5_o => t_dac_val_5
done_i => t_done
architecture bevy of inputmanager is begin end architecture;
architecture my_arch of cypher_layer is end my_arch
entity key_update is port(reg_key_in: in std_logic_vector(79 downto 0); round_counter: in std_logic_vector(4 downto 0); reg_key_out: out std_logic_vector(79 downto 0) ); end key_update;
signal i : std_logic := '0';
signal data_out_temp1: std_logic_vector(63 downto 0);
clock_frequency_out : integer := 500
signal i_stb_cpy : std_logic;
signal i_cs_re_tk : std_logic;
signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal key_temp1: std_logic_vector(79 downto 0);
signal i_sck_re_tk : std_logic;
signal i_ldac : std_logic;
signal a: STD_LOGIC_VECTOR(1 downto 0);
round_counter: in std_logic_vector(4 downto 0);
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal i_slc_counter : integer range 0 to 100;
signal output : std_logic;
signal round_keys: dataArrayType;
clock_frequency_out : integer := 5000000;
signal i_data_0_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal ytemp : std_logic_vector (3 downto 0);
signal t_btn_plaintext , t_switchdisplay , t_btn_key : std_logic; 
signal temp_p: std_logic_vector(15 downto 0);
signal t_dac_val_3 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0);
signal i_data_4_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal temp_loadM: std_logic;
signal ytemp : std_logic_vector (3 downto 0);
signal BTN_state : stato := NOT_PRESSED;
signal i_sck_cpy : std_logic;
signal t_stb_counter : integer range 0 to 108;
signal output : STD_LOGIC := '0';
signal i_data_5_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal TbClockA : std_logic := '0';
signal en_tmp: STD_LOGIC;
signal current_state: state := idle;
signal i_data_1_out : std_logic_vector(DOUT_LEN - 1 downto 0);
signal rst_n : std_logic := '1';
signal temp_shift, temp_fshift: std_logic;
signal i_data_0 : std_logic_vector(DOUT_LEN - 1 downto 0);
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ) ;
TYPE direction is (LITTLE_ENDIAN, BIG_ENDIAN);
type ciao is (x, y, z);
TYPE hex_number IS array (POSITIVE range <>) OF hex_digit;
if(rising_edge(clock)) then
sck_gen : process (clk_i)
process(clock)
if DSETS > 1 then if conv_integer(r.rndcnt) = (DSETS - 1) then v.rndcnt := (others => '0'); else v.rndcnt := r.rndcnt + 1; end if; end if;
if(sum /= difference) then end if;
if rst_n_i = '0' then ; end if;
if rst_n_i = '0' then ; end if;
if i_scl_cnt = DAC_D_IN_LEN and i_scl = '0' then ; end if;
if i_sr_data(23 downto 16) = x"08" then ; end if;
if ((d xor d_reg) = '1') then ; end if;
process(clock)
prova <= stringa1 & stringa2 & stringa3 & stringa4;
count <= c
tempq0 <= temp_p(0);
i_cs <= '1';
i_data_0 <= (others => '0');
i_cs <= sign_data(i_counter_3);
i_data_2 <= (others => '0');
when stop_st =>
signal_16 <= signal_15(1);
i_scl_cnt <= 0;
i_scl <= '0';
COUT_RCA <= cout_int(N-1);
i_scl_cnt <= 0;
i_sr_data <= (others => '0');
i_done <= '0';
out_data <= dividend or divisor;
out_signal <= data1 nor data2;
tempq0 <= temp_p(0);
out_data <= dividend or divisor;
y <= "----";
clkB <= TbClockB;
output <= operand1 and operand2;
TbClockB <= not TbClockB after TbPeriodB/2
stato_uscita_mem: process(clk) begin if rising_edge(clk) then if(rst = '1') then stato_corrente <= S0; Y <= '0'; end if; end process;
clk_process : process begin TbClockA <= '0'; wait for TbPeriodA/2; TbClockA <= '1'; wait for TbPeriodA/2; end process;
FF_D: process(clock) begin if(clock'event and clock='1') then if(reset='1') then y <= '0'; else y <= d; end if; end if; end process;
clk_process : process begin clk_tb <= '0'; wait for clk_period/2; clk_tb <= '1'; wait for clk_period/2; end process;
if rising_edge(clk_in) then if( reset_n = '1') then temp := 25; start_sig <= '1'; temp := temp - 1; end if; end if;
if rising_edge(clk) then if rst_n = '0' then tick_o_reg <= '0'; reg_count_reg <= 0;
stimuli : process begin rst <= '1'; wait for 100ns; rst <='0'; input <= '1'; wait for 100ns; input <= '0'; wait for 100ns; input <= '1'; wait; end process;
sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
sck_edge : process (clk_i) begin if rising_edge(clk_i) then if rst_n_i = '0' then i_sck_cpy <= '0'; elsif clk_en_i = '1' then i_sck_cpy <= i_scl; end if; end if; end process sck_edge;
sda_o <= i_sda when rst_n_i = '1' else '0';
y <= a0 when s = '0' else a1 when s = '1' else '-';
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
gmiii.tx_dv <= cnt_en when gmiio.tx_en = '1' else '1';
done_o <= i_done when rst_n_i = '1' else '0';
buffer_Full <= '1' when (addr_i = "1111") else '0';
data_1_o <= i_data_1_out when rst_n_i = '1' else (others => '0');
count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;
case current_state is when idle => ; when primo => ; when secondo => ; when terzo => ; end case;
case stato_corrente is when S2 => if( i = '0' ) then stato_corrente <= S0; Y <= '0'; else stato_corrente <= S0; end if; end case ;
when done_st =>
case mode is when AUTO => ; when MANUAL => ; when SEMI_AUTO => ; when OFF => ; when others => ; end case ;
current_state <= idle;
case BTN_state is when NOT_PRESSED => ; when CHK_PRESSED => ; when PRESSED => ; when CHK_NOT_PRESSED => ; when others => ; end case ;
when wait_stb_st =>
case ra.raddr(2 downto 2) is when "0" => rdata := r.hrdata(127 downto 0); when others => rdata := r.hrdata(255 downto 128); end case;
case current_state is when idle => ; when primo => ; when secondo => ; when terzo => ; end case;
i_bit_counter <= i_bit_counter - 1;
CPU_Bitwidth := CPU_Bitwidth-78;
i_scl_cnt <= i_scl_cnt + 1;
gain_value <= gain_value - 12;
entity deglitcher_testbench is end entity deglitcher_testbench;
entity Encoder_onBoard is port ( switch : in STD_LOGIC_VECTOR(9 downto 0); led : out STD_LOGIC_VECTOR(3 downto 0); catodi : out STD_LOGIC_VECTOR(7 downto 0); anodi : out STD_LOGIC_VECTOR(7 downto 0)); end Encoder_onBoard;
use ieee.numeric_std.all;
entity add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end add_round_key;
entity FFD is port( clock, reset, d: in std_logic; y : out std_logic := '0' ); end FFD;
entity comparator is port(clock: in std_logic; A,B: in std_logic_vector(7 downto 0); IAB: in std_logic; Output: out std_logic); end comparator;
component FullAdderSub is Port ( C_in : in  STD_LOGIC; A : in  STD_LOGIC; B : in  STD_LOGIC; Add_Sub: in STD_LOGIC; C_out : out  STD_LOGIC; Sum : out  STD_LOGIC); end component;
entity pwm_generator is port (clk : in std_logic; rst_n : in std_logic; enable : in std_logic; data_out : out std_logic); end pwm_generator;
component counter_mod8 port (clock : in STD_LOGIC; reset : in STD_LOGIC; enable : in STD_LOGIC; counter : out STD_LOGIC_VECTOR(2 downto 0)); end component;
component abox port (data_in:  in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0) ); end component;
component cathodes_manager port(value : in std_logic_vector(3 downto 0); dot : in std_logic; cathodes_dot : out std_logic_vector(7 downto 0)); end component;
component cathodes_manager port(value : in std_logic_vector(3 downto 0); dot : in std_logic; cathodes_dot : out std_logic_vector(7 downto 0)); end component;
component input_handler is generic (COUNT_MAX: integer := 500000); port (row_sel: in std_logic_vector(4 downto 0); clk: in std_logic; reset: in std_logic; key_out: out std_logic_vector(7 downto 0); col_sel: out std_logic_vector(3 downto 0); keypress_out: out std_logic); end component;
component Encoder port( X : in STD_LOGIC_VECTOR(9 downto 0); Y : out STD_LOGIC_VECTOR(3 downto 0) ); end component;
component read_pointer port ( rptr : out std_logic_vector(4 downto 0); fifo_rd : out std_logic; clk : in std_logic; rst_n: in std_logic; rd : in  std_logic; fifo_empty: in std_logic ); end component;
component ROM port (RST: in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end component;
debouncer_display_btn : button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_switch_display, t_switchDisplay);
debouncer_plaintext_btn: button_debouncer generic map ( clk_period => 10, btn_noise_time => 10000000) port map(rst, clock, btn_plainText_in, t_btn_plainText);
uut: Riconoscitore_Mealy port map(i => i, CLK => CLK, RST => RST, Y => Y);
sbox_inst : sbox port map ();
input_mag: inputmanager port map(clock, rst, value_in, t_btn_plainText, plaintext64);
u2: component ycbcr_to_rgb port map(clk => clk, y => y, cb => cb, cr => cr, red => red, green => green, blue => blue);
cat: cathodes_manager port map(value => ytemp, dot => dot, cathodes_dot => catodi);
FA_0: myFA port map(OP_A => OP_A_RCA(0), OP_B => OP_B_RCA(0), CIN => CIN_RCA, S => s_int(0), COUT => cout_int(0));
debouncer: ButtonDebouncer generic MAP(CLK_period => 10, btn_noise_time => 10000000) port map(RST => reset_n, CLK => clock_in, BTN => addr_strobe_in, CLEARED_BTN => read_strobe);
divisore_frequenza: clock_divider generic map ( clock_frequency_in => 100000000, clock_frequency_out => 100 ) port map(clock, rst, clk_div);
wait until clock='1';
wait for 120*clk_period;
wait for 50*clk_period;
wait for 95 ns;
wait for 100 ns; rst <= '0';
constant zero : std_logic_vector(6 downto 0) := "1000000";
constant TbPeriodB : time := 40 ns;
constant THRESHOLD : integer := 50;
constant LATCH_CNT : boolean := clatch /= 0;
constant n : integer := 1000;
constant unsaccoditempo : time := 550 ns;
constant TbPeriodB : time := 40 ns;
constant FACTOR : integer := 100;
constant d : std_logic_vector(6 downto 0) := "0100001"; 
gen_rx_ddr_lvds : for i in 0 to 4 generate inst_IDDR : IDDR generic map (DDR_CLK_EDGE => "SAME_EDGE_PIPELINED", SRTYPE => "ASYNC") port map (Q1 => rx_data_3x_i(i), Q2 => rx_data_3x_q(i), C => clk_rx_3x, CE => '1', D => rx_data_3x_ddr(i), R => rx_reset, S => '0'); inst_IBUFDS : IBUFDS generic map (DIFF_TERM => TRUE, IOSTANDARD => "DEFAULT") port map (I => RX_DATA_P(i), IB => RX_DATA_N(i), O => rx_data_3x_ddr(i)); end generate;
gen_num:FOR N IN LOOP_COUNT-1 DOWNTO 0 GENERATE rd_gen_inst2:fifo_rng GENERIC MAP(WIDTH => 8, SEED => TB_SEED+N) PORT MAP(CLK => RD_CLK, RESET => RESET, RANDOM_NUM => rand_num(8*(N+1)-1 downto 8*N), ENABLE => pr_r_en ); END GENERATE;
signal round_keys: dataArrayType;
type hsv_function is array ( 0 to 255) of integer;
TYPE xhdl_17 IS ARRAY (0 TO 63) OF std_logic;
type hsv_function is array ( 0 to 255) of integer;
outrotl(7 downto 1) <= portArotl(6 downto 0);
x(4)
blocks(0) <= plaintext;
clock_multiplier : integer := 5000000
clock_multiplier : integer := 10000000
memory_ram(to_integer(unsigned(address_a) + index)) <= data_in_a(((ram_word_size)*(index + 1) - 1) downto ((ram_word_size)*index)); 
type memory_array is array (0 to 31) of std_logic_vector(31 downto 0); signal matrix_mem : memory_array; signal row_data : std_logic_vector(31 downto 0); row_data <= matrix_mem(24);
addr := to_integer(unsigned(ADR_I(10 downto 0)));
signal data_block : std_logic_vector(167 downto 0); signal eighth : std_logic_vector(20 downto 0); eighth <= data_block(125 downto 105);
font_byte <= ram_font(to_integer(unsigned(font_address)));
signal mega_packet : std_logic_vector(255 downto 0); signal quarter : std_logic_vector(63 downto 0); quarter <= mega_packet(191 downto 128);
with color_code select rgb_out <= "11100000" when RED, "00011100" when GREEN, "00000011" when BLUE, "00000000" when others;
with data select decoded <= "00000001" when "00001001110100011111", "00000010" when "00001001110100011110", "00000011" when "00001001110100001111", "00000100" when "00001001110100001110", "00000101" when "00001001110100101001", "00000110" when "00001001110100101000", "00000111" when "00001001110100101101", "00001000" when "00001001110100101100", "00001001" when "00001001110100010001", "00010000" when "00001001110100010000", "00010001" when "00001001110100011001", "00010010" when "00001001110100011000", "00010011" when "00001001110100001101", "00010100" when "00001001110100001100", "00010101" when "00001001110100100111", "00010110" when "00001001110100100110", "00010111" when "00001001110100101011", "00011000" when "00001001110100101010", "00011001" when "00001001110100111000", "00100000" when "00001001110100110111", "11101110" when others;
with selector select constant_out <= 42 when "000", 101 when "001", 255 when "010", 0 when others;
with pack_mode select packed_data <= data_in & x"00" when ZERO_PAD, x"FF" & data_in when FF_PAD, data_in & data_in when DUPLICATE, data_in when others;
with shift_amount select shifted_data <= data_in when "000", data_in(6 downto 0) & '0' when "001", data_in(5 downto 0) & "00" when "010", (others => '0') when others;
with a select y <= "1000" when "00", "0100" when "01" , "0010" when "10", "0001" when "11", "----" when others;
with clk_div_sel select clk_out <= clk_in when "00", clk_div2 when "01", clk_div4 when "10", clk_div8 when others;
assert not (data_valid = '1' and clock_enable = '0') report "Data marked valid when clock is disabled" severity error;
assert output'event report "Output not updated on falling clock edge" severity error when falling_edge(clk) and enable = '1';
assert reset'delayed(10 ns) = '0' report "Reset pulse width too short" severity error when falling_edge(reset);
assert data_out = "10101010" report "Unexpected data pattern" severity warning;
assert output /= prev_output report "Output not toggling in toggle mode" severity error when rising_edge(clk) and toggle_mode = '1';
assert output = '0' report "errore0" severity failure;
architecture archi of shift_register is signal tmp: std_logic_vector(3 downto 0); begin process (CLK) begin if (rising_edge(CLK)) then if (RST='1') then tmp <= (others => '0'); else tmp(0) <= SI; tmp(1) <= tmp(0); tmp(2) <= tmp(1); tmp(3) <= tmp(2); end if; end if; end process; SO <= tmp(3); end archi;
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
entity half_adder is port (x, y : in std_logic; s, c : out std_logic); end half_adder
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component;
entity decoder_2_4 is port(a : in STD_LOGIC_VECTOR (1 downto 0); y : out STD_LOGIC_VECTOR (3 downto 0)); end decoder_2_4;
entity mul8x8 is port ( x: in unsigned (7 downto 0); y : in unsigned(7 downto 0); p: out unsigned(15 downto 0)); end mul8x8;
variable size : integer range 10 to 10000 := 1000;
variable limit : integer range 0 to 255 := 255;
variable acc, acc1, acc2 : std_logic_vector(48 downto 0);
variable counter : integer range 0 to count_max_value := 0;
SampledBits <= SampledBits(SampledBits'length - 3 downto 0) & RxD_i;
i_data_5_out <= i_data_5_out(i_data_5_out'length - 2 downto 0) & i_data_0;
shift_reg <= shift_reg(shift_reg'length - 2 downto 0) & sdi;
i_data_3_out <= i_data_3_out(i_data_3_out'length - 3 downto 0) & i_ldac_cpy;
i_data_2 <= i_data_2(i_data_2'length - 4 downto 0) & i_cs_fe_tk;
i_data_1_out <= i_data_1_out(i_data_1_out'length - 2 downto 0) & i_sck_cpy;
addrA <= "000000000000", "000000000001" after 150 ns, "000000000010" after 250 ns, "000000000011" after 350 ns, "000000000100" after 450 ns, "000000000101" after 550 ns;
t_rst_n <= '0', '1' after CLK_HPER * 10;
signal t_ldac : std_logic;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity glitch_filter is port ( Noisy_In : in std_logic; Filtered_Out : out std_logic ); end entity ; architecture behavioral of glitch_filter is begin process (Noisy_In) begin if rising_edge(Noisy_In) then Filtered_Out <= '1'; else Filtered_Out <= '0'; end if ; end process ; end architecture ;
process(clk) begin if rising_edge(clk) then sum <= sum - buffer(head) + input; buffer(head) <= input; if head = BUFFER_SIZE - 1 then head <= 0; else head <= head + 1; end if; output <= sum / BUFFER_SIZE; end if; end process;
process(clk,rst)begin if rst='1'then data_out<='0';elsif rising_edge(clk)then if manchester_in=clk then data_out<='1';else data_out<='0';end if;end if;end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Register_NBit is Generic(N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Enable : in STD_LOGIC; D : in STD_LOGIC_VECTOR (N-1 downto 0); Q : out STD_LOGIC_VECTOR (N-1 downto 0)); end Register_NBit; architecture Behavioral of Register_NBit is begin process (Clock, Reset) begin if Reset = '1' then Q <= (others => '0'); elsif rising_edge(Clock) and Enable = '1' then Q <= D; end if ; end process ; end Behavioral;
process(a, b) begin if a > b then greater <= '1'; equal <= '0'; less <= '0'; elsif a < b then greater <= '0'; equal <= '0'; less <= '1'; else greater <= '0'; equal <= '1'; less <= '0'; end if; end process;
process(sclk,rst)begin if rst='1'then miso<='0';shift_reg<=(others=>'0');elsif rising_edge(sclk)then shift_reg<=shift_reg(6 downto 0)&mosi;miso<=shift_reg(7);end if;end process;
process(clk,rst)begin if rst='1'then count<=0;freq<=0;elsif rising_edge(clk)then if gate='1'then count<=count+1;else freq<=count;count<=0;end if;end if;end process;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity ps_converter is generic (N : natural := 8); port ( Clk : in std_logic; Parallel_In : in std_logic_vector(N-1 downto 0); Load_En : in std_logic; Serial_Out : out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of ps_converter is begin process (Clk, Parallel_In, Load_En) begin if rising_edge(Clk) then if Load_En = '1' then Serial_Out <= Parallel_In; end if ; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity fixed_point_converter is generic ( M: natural := 32; N: natural := 16 ); port ( float_value: in std_logic_vector(M-1 downto 0); fixed_point: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of fixed_point_converter is begin process (float_value) variable fp_value: signed(M-1 downto 0); variable int_value: signed(N-1 downto 0); begin fp_value := signed(float_value); int_value := resize(fp_value, N); fixed_point <= std_logic_vector(int_value); end process ; end architecture ;
process(clk) begin if rising_edge(clk) then if we = '1' then mem(to_integer(unsigned(addr))) <= data_in; data_out <= (others => 'Z'); elsif re = '1' then data_out <= mem(to_integer(unsigned(addr))); else data_out <= (others => 'Z'); end if; end if; end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity frequency_divider is Generic (N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Divide_Ratio : in UNSIGNED(N-1 downto 0); Divided_Clock : out STD_LOGIC); end frequency_divider; architecture Behavioral of frequency_divider is signal counter : UNSIGNED(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then counter <= (others => '0'); Divided_Clock <= '0'; elsif rising_edge(Clock) then if counter < Divide_Ratio then counter <= counter + 1; else counter <= (others => '0'); Divided_Clock <= not Divided_Clock; end if ; end if ; end process ; end Behavioral;
process(clk) begin if rising_edge(clk) then case state is when IDLE => if start = '1' then state <= SETUP; counter <= 0; ss_n <= (others => '1'); ss_n(to_integer(unsigned(slave_select))) <= '0'; when SETUP => state <= SHIFT; when SHIFT => if counter < 8 then sclk <= not sclk; if sclk = '0' then mosi <= tx_data(7 - counter); else counter <= counter + 1; miso_data(7 - counter) <= miso; end if; else state <= DONE; end if; when DONE => ss_n <= (others => '1'); rx_data <= miso_data; data_valid <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then if counter < duty_cycle then pwm_out <= '1'; else pwm_out <= '0'; end if; if counter = period - 1 then counter <= 0; else counter <= counter + 1; end if; end if; end process;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity crc_checker is generic (N : natural := 32; M : natural := 8); port (Data_In : in std_logic_vector(N-1 downto 0); Received_CRC : in std_logic_vector(M-1 downto 0); Polynomial : in std_logic_vector(M-1 downto 0); CRC_Match : out std_logic); end entity ; architecture behavioral of crc_checker is signal data_reg : std_logic_vector(N-1 downto 0); signal received_crc_reg : std_logic_vector(M-1 downto 0); signal polynomial_reg : std_logic_vector(M-1 downto 0); signal crc_match_reg : std_logic; begin process (Data_In, Received_CRC, Polynomial) variable data_poly_xor : std_logic_vector(N-1 downto 0); variable received_crc_poly_xor : std_logic_vector(M-1 downto 0); begin data_poly_xor := Data_In xor Polynomial; received_crc_poly_xor := Received_CRC xor Polynomial; crc_match_reg <= '1' when data_poly_xor = received_crc_poly_xor else '0'; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity fixed_point_divider is generic (N: natural := 8); port ( dividend: in signed(N-1 downto 0); divisor: in signed(N-1 downto 0); quotient: out signed(N-1 downto 0); remainder: out signed(N-1 downto 0) ); end entity ; architecture behavioral of fixed_point_divider is begin process (dividend, divisor) variable quotient_temp: signed(N-1 downto 0); variable remainder_temp: signed(N-1 downto 0); begin if (divisor = to_signed(0, N)) then quotient <= (others => '0'); remainder <= (others => '0'); else quotient_temp := dividend / divisor; remainder_temp := dividend mod divisor; quotient <= quotient_temp; remainder <= remainder_temp; end if ; end process ; end architecture ;
library IEEE; use IEEE.std_logic_1164.all; entity magnitude_comparator is port (A1, A0, B1, B0: in std_logic; A_Greater, A_Equal, A_Smaller: out std_logic); end entity ; architecture behavioral of magnitude_comparator is begin process (A1, A0, B1, B0) variable a, b: integer range 0 to 3; begin if (A1 = '1' and A0 = '1') then a := 2; elsif (A1 = '1' and A0 = '0') then a := 1; else a := 0; end if ; if (B1 = '1' and B0 = '1') then b := 2; elsif (B1 = '1' and B0 = '0') then b := 1; else b := 0; end if ; if (a > b) then A_Greater <= '1'; A_Equal <= '0'; A_Smaller <= '0'; elsif (a = b) then A_Greater <= '0'; A_Equal <= '1'; A_Smaller <= '0'; else A_Greater <= '0'; A_Equal <= '0'; A_Smaller <= '1'; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity binary_to_gray is Generic(N : natural := 8); Port ( Binary : in STD_LOGIC_VECTOR (N-1 downto 0); Gray_Code : out STD_LOGIC_VECTOR (N-1 downto 0)); end binary_to_gray; architecture Behavioral of binary_to_gray is begin Gray_Code(0) <= Binary(0); process (Binary) begin for i in 1 to N-1 loop Gray_Code(i) <= Binary(i) xor Binary(i-1); end loop ; end process ; end Behavioral;
process(clk) begin if rising_edge(clk) then a_prev <= a; b_prev <= b; if (a = '1' and a_prev = '0' and b = '1') or (a = '0' and a_prev = '1' and b = '0') then counter <= counter + 1; elsif (a = '1' and a_prev = '0' and b = '0') or (a = '0' and a_prev = '1' and b = '1') then counter <= counter - 1; end if; end if; end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity Debouncer is Port ( Noisy_Button : in STD_LOGIC; Clean_Button_Pulse : out STD_LOGIC); end Debouncer; architecture Behavioral of Debouncer is signal debounce_counter : unsigned(7 downto 0) := (others => '0'); signal last_button_state : std_logic := '0'; begin process (Noisy_Button, debounce_counter, last_button_state) begin if rising_edge(Noisy_Button) then debounce_counter <= debounce_counter + 1; if debounce_counter = x"FF" then Clean_Button_Pulse <= '1'; last_button_state <= '0'; end if ; elsif falling_edge(Noisy_Button) then debounce_counter <= (others => '0'); if last_button_state = '0' then Clean_Button_Pulse <= '1'; last_button_state <= '1'; end if ; else Clean_Button_Pulse <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity JohnsonRingCounter is Generic(N : natural := 8); Port ( Clock : in STD_LOGIC; Reset : in STD_LOGIC; Count : out STD_LOGIC_VECTOR (N-1 downto 0)); end JohnsonRingCounter; architecture Behavioral of JohnsonRingCounter is signal tempCount : unsigned(N-1 downto 0) := (others => '0'); begin process (Clock, Reset) begin if Reset = '1' then tempCount <= (others => '0'); elsif rising_edge(Clock) then tempCount <= tempCount + 1; end if ; end process ; Count <= std_logic_vector(tempCount); end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity pulse_generator is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Pulse_Width : in STD_LOGIC_VECTOR (N-1 downto 0); Pulse_Out : out STD_LOGIC); end pulse_generator; architecture Behavioral of pulse_generator is signal counter : unsigned(N-1 downto 0) := (others => '0'); begin process (Clk, Reset) begin if Reset = '1' then counter <= (others => '0'); Pulse_Out <= '0'; elsif rising_edge(Clk) then if counter < unsigned(Pulse_Width) then counter <= counter + 1; Pulse_Out <= '1'; else counter <= (others => '0'); Pulse_Out <= '0'; end if ; end if ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity magnitude_comparator is Generic ( K : integer := 8 ); Port ( A : in STD_LOGIC_VECTOR (K-1 downto 0); B : in STD_LOGIC_VECTOR (K-1 downto 0); A_GT_B : out STD_LOGIC; A_EQ_B : out STD_LOGIC; A_LT_B : out STD_LOGIC); end magnitude_comparator; architecture Behavioral of magnitude_comparator is begin process (A, B) begin if (unsigned(A) > unsigned(B)) then A_GT_B <= '1'; A_EQ_B <= '0'; A_LT_B <= '0'; elsif (unsigned(A) < unsigned(B)) then A_GT_B <= '0'; A_EQ_B <= '0'; A_LT_B <= '1'; else A_GT_B <= '0'; A_EQ_B <= '1'; A_LT_B <= '0'; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity PRNG is generic ( N : natural := 32; SEED_VALUE : std_logic_vector(N-1 downto 0) := (others => '0'); RANDOM_NUMBER : std_logic_vector(N-1 downto 0); ); port ( clock : in std_logic; reset : in std_logic := '0'; seed_value : in std_logic_vector(N-1 downto 0) := SEED_VALUE; random_number : out std_logic_vector(N-1 downto 0); ); end PRNG; architecture behavioral of PRNG is begin process (clock, reset) variable state : std_logic_vector(N-1 downto 0); begin if (reset = '1') then state := SEED_VALUE; elsif (rising_edge(clock)) then state := state xor seed_value; end if ; random_number <= state; end process ; end behavioral;
process(clk) begin if rising_edge(clk) then if counter = DIVISION_FACTOR - 1 then counter <= 0; clk_out <= not clk_out; else counter <= counter + 1; end if; end if; end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity AsynchronousMultivibrator is Port ( Clk : in STD_LOGIC; Reset : in STD_LOGIC; Oscillating_Out : out STD_LOGIC); end AsynchronousMultivibrator; architecture Behavioral of AsynchronousMultivibrator is begin process (Clk, Reset) variable state: std_logic := '0'; begin if (Reset = '1') then state := '0'; elsif (rising_edge(Clk)) then state := not state; end if ; Oscillating_Out <= state; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity rotating_priority_encoder is Generic (N : natural := 8); Port ( Request : in STD_LOGIC_VECTOR (N-1 downto 0); Grant : out STD_LOGIC_VECTOR (log2(N)-1 downto 0); Valid : out STD_LOGIC; Rotation_Bit : out STD_LOGIC); end rotating_priority_encoder; architecture Behavioral of rotating_priority_encoder is begin process (Request) variable max_index : natural := 0; begin Valid <= '0'; Rotation_Bit <= '0'; for i in 0 to N-1 loop if Request(i) = '1' then max_index := i; Valid <= '1'; end if ; end loop ; Grant <= std_logic_vector(to_unsigned(max_index, log2(N))); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FloatingPointAdder is generic ( N : natural := 32 ); port ( A, B: in std_logic_vector(N-1 downto 0); Sum: out std_logic_vector(N-1 downto 0) ); end entity ; architecture Behavioral of FloatingPointAdder is begin process (A, B) begin for i in A'range loop Sum(i) <= A(i) xor B(i); end loop ; end process ; end architecture ;
entity comparator is port (a, b : in std_logic_vector(3 downto 0); lt, gt, eq : out std_logic); end entity; architecture Behavioral of comparator is begin process (a, b) begin if a < b then lt <= '1'; gt <= '0'; eq <= '0'; elsif a > b then lt <= '0'; gt <= '1'; eq <= '0'; else lt <= '0'; gt <= '0'; eq <= '1'; end if; end process; end architecture;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity mux_2to1 is Port ( Data0 : in STD_LOGIC; Data1 : in STD_LOGIC; Select : in STD_LOGIC; Data_Out : out STD_LOGIC); end mux_2to1; architecture Behavioral of mux_2to1 is begin process (Data0, Data1, Select) begin case Select is when '0' => Data_Out <= Data0; when '1' => Data_Out <= Data1; when others => Data_Out <= 'X'; end case ; end process ; end Behavioral;
process(clk,rst)begin if rst='1'then sclk<='0';mosi<='0';cs<='1';shift_reg<=(others=>'0');elsif rising_edge(clk)then cs<='0';sclk<=not sclk;if sclk='0'then shift_reg<=shift_reg(6 downto 0)&miso;mosi<=shift_reg(7);if bit_count=7 then cs<='1';end if;end if;end if;end process;
signal prev_signal:std_logic:='0';process(clk)begin if rising_edge(clk)then falling_edge_detected<=not signal and prev_signal;prev_signal<=signal;end if;end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity UniversalShiftRegister is Port ( Clock : in STD_LOGIC; Shift_Enable : in STD_LOGIC; Shift_Direction : in STD_LOGIC; Serial_In : in STD_LOGIC; Parallel_Out : out STD_LOGIC_VECTOR (P-1 downto 0); Serial_Out : out STD_LOGIC); end UniversalShiftRegister; architecture Behavioral of UniversalShiftRegister is signal shiftReg: STD_LOGIC_VECTOR(P-1 downto 0) := (others => '0'); begin process (Clock, Shift_Enable) begin if rising_edge(Clock) and Shift_Enable = '1' then if Shift_Direction = '0' then shiftReg <= shiftReg(P-2 downto 0) & Serial_In; else shiftReg <= Serial_In & shiftReg(P-1 downto 1); end if ; end if ; end process ; Parallel_Out <= shiftReg; Serial_Out <= shiftReg(0); end Behavioral;
process(input) begin output <= "000"; if input(7) = '1' then output <= "111"; elsif input(6) = '1' then output <= "110"; elsif input(5) = '1' then output <= "101"; elsif input(4) = '1' then output <= "100"; elsif input(3) = '1' then output <= "011"; elsif input(2) = '1' then output <= "010"; elsif input(1) = '1' then output <= "001"; end if; end process;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity RingCounter is generic (N : natural := 8); port ( clock: in std_logic; reset: in std_logic; ring_count: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of RingCounter is begin process (clock, reset) variable counter : natural range 0 to N-1 := 0; begin if (reset = '1') then counter := 0; elsif (rising_edge(clock)) then counter := counter + 1; if (counter = N-1) then counter := 0; end if ; end if ; ring_count <= std_logic_vector(to_unsigned(counter, N)); end process ; end architecture ;
entity bin_to_bcd is port (bin : in std_logic_vector(7 downto 0); bcd : out std_logic_vector(11 downto 0)); end entity; architecture Behavioral of bin_to_bcd is begin process (bin) variable bcd_tmp : std_logic_vector(11 downto 0) := (others => '0'); variable bin_tmp : std_logic_vector(7 downto 0) := bin; begin for i in 0 to 7 loop if bcd_tmp(11 downto 8) > "0100" then bcd_tmp(11 downto 8) := bcd_tmp(11 downto 8) + 3; end if; if bcd_tmp(7 downto 4) > "0100" then bcd_tmp(7 downto 4) := bcd_tmp(7 downto 4) + 3; end if; if bcd_tmp(3 downto 0) > "0100" then bcd_tmp(3 downto 0) := bcd_tmp(3 downto 0) + 3; end if; bcd_tmp := bcd_tmp(10 downto 0) & bin_tmp(7); bin_tmp := bin_tmp(6 downto 0) & '0'; end loop; bcd <= bcd_tmp; end process; end architecture;
entity pulse_gen is port (clk : in std_logic; rst : in std_logic; pulse_out : out std_logic); end entity; architecture Behavioral of pulse_gen is constant N : integer := 10; signal count : integer range 0 to N-1 := 0; begin process (clk, rst) begin if rst = '1' then count <= 0; pulse_out <= '0'; elsif rising_edge(clk) then if count = N-1 then count <= 0; pulse_out <= '1'; else count <= count + 1; pulse_out <= '0'; end if; end if; end process; end architecture;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity binary_to_bcd is Port ( Binary_Value : in STD_LOGIC_VECTOR ((N-1) downto 0); BCD_Value : out STD_LOGIC_VECTOR (((N/3)+1)-1 downto 0)); end binary_to_bcd; architecture Behavioral of binary_to_bcd is begin process (Binary_Value) variable temp : STD_LOGIC_VECTOR ((N/3)+1-1 downto 0); begin for i in 0 to (N/3)-1 loop temp((i*4+3) downto (i*4)) := Binary_Value(((N-1)-(i*4)) downto ((N-1)-(i*4)+3)); end loop ; BCD_Value <= temp; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity dual_port_ram is Generic ( K : natural := 8; L : natural := 32 ); Port ( Clock : in STD_LOGIC; Write_Enable : in STD_LOGIC; Read_Enable : in STD_LOGIC; Write_Address : in unsigned(log2(K)-1 downto 0); Read_Address : in unsigned(log2(K)-1 downto 0); Data_In : in STD_LOGIC_VECTOR (L-1 downto 0); Data_Out : out STD_LOGIC_VECTOR (L-1 downto 0) ); end dual_port_ram; architecture Behavioral of dual_port_ram is type ram_type is array (0 to K-1) of std_logic_vector(L-1 downto 0); signal RAM : ram_type := (others => (others => '0')); begin process (Clock, Write_Enable, Read_Address, Data_In) begin if rising_edge(Clock) then if Write_Enable = '1' then RAM(to_integer(Write_Address)) <= Data_In; end if ; end if ; Data_Out <= RAM(to_integer(Read_Address)); end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity dual_port_memory is Generic( K : integer := 8; L : integer := 32 ); Port( clk : in std_logic; write : in std_logic; address_w : in std_logic_vector((log2(K))-1 downto 0); address_r : in std_logic_vector((log2(K))-1 downto 0); data_write : in std_logic_vector(L-1 downto 0); data_read : out std_logic_vector(L-1 downto 0) ); end dual_port_memory; architecture behavioral of dual_port_memory is begin process (clk, write, address_w, address_r, data_write) variable memory : std_logic_vector(K*L-1 downto 0); begin if rising_edge(clk) then if write = '1' then memory(address_w) := data_write; end if ; data_read <= memory(address_r); end if ; end process ; end behavioral;
entity counter_4bit is port (clk : in std_logic; rst : in std_logic; q : out std_logic_vector(3 downto 0)); end entity; architecture Behavioral of counter_4bit is signal count : std_logic_vector(3 downto 0) := (others => '0'); begin process (clk, rst) begin if rst = '1' then count <= (others => '0'); elsif rising_edge(clk) then count <= count + 1; end if; end process; q <= count; end architecture;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity FIR_Filter is generic ( N: natural := 8; M: natural := 3 ); port ( clk: in std_logic; rst: in std_logic; data_in: in std_logic_vector(N-1 downto 0); coefficients: in std_logic_vector(M*N-1 downto 0); filtered_output: out std_logic_vector(N-1 downto 0) ); end FIR_Filter; architecture Behavioral of FIR_Filter is signal data_reg: std_logic_vector(N-1 downto 0); signal coefficients_reg: std_logic_vector(M*N-1 downto 0); begin process (clk, rst) variable sum: std_logic_vector(N-1 downto 0); begin if (rst = '1') then data_reg <= (others => '0'); coefficients_reg <= (others => '0'); elsif (rising_edge(clk)) then sum := (others => '0'); for i in 0 to M-1 loop sum := std_logic_vector(unsigned(sum) + unsigned(coefficients_reg((i+1)*N-1 downto i*N))); end loop ; data_reg <= data_in; coefficients_reg <= coefficients; filtered_output <= sum; end if ; end process ; end Behavioral;
process(clk, enable) begin gated_clk <= clk and enable; end process;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity floating_point_multiplier is generic ( N : natural := 32; P : natural := 8; R : natural := 23 ); port ( A, B: in std_logic_vector(N-1 downto 0); Product: out std_logic_vector(N-1 downto 0) ); end entity ; architecture behavioral of floating_point_multiplier is begin process (A, B) variable temp : std_logic_vector(N-1 downto 0); begin temp := A * B; Product <= temp; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity bcd_to_binary is Generic(N : integer := 8); Port ( BCD_Value : in STD_LOGIC_VECTOR ((N/3)+1-1 downto 0); Binary_Value : out STD_LOGIC_VECTOR (N-1 downto 0)); end bcd_to_binary; architecture Behavioral of bcd_to_binary is begin process (BCD_Value) variable temp : STD_LOGIC_VECTOR ((N/3)+1-1 downto 0); variable result : STD_LOGIC_VECTOR (N-1 downto 0); begin temp := BCD_Value; result := (others => '0'); for i in 0 to (N/3)-1 loop case temp(i) is when '0' => result((i*3)+2 downto (i*3)) := "000"; when '1' => result((i*3)+2 downto (i*3)) := "001"; when '2' => result((i*3)+2 downto (i*3)) := "010"; when '3' => result((i*3)+2 downto (i*3)) := "011"; when '4' => result((i*3)+2 downto (i*3)) := "100"; when '5' => result((i*3)+2 downto (i*3)) := "101"; when '6' => result((i*3)+2 downto (i*3)) := "110"; when '7' => result((i*3)+2 downto (i*3)) := "111"; when others => null; end case ; end loop ; Binary_Value <= result; end process ; end Behavioral;
process(clk) begin if rising_edge(clk) then if measure = '1' then if input = '1' and input_prev = '0' then pulse_count <= pulse_count + 1; end if; input_prev <= input; if ref_count = REF_PERIOD - 1 then frequency <= pulse_count; pulse_count <= 0; ref_count <= 0; else ref_count <= ref_count + 1; end if; end if; end if; end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity Digital_Differentiator is Generic ( N : natural := 8 ); Port ( Clk : in STD_LOGIC; Input_Data : in STD_LOGIC_VECTOR (N-1 downto 0); Differentiated_Data : out STD_LOGIC_VECTOR (N-1 downto 0)); end Digital_Differentiator; architecture Behavioral of Digital_Differentiator is signal previous_input : STD_LOGIC_VECTOR(N-1 downto 0); begin process (Clk) begin if rising_edge(Clk) then Differentiated_Data <= Input_Data - previous_input; previous_input <= Input_Data; end if ; end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity DigitalIntegrator is generic ( N : natural := 8 ); port ( Clock : in std_logic; Reset : in std_logic; Data_In : in std_logic_vector(N-1 downto 0); Integrated_Output : out std_logic_vector(N-1 downto 0) ); end DigitalIntegrator; architecture Behavioral of DigitalIntegrator is begin process (Clock, Reset) variable sum : unsigned(N-1 downto 0); begin if (Reset = '1') then sum := (others => '0'); elsif (rising_edge(Clock)) then sum := sum + Data_In; end if ; Integrated_Output <= std_logic_vector(sum); end process ; end Behavioral;
library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; entity crc_generator is generic (N : natural := 8); port ( clk : in std_logic; rst : in std_logic; data_in : in std_logic_vector(N-1 downto 0); polynomial : in std_logic_vector(M-1 downto 0); crc_value : out std_logic_vector(M-1 downto 0) ); end entity ; architecture behavioral of crc_generator is begin process (clk, rst) variable temp : std_logic_vector(M-1 downto 0); begin if rising_edge(clk) then if rst = '1' then temp := (others => '0'); else temp := polynomial; for i in 0 to N-1 loop if data_in(i) = '1' then temp := temp xor polynomial; end if ; end loop ; end if ; crc_value <= temp; end if ; end process ; end architecture ;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity priority_encoder is Generic(M : natural := 8); Port ( requests : in STD_LOGIC_VECTOR (2**M-1 downto 0); encoded : out STD_LOGIC_VECTOR (M-1 downto 0); valid : out STD_LOGIC); end priority_encoder; architecture Behavioral of priority_encoder is begin process (requests) variable max_index : natural := M-1; begin valid <= '0'; for i in 2**M-1 downto 0 loop if requests(i) = '1' then encoded <= std_logic_vector(to_unsigned(max_index, M)); valid <= '1'; exit; end if ; max_index := max_index - 1; end loop ; end process ; end Behavioral;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity unsigned_divider is Generic(N : positive := 8); Port ( dividend : in unsigned(N-1 downto 0); divisor : in unsigned(N-1 downto 0); quotient : out unsigned(N-1 downto 0); remainder : out unsigned(N-1 downto 0)); end unsigned_divider; architecture Behavioral of unsigned_divider is begin process (dividend, divisor) variable temp_quotient : unsigned(N-1 downto 0); variable temp_remainder : unsigned(N-1 downto 0); begin temp_quotient := (others => '0'); temp_remainder := dividend; for i in 0 to N-1 loop if temp_remainder >= divisor then temp_remainder := temp_remainder - divisor; temp_quotient(i) := '1'; end if ; end loop ; quotient <= temp_quotient; remainder <= temp_remainder; end process ; end Behavioral;
process(clk, rst) begin if rst = '1' then state <= IDLE; sda <= '1'; scl <= '1'; elsif rising_edge(clk) then case state is when IDLE => if start = '1' then state <= START; when START => sda <= '0'; state <= CLOCK_LOW; when CLOCK_LOW => scl <= '0'; if bit_count = 8 then state <= ACK; else state <= SHIFT_OUT; end if; when SHIFT_OUT => sda <= tx_data(7 - bit_count); state <= CLOCK_HIGH; when CLOCK_HIGH => scl <= '1'; state <= CLOCK_LOW; bit_count <= bit_count + 1; when ACK => state <= STOP; when STOP => sda <= '0'; scl <= '1'; state <= IDLE; end case; end if; end process;
process(clk) begin if rising_edge(clk) then phase_acc <= phase_acc + phase_inc; case waveform_select is when "00" => output <= sine_lut(to_integer(phase_acc(31 downto 24))); when "01" => output <= std_logic_vector(phase_acc(31 downto 16)); when "10" => output <= (31 => phase_acc(31), others => '0'); when others => if phase_acc(31) = '1' then output <= (others => '1'); else output <= (others => '0'); end if; end case; end if; end process;
library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ComparatorCircuit is Generic(K : natural := 8); Port ( Value1 : in STD_LOGIC_VECTOR (K-1 downto 0); Value2 : in STD_LOGIC_VECTOR (K-1 downto 0); Greater : out STD_LOGIC; Equal : out STD_LOGIC; Smaller : out STD_LOGIC); end ComparatorCircuit; architecture Behavioral of ComparatorCircuit is begin process (Value1, Value2) begin if (Value1 > Value2) then Greater <= '1'; Equal <= '0'; Smaller <= '0'; elsif (Value1 < Value2) then Greater <= '0'; Equal <= '0'; Smaller <= '1'; else Greater <= '0'; Equal <= '1'; Smaller <= '0'; end if ; end process ; end Behavioral;
if rising_edge(clk_i) then ;  end if; when other_st =>; cathodes_dot <= (not dot)&cathodes;
signal t_tick_o : std_logic; S <= (OP_A xor OP_B) xor CIN;
signal plaintext64: std_logic_vector ( 63 downto 0 ) := ( others => '0' ); signal data_out_reg, data_out_nxt : std_logic;
i_slc_counter <= DAC_CLK_DIV - 1; sck_edge : process (clk_i) begin ; end process ;
memi.edac <= gpioo.val(2); constant t_clock_multiplier : integer := 50;; i_sda <= data_i(i_bit_counter);
component counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end component; signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0);; signal i_cmd_state : cmd_state;
constant CLK_DIV : integer := 100; prova <= stringa1 & stringa2 & stringa3 & stringa4;
signal i_cs_re_tk : std_logic; anodes : out  STD_LOGIC_VECTOR (7 downto 0);
component mux_2_1 port(a0 : in STD_LOGIC; a1 : in STD_LOGIC; s : in STD_LOGIC; y : out STD_LOGIC); end component; round_key_in: out std_logic_vector(63 downto 0);
reg_count_nxt <= 0; initaddr := std_logic_vector((unsigned(initaddr) + 1));
COUT_RCA <= cout_int(N-1); constant d : std_logic_vector(6 downto 0) := "0100001";; TbClockB <= not TbClockB after TbPeriodB/2 when TbSimEnded /= '1' else '0';
signal i_sr_data : std_logic_vector(DATA_LEN - 1 downto 0); clk_process : process begin CLK <= '0'; wait for CLK_period/2; CLK <= '1'; wait for CLK_period/2; end process;; signal CLK : std_logic := '0';
counter <= c; component abox port (data_in:  in std_logic_vector(3 downto 0); data_out: out std_logic_vector(3 downto 0) ); end component;; if rst_n_i = '0' then ; end if;
signal t_dac_val_0 : std_logic_vector(DAC_D_OUT_LEN - 1 downto 0); i_cs <= sign_data(i_counter_3);
kupd: key_update port map(reg_key_in,round_counter,reg_key_out); signal t_rst_n : std_logic;
if rising_edge(clk_i) then if rst_n_i = '0' then i_bit_counter <= DAC_D_IN_LEN - 1; i_cmd_state <= idle_st; i_done <= '0'; i_cs <= '1'; i_sda <= '0'; i_ldac <= '1'; i_ldac_cnt <= 0; end if; end if; i_scl <= val_vector(i_counter_4);; rst_n_i : in std_logic;
constant count_max_value : integer := CLKIN_freq/(CLKOUT_freq)-1; sda_o <= i_sda when rst_n_i = '1' else '0';
stimulus: process begin wait for 100 ns; wait for 10 ns; a<="00"; wait for 10 ns; wait; end process; address(0) <= '0';; signal rst_n : std_logic := '1';
component unita_operativa is port(X, Y: in std_logic_vector(7 downto 0); clock, reset: in std_logic; loadAQ, shift, loadM, sub, selM, selAQ, selF, count_in: in std_logic; count: out std_logic_vector(2 downto 0); P: out std_logic_vector(15 downto 0)); end component; signal_20 <= signal_19(0);; done_o => t_done
i_data_1_out <= i_data_1_out(i_data_1_out'length - 4 downto 0) & i_sck_cpy; component ROM port (RST: in std_logic; ADDR : in std_logic_vector(2 downto 0); DATA : out std_logic_vector(31 downto 0)); end component;
constant four : std_logic_vector(6 downto 0) := "0011001"; if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
component ButtonDebouncer generic (CLK_period: integer := 10; btn_noise_time: integer := 10000000) port (RST : in STD_LOGIC; CLK : in STD_LOGIC; BTN : in STD_LOGIC; CLEARED_BTN : out STD_LOGIC); end component; signal data_out : std_logic_vector (31 downto 0);
signal data_out_temp1: std_logic_vector(63 downto 0); variable temperature : integer range -20 to 50 := 25;; signal i_ldac_cnt : integer range 0 to 4;
entity shift_reg is port(clk, rst, si : in std_logic; so : out std_logic); end shift_register; if t_rst_n = '0' then i_start_counter <= 0; t_start <= '0'; t_stb <= '0'; end if;
library ieee; signal current_state: state := secondo;
sda_i => t_sda; signal i_cmd_state : cmd_state;; component add_round_key is port (round_key_in: in std_logic_vector(63 downto 0); data_in: in std_logic_vector(63 downto 0); data_out: out std_logic_vector(63 downto 0) ); end component;
clk_process : process begin TbClockA <= '0'; wait for TbPeriodA/2; TbClockA <= '1'; wait for TbPeriodA/2; end process; count_nxt <= count_reg when enable = '0' else 0 when count_reg = DIV - 1 else count_reg + 1;; component shift_register port (CLK : in std_logic; RST : in std_logic; SI : in std_logic; SO : out std_logic); end component;
data_2_o => t_dac_val_2; if bar(21 downto 14) = x"2B" then ; end if;; with GPIO_enable select GPIO_inout <= 	GPIO_write when '1', 'Z' when others;assert output = '0' report "errore0" severity failure;
signal control : STD_LOGIC_VECTOR (1 downto 0) := (others => '0'); reg_key_in: in std_logic_vector(79 downto 0);
signal ytemp : std_logic_vector (3 downto 0); if abc(18 downto 11) = x"5E" then ; end if;; anodes : out  STD_LOGIC_VECTOR (7 downto 0);
wait for 100 ns; plaintext <= x"0000000000000000"; user_key <= x"00000000000000000000"; component unita_controllo is port(q0, clock, reset, start: in std_logic; count: in std_logic_vector(2 downto 0); loadM, count_in, loadAQ, en_shift: out std_logic; selM, selAQ, selF, subtract, stop_cu: out std_logic); end component;; constant c : std_logic_vector(6 downto 0) := "1000110";
signal enable : std_logic := '1'; with f select z <= 	b0 when '0', a1 when '1', '-' when others;; component counter is port ( clk : in STD_LOGIC; en : in STD_LOGIC; rst : in STD_LOGIC; count : out STD_LOGIC_VECTOR (2 downto 0)); end component;
wait until s0_arready = '1'; enable : in std_logic;; architecture behavioral of counter is begin end behavioral ;
kupd: key_update port map(reg_key_in,round_counter,reg_key_out); with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;
signal temp_selF: std_logic; case flag_code is when FLAG_1 => ; when FLAG_2 => ; when FLAG_3 => ; when FLAG_4 => ; when others => ; end case ;
signal u1 : STD_LOGIC := '0'; output_val <= val1 and val2;; if bar(21 downto 14) = x"2B" then ; end if;
signal en_tmp, req_tmp, ack_tmp, write_tmp: STD_LOGIC; signal i_ldac_cnt : integer range 0 to 4;
if ghi(16 downto 9) = x"77" then ; end if; case w is when 'U' => w := 'X'; when 'X' => null; when '0' => w := w2; when '+' | '-' => if w2 /= '0' then w := 'X'; end if; end case;
entity ROM_selector_onboard is port (clock_in : in STD_LOGIC; reset_in : in STD_LOGIC; addr_strobe_in : in STD_LOGIC; anodes_out : out STD_LOGIC_VECTOR(7 downto 0); cathodes_out : out STD_LOGIC_VECTOR(7 downto 0)); end ROM_selector_onboard; signal temp_stop_cu: std_logic;; signal TbClockA : std_logic := '0';
entity ripple_carry is port( X, Y: in std_logic_vector(7 downto 0); c_in: in std_logic; c_out: out std_logic; Z: out std_logic_vector(7 downto 0)); end ripple_carry; with c.b_request_complete select c.a_request.be <= c.sys_master_ctrl_out.be when '1', r.b_request.be when '0', 'X' when others;; library ieee;
if i_start_counter < START_DLY - 1 then i_start_counter <= i_start_counter + 1; t_start <= '0'; end if; with ciao select y <= a0 when '0', a1 when '1', '-' when others;
clk2xgen: if (clk2xen /= 0) generate clkena(1 downto 0) <= "11"; end generate; signal round_key_temp: std_logic_vector(63 downto 0);; component sbox is port(); end component;
signal t_stb : std_logic; key_temp1 <= reg_key_in( 18 downto 0 ) & reg_key_in( 79 downto 19 );
result_sig <= input_x xor input_y; signal i_sck_cpy : std_logic;; pl: perm_layer port map (data_out_temp2,data_out);
seven_segment_array: display_seven_segments generic map(CLKIN_freq => 100000000, CLKOUT_freq => 500) port map(CLK => clock_in, RST => reset_n, value => value_temp, enable => "11111111", dots => "00000000", anodes => anodes_out, cathodes => cathodes_out); i_sda <= data_i(i_bit_counter);
signal i_data_5 : std_logic_vector(DOUT_LEN - 1 downto 0); data_2_o => t_dac_val_2; scl_i : in std_logic;
case (a) is when "00" => y <= "1000"; when "01" => y <= "0100"; when "10" => y <= "0010"; when "11" => y <= "0001"; when others => y <="----"; end case; signal reg_count_nxt : integer range 0 to clock_multiplier - 1;
data_1_o <= i_data_1_out when rst_n_i = '1' else (others => '0'); x <= y & z; signal i_data_3_out : std_logic_vector(DOUT_LEN - 1 downto 0);
scl_i => t_scl; entity Encoder_onBoard is port ( switch : in STD_LOGIC_VECTOR(9 downto 0); led : out STD_LOGIC_VECTOR(3 downto 0); catodi : out STD_LOGIC_VECTOR(7 downto 0); anodi : out STD_LOGIC_VECTOR(7 downto 0)); end Encoder_onBoard;
i_cs_re_tk <= '1' when i_cs_cpy = '0' and i_cs = '1' else '0'; variable limit : integer range 0 to 255 := 255;
wait for 10 ns; cs_o : out std_logic;
